var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$1 = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, e$3 = Symbol(), n$5 = new Map();
class s$3 {
  constructor(t2, n2) {
    if (this._$cssResult$ = true, n2 !== e$3)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t2;
  }
  get styleSheet() {
    let e2 = n$5.get(this.cssText);
    return t$1 && e2 === void 0 && (n$5.set(this.cssText, e2 = new CSSStyleSheet()), e2.replaceSync(this.cssText)), e2;
  }
  toString() {
    return this.cssText;
  }
}
const o$4 = (t2) => new s$3(typeof t2 == "string" ? t2 : t2 + "", e$3), r$2 = (t2, ...n2) => {
  const o2 = t2.length === 1 ? t2[0] : n2.reduce((e2, n3, s2) => e2 + ((t3) => {
    if (t3._$cssResult$ === true)
      return t3.cssText;
    if (typeof t3 == "number")
      return t3;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t3 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(n3) + t2[s2 + 1], t2[0]);
  return new s$3(o2, e$3);
}, i$3 = (e2, n2) => {
  t$1 ? e2.adoptedStyleSheets = n2.map((t2) => t2 instanceof CSSStyleSheet ? t2 : t2.styleSheet) : n2.forEach((t2) => {
    const n3 = document.createElement("style"), s2 = window.litNonce;
    s2 !== void 0 && n3.setAttribute("nonce", s2), n3.textContent = t2.cssText, e2.appendChild(n3);
  });
}, S$1 = t$1 ? (t2) => t2 : (t2) => t2 instanceof CSSStyleSheet ? ((t3) => {
  let e2 = "";
  for (const n2 of t3.cssRules)
    e2 += n2.cssText;
  return o$4(e2);
})(t2) : t2;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var s$2;
const e$2 = window.trustedTypes, r$1 = e$2 ? e$2.emptyScript : "", h$1 = window.reactiveElementPolyfillSupport, o$3 = { toAttribute(t2, i2) {
  switch (i2) {
    case Boolean:
      t2 = t2 ? r$1 : null;
      break;
    case Object:
    case Array:
      t2 = t2 == null ? t2 : JSON.stringify(t2);
  }
  return t2;
}, fromAttribute(t2, i2) {
  let s2 = t2;
  switch (i2) {
    case Boolean:
      s2 = t2 !== null;
      break;
    case Number:
      s2 = t2 === null ? null : Number(t2);
      break;
    case Object:
    case Array:
      try {
        s2 = JSON.parse(t2);
      } catch (t3) {
        s2 = null;
      }
  }
  return s2;
} }, n$4 = (t2, i2) => i2 !== t2 && (i2 == i2 || t2 == t2), l$2 = { attribute: true, type: String, converter: o$3, reflect: false, hasChanged: n$4 };
class a$1 extends HTMLElement {
  constructor() {
    super(), this._$Et = new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$Ei = null, this.o();
  }
  static addInitializer(t2) {
    var i2;
    (i2 = this.l) !== null && i2 !== void 0 || (this.l = []), this.l.push(t2);
  }
  static get observedAttributes() {
    this.finalize();
    const t2 = [];
    return this.elementProperties.forEach((i2, s2) => {
      const e2 = this._$Eh(s2, i2);
      e2 !== void 0 && (this._$Eu.set(e2, s2), t2.push(e2));
    }), t2;
  }
  static createProperty(t2, i2 = l$2) {
    if (i2.state && (i2.attribute = false), this.finalize(), this.elementProperties.set(t2, i2), !i2.noAccessor && !this.prototype.hasOwnProperty(t2)) {
      const s2 = typeof t2 == "symbol" ? Symbol() : "__" + t2, e2 = this.getPropertyDescriptor(t2, s2, i2);
      e2 !== void 0 && Object.defineProperty(this.prototype, t2, e2);
    }
  }
  static getPropertyDescriptor(t2, i2, s2) {
    return { get() {
      return this[i2];
    }, set(e2) {
      const r2 = this[t2];
      this[i2] = e2, this.requestUpdate(t2, r2, s2);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t2) {
    return this.elementProperties.get(t2) || l$2;
  }
  static finalize() {
    if (this.hasOwnProperty("finalized"))
      return false;
    this.finalized = true;
    const t2 = Object.getPrototypeOf(this);
    if (t2.finalize(), this.elementProperties = new Map(t2.elementProperties), this._$Eu = new Map(), this.hasOwnProperty("properties")) {
      const t3 = this.properties, i2 = [...Object.getOwnPropertyNames(t3), ...Object.getOwnPropertySymbols(t3)];
      for (const s2 of i2)
        this.createProperty(s2, t3[s2]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), true;
  }
  static finalizeStyles(i2) {
    const s2 = [];
    if (Array.isArray(i2)) {
      const e2 = new Set(i2.flat(1 / 0).reverse());
      for (const i3 of e2)
        s2.unshift(S$1(i3));
    } else
      i2 !== void 0 && s2.push(S$1(i2));
    return s2;
  }
  static _$Eh(t2, i2) {
    const s2 = i2.attribute;
    return s2 === false ? void 0 : typeof s2 == "string" ? s2 : typeof t2 == "string" ? t2.toLowerCase() : void 0;
  }
  o() {
    var t2;
    this._$Ep = new Promise((t3) => this.enableUpdating = t3), this._$AL = new Map(), this._$Em(), this.requestUpdate(), (t2 = this.constructor.l) === null || t2 === void 0 || t2.forEach((t3) => t3(this));
  }
  addController(t2) {
    var i2, s2;
    ((i2 = this._$Eg) !== null && i2 !== void 0 ? i2 : this._$Eg = []).push(t2), this.renderRoot !== void 0 && this.isConnected && ((s2 = t2.hostConnected) === null || s2 === void 0 || s2.call(t2));
  }
  removeController(t2) {
    var i2;
    (i2 = this._$Eg) === null || i2 === void 0 || i2.splice(this._$Eg.indexOf(t2) >>> 0, 1);
  }
  _$Em() {
    this.constructor.elementProperties.forEach((t2, i2) => {
      this.hasOwnProperty(i2) && (this._$Et.set(i2, this[i2]), delete this[i2]);
    });
  }
  createRenderRoot() {
    var t2;
    const s2 = (t2 = this.shadowRoot) !== null && t2 !== void 0 ? t2 : this.attachShadow(this.constructor.shadowRootOptions);
    return i$3(s2, this.constructor.elementStyles), s2;
  }
  connectedCallback() {
    var t2;
    this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (t2 = this._$Eg) === null || t2 === void 0 || t2.forEach((t3) => {
      var i2;
      return (i2 = t3.hostConnected) === null || i2 === void 0 ? void 0 : i2.call(t3);
    });
  }
  enableUpdating(t2) {
  }
  disconnectedCallback() {
    var t2;
    (t2 = this._$Eg) === null || t2 === void 0 || t2.forEach((t3) => {
      var i2;
      return (i2 = t3.hostDisconnected) === null || i2 === void 0 ? void 0 : i2.call(t3);
    });
  }
  attributeChangedCallback(t2, i2, s2) {
    this._$AK(t2, s2);
  }
  _$ES(t2, i2, s2 = l$2) {
    var e2, r2;
    const h2 = this.constructor._$Eh(t2, s2);
    if (h2 !== void 0 && s2.reflect === true) {
      const n2 = ((r2 = (e2 = s2.converter) === null || e2 === void 0 ? void 0 : e2.toAttribute) !== null && r2 !== void 0 ? r2 : o$3.toAttribute)(i2, s2.type);
      this._$Ei = t2, n2 == null ? this.removeAttribute(h2) : this.setAttribute(h2, n2), this._$Ei = null;
    }
  }
  _$AK(t2, i2) {
    var s2, e2, r2;
    const h2 = this.constructor, n2 = h2._$Eu.get(t2);
    if (n2 !== void 0 && this._$Ei !== n2) {
      const t3 = h2.getPropertyOptions(n2), l2 = t3.converter, a2 = (r2 = (e2 = (s2 = l2) === null || s2 === void 0 ? void 0 : s2.fromAttribute) !== null && e2 !== void 0 ? e2 : typeof l2 == "function" ? l2 : null) !== null && r2 !== void 0 ? r2 : o$3.fromAttribute;
      this._$Ei = n2, this[n2] = a2(i2, t3.type), this._$Ei = null;
    }
  }
  requestUpdate(t2, i2, s2) {
    let e2 = true;
    t2 !== void 0 && (((s2 = s2 || this.constructor.getPropertyOptions(t2)).hasChanged || n$4)(this[t2], i2) ? (this._$AL.has(t2) || this._$AL.set(t2, i2), s2.reflect === true && this._$Ei !== t2 && (this._$E_ === void 0 && (this._$E_ = new Map()), this._$E_.set(t2, s2))) : e2 = false), !this.isUpdatePending && e2 && (this._$Ep = this._$EC());
  }
  async _$EC() {
    this.isUpdatePending = true;
    try {
      await this._$Ep;
    } catch (t3) {
      Promise.reject(t3);
    }
    const t2 = this.scheduleUpdate();
    return t2 != null && await t2, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t2;
    if (!this.isUpdatePending)
      return;
    this.hasUpdated, this._$Et && (this._$Et.forEach((t3, i3) => this[i3] = t3), this._$Et = void 0);
    let i2 = false;
    const s2 = this._$AL;
    try {
      i2 = this.shouldUpdate(s2), i2 ? (this.willUpdate(s2), (t2 = this._$Eg) === null || t2 === void 0 || t2.forEach((t3) => {
        var i3;
        return (i3 = t3.hostUpdate) === null || i3 === void 0 ? void 0 : i3.call(t3);
      }), this.update(s2)) : this._$EU();
    } catch (t3) {
      throw i2 = false, this._$EU(), t3;
    }
    i2 && this._$AE(s2);
  }
  willUpdate(t2) {
  }
  _$AE(t2) {
    var i2;
    (i2 = this._$Eg) === null || i2 === void 0 || i2.forEach((t3) => {
      var i3;
      return (i3 = t3.hostUpdated) === null || i3 === void 0 ? void 0 : i3.call(t3);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t2)), this.updated(t2);
  }
  _$EU() {
    this._$AL = new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$Ep;
  }
  shouldUpdate(t2) {
    return true;
  }
  update(t2) {
    this._$E_ !== void 0 && (this._$E_.forEach((t3, i2) => this._$ES(i2, this[i2], t3)), this._$E_ = void 0), this._$EU();
  }
  updated(t2) {
  }
  firstUpdated(t2) {
  }
}
a$1.finalized = true, a$1.elementProperties = new Map(), a$1.elementStyles = [], a$1.shadowRootOptions = { mode: "open" }, h$1 == null || h$1({ ReactiveElement: a$1 }), ((s$2 = globalThis.reactiveElementVersions) !== null && s$2 !== void 0 ? s$2 : globalThis.reactiveElementVersions = []).push("1.2.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var t;
const i$2 = globalThis.trustedTypes, s$1 = i$2 ? i$2.createPolicy("lit-html", { createHTML: (t2) => t2 }) : void 0, e$1 = `lit$${(Math.random() + "").slice(9)}$`, o$2 = "?" + e$1, n$3 = `<${o$2}>`, l$1 = document, h = (t2 = "") => l$1.createComment(t2), r = (t2) => t2 === null || typeof t2 != "object" && typeof t2 != "function", d = Array.isArray, u = (t2) => {
  var i2;
  return d(t2) || typeof ((i2 = t2) === null || i2 === void 0 ? void 0 : i2[Symbol.iterator]) == "function";
}, c = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, v = /-->/g, a = />/g, f = />|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g, _ = /'/g, m = /"/g, g = /^(?:script|style|textarea)$/i, p = (t2) => (i2, ...s2) => ({ _$litType$: t2, strings: i2, values: s2 }), $$1 = p(1), b = Symbol.for("lit-noChange"), w = Symbol.for("lit-nothing"), T = new WeakMap(), x = (t2, i2, s2) => {
  var e2, o2;
  const n2 = (e2 = s2 == null ? void 0 : s2.renderBefore) !== null && e2 !== void 0 ? e2 : i2;
  let l2 = n2._$litPart$;
  if (l2 === void 0) {
    const t3 = (o2 = s2 == null ? void 0 : s2.renderBefore) !== null && o2 !== void 0 ? o2 : null;
    n2._$litPart$ = l2 = new N(i2.insertBefore(h(), t3), t3, void 0, s2 != null ? s2 : {});
  }
  return l2._$AI(t2), l2;
}, A = l$1.createTreeWalker(l$1, 129, null, false), C = (t2, i2) => {
  const o2 = t2.length - 1, l2 = [];
  let h2, r2 = i2 === 2 ? "<svg>" : "", d2 = c;
  for (let i3 = 0; i3 < o2; i3++) {
    const s2 = t2[i3];
    let o3, u3, p2 = -1, $2 = 0;
    for (; $2 < s2.length && (d2.lastIndex = $2, u3 = d2.exec(s2), u3 !== null); )
      $2 = d2.lastIndex, d2 === c ? u3[1] === "!--" ? d2 = v : u3[1] !== void 0 ? d2 = a : u3[2] !== void 0 ? (g.test(u3[2]) && (h2 = RegExp("</" + u3[2], "g")), d2 = f) : u3[3] !== void 0 && (d2 = f) : d2 === f ? u3[0] === ">" ? (d2 = h2 != null ? h2 : c, p2 = -1) : u3[1] === void 0 ? p2 = -2 : (p2 = d2.lastIndex - u3[2].length, o3 = u3[1], d2 = u3[3] === void 0 ? f : u3[3] === '"' ? m : _) : d2 === m || d2 === _ ? d2 = f : d2 === v || d2 === a ? d2 = c : (d2 = f, h2 = void 0);
    const y = d2 === f && t2[i3 + 1].startsWith("/>") ? " " : "";
    r2 += d2 === c ? s2 + n$3 : p2 >= 0 ? (l2.push(o3), s2.slice(0, p2) + "$lit$" + s2.slice(p2) + e$1 + y) : s2 + e$1 + (p2 === -2 ? (l2.push(void 0), i3) : y);
  }
  const u2 = r2 + (t2[o2] || "<?>") + (i2 === 2 ? "</svg>" : "");
  if (!Array.isArray(t2) || !t2.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return [s$1 !== void 0 ? s$1.createHTML(u2) : u2, l2];
};
class E {
  constructor({ strings: t2, _$litType$: s2 }, n2) {
    let l2;
    this.parts = [];
    let r2 = 0, d2 = 0;
    const u2 = t2.length - 1, c2 = this.parts, [v2, a2] = C(t2, s2);
    if (this.el = E.createElement(v2, n2), A.currentNode = this.el.content, s2 === 2) {
      const t3 = this.el.content, i2 = t3.firstChild;
      i2.remove(), t3.append(...i2.childNodes);
    }
    for (; (l2 = A.nextNode()) !== null && c2.length < u2; ) {
      if (l2.nodeType === 1) {
        if (l2.hasAttributes()) {
          const t3 = [];
          for (const i2 of l2.getAttributeNames())
            if (i2.endsWith("$lit$") || i2.startsWith(e$1)) {
              const s3 = a2[d2++];
              if (t3.push(i2), s3 !== void 0) {
                const t4 = l2.getAttribute(s3.toLowerCase() + "$lit$").split(e$1), i3 = /([.?@])?(.*)/.exec(s3);
                c2.push({ type: 1, index: r2, name: i3[2], strings: t4, ctor: i3[1] === "." ? M : i3[1] === "?" ? H : i3[1] === "@" ? I : S });
              } else
                c2.push({ type: 6, index: r2 });
            }
          for (const i2 of t3)
            l2.removeAttribute(i2);
        }
        if (g.test(l2.tagName)) {
          const t3 = l2.textContent.split(e$1), s3 = t3.length - 1;
          if (s3 > 0) {
            l2.textContent = i$2 ? i$2.emptyScript : "";
            for (let i2 = 0; i2 < s3; i2++)
              l2.append(t3[i2], h()), A.nextNode(), c2.push({ type: 2, index: ++r2 });
            l2.append(t3[s3], h());
          }
        }
      } else if (l2.nodeType === 8)
        if (l2.data === o$2)
          c2.push({ type: 2, index: r2 });
        else {
          let t3 = -1;
          for (; (t3 = l2.data.indexOf(e$1, t3 + 1)) !== -1; )
            c2.push({ type: 7, index: r2 }), t3 += e$1.length - 1;
        }
      r2++;
    }
  }
  static createElement(t2, i2) {
    const s2 = l$1.createElement("template");
    return s2.innerHTML = t2, s2;
  }
}
function P(t2, i2, s2 = t2, e2) {
  var o2, n2, l2, h2;
  if (i2 === b)
    return i2;
  let d2 = e2 !== void 0 ? (o2 = s2._$Cl) === null || o2 === void 0 ? void 0 : o2[e2] : s2._$Cu;
  const u2 = r(i2) ? void 0 : i2._$litDirective$;
  return (d2 == null ? void 0 : d2.constructor) !== u2 && ((n2 = d2 == null ? void 0 : d2._$AO) === null || n2 === void 0 || n2.call(d2, false), u2 === void 0 ? d2 = void 0 : (d2 = new u2(t2), d2._$AT(t2, s2, e2)), e2 !== void 0 ? ((l2 = (h2 = s2)._$Cl) !== null && l2 !== void 0 ? l2 : h2._$Cl = [])[e2] = d2 : s2._$Cu = d2), d2 !== void 0 && (i2 = P(t2, d2._$AS(t2, i2.values), d2, e2)), i2;
}
class V {
  constructor(t2, i2) {
    this.v = [], this._$AN = void 0, this._$AD = t2, this._$AM = i2;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  p(t2) {
    var i2;
    const { el: { content: s2 }, parts: e2 } = this._$AD, o2 = ((i2 = t2 == null ? void 0 : t2.creationScope) !== null && i2 !== void 0 ? i2 : l$1).importNode(s2, true);
    A.currentNode = o2;
    let n2 = A.nextNode(), h2 = 0, r2 = 0, d2 = e2[0];
    for (; d2 !== void 0; ) {
      if (h2 === d2.index) {
        let i3;
        d2.type === 2 ? i3 = new N(n2, n2.nextSibling, this, t2) : d2.type === 1 ? i3 = new d2.ctor(n2, d2.name, d2.strings, this, t2) : d2.type === 6 && (i3 = new L(n2, this, t2)), this.v.push(i3), d2 = e2[++r2];
      }
      h2 !== (d2 == null ? void 0 : d2.index) && (n2 = A.nextNode(), h2++);
    }
    return o2;
  }
  m(t2) {
    let i2 = 0;
    for (const s2 of this.v)
      s2 !== void 0 && (s2.strings !== void 0 ? (s2._$AI(t2, s2, i2), i2 += s2.strings.length - 2) : s2._$AI(t2[i2])), i2++;
  }
}
class N {
  constructor(t2, i2, s2, e2) {
    var o2;
    this.type = 2, this._$AH = w, this._$AN = void 0, this._$AA = t2, this._$AB = i2, this._$AM = s2, this.options = e2, this._$Cg = (o2 = e2 == null ? void 0 : e2.isConnected) === null || o2 === void 0 || o2;
  }
  get _$AU() {
    var t2, i2;
    return (i2 = (t2 = this._$AM) === null || t2 === void 0 ? void 0 : t2._$AU) !== null && i2 !== void 0 ? i2 : this._$Cg;
  }
  get parentNode() {
    let t2 = this._$AA.parentNode;
    const i2 = this._$AM;
    return i2 !== void 0 && t2.nodeType === 11 && (t2 = i2.parentNode), t2;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t2, i2 = this) {
    t2 = P(this, t2, i2), r(t2) ? t2 === w || t2 == null || t2 === "" ? (this._$AH !== w && this._$AR(), this._$AH = w) : t2 !== this._$AH && t2 !== b && this.$(t2) : t2._$litType$ !== void 0 ? this.T(t2) : t2.nodeType !== void 0 ? this.S(t2) : u(t2) ? this.A(t2) : this.$(t2);
  }
  M(t2, i2 = this._$AB) {
    return this._$AA.parentNode.insertBefore(t2, i2);
  }
  S(t2) {
    this._$AH !== t2 && (this._$AR(), this._$AH = this.M(t2));
  }
  $(t2) {
    this._$AH !== w && r(this._$AH) ? this._$AA.nextSibling.data = t2 : this.S(l$1.createTextNode(t2)), this._$AH = t2;
  }
  T(t2) {
    var i2;
    const { values: s2, _$litType$: e2 } = t2, o2 = typeof e2 == "number" ? this._$AC(t2) : (e2.el === void 0 && (e2.el = E.createElement(e2.h, this.options)), e2);
    if (((i2 = this._$AH) === null || i2 === void 0 ? void 0 : i2._$AD) === o2)
      this._$AH.m(s2);
    else {
      const t3 = new V(o2, this), i3 = t3.p(this.options);
      t3.m(s2), this.S(i3), this._$AH = t3;
    }
  }
  _$AC(t2) {
    let i2 = T.get(t2.strings);
    return i2 === void 0 && T.set(t2.strings, i2 = new E(t2)), i2;
  }
  A(t2) {
    d(this._$AH) || (this._$AH = [], this._$AR());
    const i2 = this._$AH;
    let s2, e2 = 0;
    for (const o2 of t2)
      e2 === i2.length ? i2.push(s2 = new N(this.M(h()), this.M(h()), this, this.options)) : s2 = i2[e2], s2._$AI(o2), e2++;
    e2 < i2.length && (this._$AR(s2 && s2._$AB.nextSibling, e2), i2.length = e2);
  }
  _$AR(t2 = this._$AA.nextSibling, i2) {
    var s2;
    for ((s2 = this._$AP) === null || s2 === void 0 || s2.call(this, false, true, i2); t2 && t2 !== this._$AB; ) {
      const i3 = t2.nextSibling;
      t2.remove(), t2 = i3;
    }
  }
  setConnected(t2) {
    var i2;
    this._$AM === void 0 && (this._$Cg = t2, (i2 = this._$AP) === null || i2 === void 0 || i2.call(this, t2));
  }
}
class S {
  constructor(t2, i2, s2, e2, o2) {
    this.type = 1, this._$AH = w, this._$AN = void 0, this.element = t2, this.name = i2, this._$AM = e2, this.options = o2, s2.length > 2 || s2[0] !== "" || s2[1] !== "" ? (this._$AH = Array(s2.length - 1).fill(new String()), this.strings = s2) : this._$AH = w;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t2, i2 = this, s2, e2) {
    const o2 = this.strings;
    let n2 = false;
    if (o2 === void 0)
      t2 = P(this, t2, i2, 0), n2 = !r(t2) || t2 !== this._$AH && t2 !== b, n2 && (this._$AH = t2);
    else {
      const e3 = t2;
      let l2, h2;
      for (t2 = o2[0], l2 = 0; l2 < o2.length - 1; l2++)
        h2 = P(this, e3[s2 + l2], i2, l2), h2 === b && (h2 = this._$AH[l2]), n2 || (n2 = !r(h2) || h2 !== this._$AH[l2]), h2 === w ? t2 = w : t2 !== w && (t2 += (h2 != null ? h2 : "") + o2[l2 + 1]), this._$AH[l2] = h2;
    }
    n2 && !e2 && this.k(t2);
  }
  k(t2) {
    t2 === w ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t2 != null ? t2 : "");
  }
}
class M extends S {
  constructor() {
    super(...arguments), this.type = 3;
  }
  k(t2) {
    this.element[this.name] = t2 === w ? void 0 : t2;
  }
}
const k = i$2 ? i$2.emptyScript : "";
class H extends S {
  constructor() {
    super(...arguments), this.type = 4;
  }
  k(t2) {
    t2 && t2 !== w ? this.element.setAttribute(this.name, k) : this.element.removeAttribute(this.name);
  }
}
class I extends S {
  constructor(t2, i2, s2, e2, o2) {
    super(t2, i2, s2, e2, o2), this.type = 5;
  }
  _$AI(t2, i2 = this) {
    var s2;
    if ((t2 = (s2 = P(this, t2, i2, 0)) !== null && s2 !== void 0 ? s2 : w) === b)
      return;
    const e2 = this._$AH, o2 = t2 === w && e2 !== w || t2.capture !== e2.capture || t2.once !== e2.once || t2.passive !== e2.passive, n2 = t2 !== w && (e2 === w || o2);
    o2 && this.element.removeEventListener(this.name, this, e2), n2 && this.element.addEventListener(this.name, this, t2), this._$AH = t2;
  }
  handleEvent(t2) {
    var i2, s2;
    typeof this._$AH == "function" ? this._$AH.call((s2 = (i2 = this.options) === null || i2 === void 0 ? void 0 : i2.host) !== null && s2 !== void 0 ? s2 : this.element, t2) : this._$AH.handleEvent(t2);
  }
}
class L {
  constructor(t2, i2, s2) {
    this.element = t2, this.type = 6, this._$AN = void 0, this._$AM = i2, this.options = s2;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t2) {
    P(this, t2);
  }
}
const z = window.litHtmlPolyfillSupport;
z == null || z(E, N), ((t = globalThis.litHtmlVersions) !== null && t !== void 0 ? t : globalThis.litHtmlVersions = []).push("2.1.2");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var l, o$1;
class s extends a$1 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Dt = void 0;
  }
  createRenderRoot() {
    var t2, e2;
    const i2 = super.createRenderRoot();
    return (t2 = (e2 = this.renderOptions).renderBefore) !== null && t2 !== void 0 || (e2.renderBefore = i2.firstChild), i2;
  }
  update(t2) {
    const i2 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t2), this._$Dt = x(i2, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t2;
    super.connectedCallback(), (t2 = this._$Dt) === null || t2 === void 0 || t2.setConnected(true);
  }
  disconnectedCallback() {
    var t2;
    super.disconnectedCallback(), (t2 = this._$Dt) === null || t2 === void 0 || t2.setConnected(false);
  }
  render() {
    return b;
  }
}
s.finalized = true, s._$litElement$ = true, (l = globalThis.litElementHydrateSupport) === null || l === void 0 || l.call(globalThis, { LitElement: s });
const n$2 = globalThis.litElementPolyfillSupport;
n$2 == null || n$2({ LitElement: s });
((o$1 = globalThis.litElementVersions) !== null && o$1 !== void 0 ? o$1 : globalThis.litElementVersions = []).push("3.1.2");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const n$1 = (n2) => (e2) => typeof e2 == "function" ? ((n3, e3) => (window.customElements.define(n3, e3), e3))(n2, e2) : ((n3, e3) => {
  const { kind: t2, elements: i2 } = e3;
  return { kind: t2, elements: i2, finisher(e4) {
    window.customElements.define(n3, e4);
  } };
})(n2, e2);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const i$1 = (i2, e2) => e2.kind === "method" && e2.descriptor && !("value" in e2.descriptor) ? __spreadProps(__spreadValues({}, e2), { finisher(n2) {
  n2.createProperty(e2.key, i2);
} }) : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: e2.key, initializer() {
  typeof e2.initializer == "function" && (this[e2.key] = e2.initializer.call(this));
}, finisher(n2) {
  n2.createProperty(e2.key, i2);
} };
function e(e2) {
  return (n2, t2) => t2 !== void 0 ? ((i2, e3, n3) => {
    e3.constructor.createProperty(n3, i2);
  })(e2, n2, t2) : i$1(e2, n2);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o = ({ finisher: e2, descriptor: t2 }) => (o2, n2) => {
  var r2;
  if (n2 === void 0) {
    const n3 = (r2 = o2.originalKey) !== null && r2 !== void 0 ? r2 : o2.key, i2 = t2 != null ? { kind: "method", placement: "prototype", key: n3, descriptor: t2(o2.key) } : __spreadProps(__spreadValues({}, o2), { key: n3 });
    return e2 != null && (i2.finisher = function(t3) {
      e2(t3, n3);
    }), i2;
  }
  {
    const r3 = o2.constructor;
    t2 !== void 0 && Object.defineProperty(o2, n2, t2(n2)), e2 == null || e2(r3, n2);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function i(i2, n2) {
  return o({ descriptor: (o2) => {
    const t2 = { get() {
      var o3, n3;
      return (n3 = (o3 = this.renderRoot) === null || o3 === void 0 ? void 0 : o3.querySelector(i2)) !== null && n3 !== void 0 ? n3 : null;
    }, enumerable: true, configurable: true };
    if (n2) {
      const n3 = typeof o2 == "symbol" ? Symbol() : "__" + o2;
      t2.get = function() {
        var o3, t3;
        return this[n3] === void 0 && (this[n3] = (t3 = (o3 = this.renderRoot) === null || o3 === void 0 ? void 0 : o3.querySelector(i2)) !== null && t3 !== void 0 ? t3 : null), this[n3];
      };
    }
    return t2;
  } });
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var n;
((n = window.HTMLSlotElement) === null || n === void 0 ? void 0 : n.prototype.assignedElements) != null ? (o2, n2) => o2.assignedElements(n2) : (o2, n2) => o2.assignedNodes(n2).filter((o3) => o3.nodeType === Node.ELEMENT_NODE);
function injectCSS(styles2, styleElement = document.createElement("style")) {
  styleElement.innerHTML = styles2.cssText;
  document.head.appendChild(styleElement);
  return styleElement;
}
const swiperIconCss = r$2`
  @font-face {
    font-family: qy-swiper-icons;
    src: url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA') format('woff');
    font-weight: 400;
    font-style: normal;
  }
`;
injectCSS(swiperIconCss);
const swiperStyles = r$2`.swiper-container{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1}.swiper-container-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;box-sizing:content-box}.swiper-container-android .swiper-slide,.swiper-wrapper{transform:translate3d(0px,0,0)}.swiper-container-multirow>.swiper-wrapper{flex-wrap:wrap}.swiper-container-multirow-column>.swiper-wrapper{flex-wrap:wrap;flex-direction:column}.swiper-container-free-mode>.swiper-wrapper{transition-timing-function:ease-out;margin:0 auto}.swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform}.swiper-slide-invisible-blank{visibility:hidden}.swiper-container-autoheight,.swiper-container-autoheight .swiper-slide{height:auto}.swiper-container-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-container-3d{perspective:1200px}.swiper-container-3d .swiper-cube-shadow,.swiper-container-3d .swiper-slide,.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-container-3d .swiper-slide-shadow-left{background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-right{background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-top{background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-container-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-container-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-container-horizontal.swiper-container-css-mode>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-container-vertical.swiper-container-css-mode>.swiper-wrapper{scroll-snap-type:y mandatory}:root{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{position:absolute;top:50%;width:calc(var(--swiper-navigation-size)/ 44 * 27);height:var(--swiper-navigation-size);margin-top:calc(-1 * var(--swiper-navigation-size)/ 2);z-index:10;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--swiper-navigation-color,var(--swiper-theme-color))}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-next:after,.swiper-button-prev:after{font-family:qy-swiper-icons;font-size:var(--swiper-navigation-size);text-transform:none!important;letter-spacing:0;text-transform:none;font-variant:initial;line-height:1}.swiper-button-prev,.swiper-container-rtl .swiper-button-next{left:10px;right:auto}.swiper-button-prev:after,.swiper-container-rtl .swiper-button-next:after{content:'prev'}.swiper-button-next,.swiper-container-rtl .swiper-button-prev{right:10px;left:auto}.swiper-button-next:after,.swiper-container-rtl .swiper-button-prev:after{content:'next'}.swiper-button-next.swiper-button-white,.swiper-button-prev.swiper-button-white{--swiper-navigation-color:#ffffff}.swiper-button-next.swiper-button-black,.swiper-button-prev.swiper-button-black{--swiper-navigation-color:#000000}.swiper-button-lock{display:none}.swiper-pagination{position:absolute;text-align:center;transition:.3s opacity;transform:translate3d(0,0,0);z-index:10;bottom:0;left:0;right:0;}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-container-horizontal>.swiper-pagination-bullets,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:10px;left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{width:8px;height:8px;margin:2px;display:inline-block;border-radius:100%;background:var(--swiper-navigation-color);opacity:.2}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet-active{opacity:1;background:var(--swiper-pagination-color),var(--swiper-theme-color))}.swiper-container-vertical>.swiper-pagination-bullets{right:10px;top:50%;transform:translate3d(0px,-50%,0)}.swiper-container-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:6px 0;display:block}.swiper-container-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-container-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:.2s transform,.2s top}.swiper-container-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 4px}.swiper-container-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-container-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s left}.swiper-container-horizontal.swiper-container-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s right}.swiper-pagination-progressbar{background:rgba(0,0,0,.25);position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}.swiper-container-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-container-horizontal>.swiper-pagination-progressbar,.swiper-container-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:4px;left:0;top:0}.swiper-container-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-container-vertical>.swiper-pagination-progressbar{width:4px;height:100%;left:0;top:0}.swiper-pagination-white{--swiper-pagination-color:#ffffff}.swiper-pagination-black{--swiper-pagination-color:#000000}.swiper-pagination-lock{display:none}.swiper-scrollbar{border-radius:10px;position:relative;-ms-touch-action:none;background:rgba(0,0,0,.1)}.swiper-container-horizontal>.swiper-scrollbar{position:absolute;left:1%;bottom:3px;z-index:50;height:5px;width:98%}.swiper-container-vertical>.swiper-scrollbar{position:absolute;right:3px;top:1%;z-index:50;width:5px;height:98%}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:rgba(0,0,0,.5);border-radius:10px;left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}.swiper-zoom-container{width:100%;height:100%;display:flex;justify-content:center;align-items:center;text-align:center}.swiper-zoom-container>canvas,.swiper-zoom-container>img,.swiper-zoom-container>svg{max-width:100%;max-height:100%;object-fit:contain}.swiper-slide-zoomed{cursor:move}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;transform-origin:50%;animation:swiper-preloader-spin 1s infinite linear;box-sizing:border-box;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}.swiper-lazy-preloader-white{--swiper-preloader-color:#fff}.swiper-lazy-preloader-black{--swiper-preloader-color:#000}@keyframes swiper-preloader-spin{100%{transform:rotate(360deg)}}.swiper-container .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}.swiper-container-fade.swiper-container-free-mode .swiper-slide{transition-timing-function:ease-out}.swiper-container-fade .swiper-slide{pointer-events:none;transition-property:opacity}.swiper-container-fade .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-fade .swiper-slide-active,.swiper-container-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-cube{overflow:visible}.swiper-container-cube .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;visibility:hidden;transform-origin:0 0;width:100%;height:100%}.swiper-container-cube .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-cube.swiper-container-rtl .swiper-slide{transform-origin:100% 0}.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-next,.swiper-container-cube .swiper-slide-next+.swiper-slide,.swiper-container-cube .swiper-slide-prev{pointer-events:auto;visibility:visible}.swiper-container-cube .swiper-slide-shadow-bottom,.swiper-container-cube .swiper-slide-shadow-left,.swiper-container-cube .swiper-slide-shadow-right,.swiper-container-cube .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-container-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0px;width:100%;height:100%;background:#000;opacity:.6;-webkit-filter:blur(50px);filter:blur(50px);z-index:0}.swiper-container-flip{overflow:visible}.swiper-container-flip .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1}.swiper-container-flip .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-flip .swiper-slide-active,.swiper-container-flip .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-flip .swiper-slide-shadow-bottom,.swiper-container-flip .swiper-slide-shadow-left,.swiper-container-flip .swiper-slide-shadow-right,.swiper-container-flip .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}`;
function isObject$2(obj) {
  return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
}
function extend$1(target = {}, src = {}) {
  Object.keys(src).forEach((key) => {
    if (typeof target[key] === "undefined")
      target[key] = src[key];
    else if (isObject$2(src[key]) && isObject$2(target[key]) && Object.keys(src[key]).length > 0) {
      extend$1(target[key], src[key]);
    }
  });
}
const ssrDocument = {
  body: {},
  addEventListener() {
  },
  removeEventListener() {
  },
  activeElement: {
    blur() {
    },
    nodeName: ""
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {
      }
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {
      },
      getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  }
};
function getDocument() {
  const doc = typeof document !== "undefined" ? document : {};
  extend$1(doc, ssrDocument);
  return doc;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ""
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  },
  history: {
    replaceState() {
    },
    pushState() {
    },
    go() {
    },
    back() {
    }
  },
  CustomEvent: function CustomEvent2() {
    return this;
  },
  addEventListener() {
  },
  removeEventListener() {
  },
  getComputedStyle() {
    return {
      getPropertyValue() {
        return "";
      }
    };
  },
  Image() {
  },
  Date() {
  },
  screen: {},
  setTimeout() {
  },
  clearTimeout() {
  },
  matchMedia() {
    return {};
  },
  requestAnimationFrame(callback) {
    if (typeof setTimeout === "undefined") {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame(id) {
    if (typeof setTimeout === "undefined") {
      return;
    }
    clearTimeout(id);
  }
};
function getWindow() {
  const win = typeof window !== "undefined" ? window : {};
  extend$1(win, ssrWindow);
  return win;
}
function makeReactive(obj) {
  const proto = obj.__proto__;
  Object.defineProperty(obj, "__proto__", {
    get() {
      return proto;
    },
    set(value) {
      proto.__proto__ = value;
    }
  });
}
class Dom7 extends Array {
  constructor(items) {
    if (typeof items === "number") {
      super(items);
    } else {
      super(...items || []);
      makeReactive(this);
    }
  }
}
function arrayFlat(arr = []) {
  const res = [];
  arr.forEach((el) => {
    if (Array.isArray(el)) {
      res.push(...arrayFlat(el));
    } else {
      res.push(el);
    }
  });
  return res;
}
function arrayFilter(arr, callback) {
  return Array.prototype.filter.call(arr, callback);
}
function arrayUnique(arr) {
  const uniqueArray = [];
  for (let i2 = 0; i2 < arr.length; i2 += 1) {
    if (uniqueArray.indexOf(arr[i2]) === -1)
      uniqueArray.push(arr[i2]);
  }
  return uniqueArray;
}
function qsa(selector, context2) {
  if (typeof selector !== "string") {
    return [selector];
  }
  const a2 = [];
  const res = context2.querySelectorAll(selector);
  for (let i2 = 0; i2 < res.length; i2 += 1) {
    a2.push(res[i2]);
  }
  return a2;
}
function $(selector, context2) {
  const window2 = getWindow();
  const document2 = getDocument();
  let arr = [];
  if (!context2 && selector instanceof Dom7) {
    return selector;
  }
  if (!selector) {
    return new Dom7(arr);
  }
  if (typeof selector === "string") {
    const html2 = selector.trim();
    if (html2.indexOf("<") >= 0 && html2.indexOf(">") >= 0) {
      let toCreate = "div";
      if (html2.indexOf("<li") === 0)
        toCreate = "ul";
      if (html2.indexOf("<tr") === 0)
        toCreate = "tbody";
      if (html2.indexOf("<td") === 0 || html2.indexOf("<th") === 0)
        toCreate = "tr";
      if (html2.indexOf("<tbody") === 0)
        toCreate = "table";
      if (html2.indexOf("<option") === 0)
        toCreate = "select";
      const tempParent = document2.createElement(toCreate);
      tempParent.innerHTML = html2;
      for (let i2 = 0; i2 < tempParent.childNodes.length; i2 += 1) {
        arr.push(tempParent.childNodes[i2]);
      }
    } else {
      arr = qsa(selector.trim(), context2 || document2);
    }
  } else if (selector.nodeType || selector === window2 || selector === document2) {
    arr.push(selector);
  } else if (Array.isArray(selector)) {
    if (selector instanceof Dom7)
      return selector;
    arr = selector;
  }
  return new Dom7(arrayUnique(arr));
}
$.fn = Dom7.prototype;
function addClass$1(...classes2) {
  const classNames = arrayFlat(classes2.map((c2) => c2.split(" ")));
  this.forEach((el) => {
    el.classList.add(...classNames);
  });
  return this;
}
function removeClass$1(...classes2) {
  const classNames = arrayFlat(classes2.map((c2) => c2.split(" ")));
  this.forEach((el) => {
    el.classList.remove(...classNames);
  });
  return this;
}
function toggleClass$1(...classes2) {
  const classNames = arrayFlat(classes2.map((c2) => c2.split(" ")));
  this.forEach((el) => {
    classNames.forEach((className) => {
      el.classList.toggle(className);
    });
  });
}
function hasClass$1(...classes2) {
  const classNames = arrayFlat(classes2.map((c2) => c2.split(" ")));
  return arrayFilter(this, (el) => {
    return classNames.filter((className) => el.classList.contains(className)).length > 0;
  }).length > 0;
}
function attr(attrs, value) {
  if (arguments.length === 1 && typeof attrs === "string") {
    if (this[0])
      return this[0].getAttribute(attrs);
    return void 0;
  }
  for (let i2 = 0; i2 < this.length; i2 += 1) {
    if (arguments.length === 2) {
      this[i2].setAttribute(attrs, value);
    } else {
      for (const attrName in attrs) {
        this[i2][attrName] = attrs[attrName];
        this[i2].setAttribute(attrName, attrs[attrName]);
      }
    }
  }
  return this;
}
function removeAttr(attr2) {
  for (let i2 = 0; i2 < this.length; i2 += 1) {
    this[i2].removeAttribute(attr2);
  }
  return this;
}
function transform(transform2) {
  for (let i2 = 0; i2 < this.length; i2 += 1) {
    this[i2].style.transform = transform2;
  }
  return this;
}
function transition$1(duration) {
  for (let i2 = 0; i2 < this.length; i2 += 1) {
    this[i2].style.transitionDuration = typeof duration !== "string" ? `${duration}ms` : duration;
  }
  return this;
}
function on(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === "function") {
    [eventType, listener, capture] = args;
    targetSelector = void 0;
  }
  if (!capture)
    capture = false;
  function handleLiveEvent(e2) {
    const target = e2.target;
    if (!target)
      return;
    const eventData = e2.target.dom7EventData || [];
    if (eventData.indexOf(e2) < 0) {
      eventData.unshift(e2);
    }
    if ($(target).is(targetSelector))
      listener.apply(target, eventData);
    else {
      const parents2 = $(target).parents();
      for (let k2 = 0; k2 < parents2.length; k2 += 1) {
        if ($(parents2[k2]).is(targetSelector))
          listener.apply(parents2[k2], eventData);
      }
    }
  }
  function handleEvent(e2) {
    const eventData = e2 && e2.target ? e2.target.dom7EventData || [] : [];
    if (eventData.indexOf(e2) < 0) {
      eventData.unshift(e2);
    }
    listener.apply(this, eventData);
  }
  const events2 = eventType.split(" ");
  let j;
  for (let i2 = 0; i2 < this.length; i2 += 1) {
    const el = this[i2];
    if (!targetSelector) {
      for (j = 0; j < events2.length; j += 1) {
        const event = events2[j];
        if (!el.dom7Listeners)
          el.dom7Listeners = {};
        if (!el.dom7Listeners[event])
          el.dom7Listeners[event] = [];
        el.dom7Listeners[event].push({
          listener,
          proxyListener: handleEvent
        });
        el.addEventListener(event, handleEvent, capture);
      }
    } else {
      for (j = 0; j < events2.length; j += 1) {
        const event = events2[j];
        if (!el.dom7LiveListeners)
          el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[event])
          el.dom7LiveListeners[event] = [];
        el.dom7LiveListeners[event].push({
          listener,
          proxyListener: handleLiveEvent
        });
        el.addEventListener(event, handleLiveEvent, capture);
      }
    }
  }
  return this;
}
function off(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === "function") {
    [eventType, listener, capture] = args;
    targetSelector = void 0;
  }
  if (!capture)
    capture = false;
  const events2 = eventType.split(" ");
  for (let i2 = 0; i2 < events2.length; i2 += 1) {
    const event = events2[i2];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let handlers2;
      if (!targetSelector && el.dom7Listeners) {
        handlers2 = el.dom7Listeners[event];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers2 = el.dom7LiveListeners[event];
      }
      if (handlers2 && handlers2.length) {
        for (let k2 = handlers2.length - 1; k2 >= 0; k2 -= 1) {
          const handler = handlers2[k2];
          if (listener && handler.listener === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers2.splice(k2, 1);
          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers2.splice(k2, 1);
          } else if (!listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers2.splice(k2, 1);
          }
        }
      }
    }
  }
  return this;
}
function trigger(...args) {
  const window2 = getWindow();
  const events2 = args[0].split(" ");
  const eventData = args[1];
  for (let i2 = 0; i2 < events2.length; i2 += 1) {
    const event = events2[i2];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      if (window2.CustomEvent) {
        const evt = new window2.CustomEvent(event, {
          detail: eventData,
          bubbles: true,
          cancelable: true
        });
        el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
        el.dispatchEvent(evt);
        el.dom7EventData = [];
        delete el.dom7EventData;
      }
    }
  }
  return this;
}
function transitionEnd$1(callback) {
  const dom = this;
  function fireCallBack(e2) {
    if (e2.target !== this)
      return;
    callback.call(this, e2);
    dom.off("transitionend", fireCallBack);
  }
  if (callback) {
    dom.on("transitionend", fireCallBack);
  }
  return this;
}
function outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      const styles2 = this.styles();
      return this[0].offsetWidth + parseFloat(styles2.getPropertyValue("margin-right")) + parseFloat(styles2.getPropertyValue("margin-left"));
    }
    return this[0].offsetWidth;
  }
  return null;
}
function outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      const styles2 = this.styles();
      return this[0].offsetHeight + parseFloat(styles2.getPropertyValue("margin-top")) + parseFloat(styles2.getPropertyValue("margin-bottom"));
    }
    return this[0].offsetHeight;
  }
  return null;
}
function offset() {
  if (this.length > 0) {
    const window2 = getWindow();
    const document2 = getDocument();
    const el = this[0];
    const box = el.getBoundingClientRect();
    const body = document2.body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop = el === window2 ? window2.scrollY : el.scrollTop;
    const scrollLeft = el === window2 ? window2.scrollX : el.scrollLeft;
    return {
      top: box.top + scrollTop - clientTop,
      left: box.left + scrollLeft - clientLeft
    };
  }
  return null;
}
function styles() {
  const window2 = getWindow();
  if (this[0])
    return window2.getComputedStyle(this[0], null);
  return {};
}
function css(props, value) {
  const window2 = getWindow();
  let i2;
  if (arguments.length === 1) {
    if (typeof props === "string") {
      if (this[0])
        return window2.getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      for (i2 = 0; i2 < this.length; i2 += 1) {
        for (const prop in props) {
          this[i2].style[prop] = props[prop];
        }
      }
      return this;
    }
  }
  if (arguments.length === 2 && typeof props === "string") {
    for (i2 = 0; i2 < this.length; i2 += 1) {
      this[i2].style[props] = value;
    }
    return this;
  }
  return this;
}
function each(callback) {
  if (!callback)
    return this;
  this.forEach((el, index2) => {
    callback.apply(el, [el, index2]);
  });
  return this;
}
function filter(callback) {
  const result = arrayFilter(this, callback);
  return $(result);
}
function html(html2) {
  if (typeof html2 === "undefined") {
    return this[0] ? this[0].innerHTML : null;
  }
  for (let i2 = 0; i2 < this.length; i2 += 1) {
    this[i2].innerHTML = html2;
  }
  return this;
}
function text(text2) {
  if (typeof text2 === "undefined") {
    return this[0] ? this[0].textContent.trim() : null;
  }
  for (let i2 = 0; i2 < this.length; i2 += 1) {
    this[i2].textContent = text2;
  }
  return this;
}
function is(selector) {
  const window2 = getWindow();
  const document2 = getDocument();
  const el = this[0];
  let compareWith;
  let i2;
  if (!el || typeof selector === "undefined")
    return false;
  if (typeof selector === "string") {
    if (el.matches)
      return el.matches(selector);
    if (el.webkitMatchesSelector)
      return el.webkitMatchesSelector(selector);
    if (el.msMatchesSelector)
      return el.msMatchesSelector(selector);
    compareWith = $(selector);
    for (i2 = 0; i2 < compareWith.length; i2 += 1) {
      if (compareWith[i2] === el)
        return true;
    }
    return false;
  }
  if (selector === document2) {
    return el === document2;
  }
  if (selector === window2) {
    return el === window2;
  }
  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;
    for (i2 = 0; i2 < compareWith.length; i2 += 1) {
      if (compareWith[i2] === el)
        return true;
    }
    return false;
  }
  return false;
}
function index() {
  let child = this[0];
  let i2;
  if (child) {
    i2 = 0;
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1)
        i2 += 1;
    }
    return i2;
  }
  return void 0;
}
function eq(index2) {
  if (typeof index2 === "undefined")
    return this;
  const length = this.length;
  if (index2 > length - 1) {
    return $([]);
  }
  if (index2 < 0) {
    const returnIndex = length + index2;
    if (returnIndex < 0)
      return $([]);
    return $([this[returnIndex]]);
  }
  return $([this[index2]]);
}
function append(...els) {
  let newChild;
  const document2 = getDocument();
  for (let k2 = 0; k2 < els.length; k2 += 1) {
    newChild = els[k2];
    for (let i2 = 0; i2 < this.length; i2 += 1) {
      if (typeof newChild === "string") {
        const tempDiv = document2.createElement("div");
        tempDiv.innerHTML = newChild;
        while (tempDiv.firstChild) {
          this[i2].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (let j = 0; j < newChild.length; j += 1) {
          this[i2].appendChild(newChild[j]);
        }
      } else {
        this[i2].appendChild(newChild);
      }
    }
  }
  return this;
}
function prepend(newChild) {
  const document2 = getDocument();
  let i2;
  let j;
  for (i2 = 0; i2 < this.length; i2 += 1) {
    if (typeof newChild === "string") {
      const tempDiv = document2.createElement("div");
      tempDiv.innerHTML = newChild;
      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i2].insertBefore(tempDiv.childNodes[j], this[i2].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i2].insertBefore(newChild[j], this[i2].childNodes[0]);
      }
    } else {
      this[i2].insertBefore(newChild, this[i2].childNodes[0]);
    }
  }
  return this;
}
function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
        return $([this[0].nextElementSibling]);
      }
      return $([]);
    }
    if (this[0].nextElementSibling)
      return $([this[0].nextElementSibling]);
    return $([]);
  }
  return $([]);
}
function nextAll(selector) {
  const nextEls = [];
  let el = this[0];
  if (!el)
    return $([]);
  while (el.nextElementSibling) {
    const next3 = el.nextElementSibling;
    if (selector) {
      if ($(next3).is(selector))
        nextEls.push(next3);
    } else
      nextEls.push(next3);
    el = next3;
  }
  return $(nextEls);
}
function prev(selector) {
  if (this.length > 0) {
    const el = this[0];
    if (selector) {
      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
        return $([el.previousElementSibling]);
      }
      return $([]);
    }
    if (el.previousElementSibling)
      return $([el.previousElementSibling]);
    return $([]);
  }
  return $([]);
}
function prevAll(selector) {
  const prevEls = [];
  let el = this[0];
  if (!el)
    return $([]);
  while (el.previousElementSibling) {
    const prev3 = el.previousElementSibling;
    if (selector) {
      if ($(prev3).is(selector))
        prevEls.push(prev3);
    } else
      prevEls.push(prev3);
    el = prev3;
  }
  return $(prevEls);
}
function parent(selector) {
  const parents2 = [];
  for (let i2 = 0; i2 < this.length; i2 += 1) {
    if (this[i2].parentNode !== null) {
      if (selector) {
        if ($(this[i2].parentNode).is(selector))
          parents2.push(this[i2].parentNode);
      } else {
        parents2.push(this[i2].parentNode);
      }
    }
  }
  return $(parents2);
}
function parents(selector) {
  const parents2 = [];
  for (let i2 = 0; i2 < this.length; i2 += 1) {
    let parent2 = this[i2].parentNode;
    while (parent2) {
      if (selector) {
        if ($(parent2).is(selector))
          parents2.push(parent2);
      } else {
        parents2.push(parent2);
      }
      parent2 = parent2.parentNode;
    }
  }
  return $(parents2);
}
function closest(selector) {
  let closest2 = this;
  if (typeof selector === "undefined") {
    return $([]);
  }
  if (!closest2.is(selector)) {
    closest2 = closest2.parents(selector).eq(0);
  }
  return closest2;
}
function find(selector) {
  const foundElements = [];
  for (let i2 = 0; i2 < this.length; i2 += 1) {
    const found = this[i2].querySelectorAll(selector);
    for (let j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }
  return $(foundElements);
}
function children(selector) {
  const children2 = [];
  for (let i2 = 0; i2 < this.length; i2 += 1) {
    const childNodes = this[i2].children;
    for (let j = 0; j < childNodes.length; j += 1) {
      if (!selector || $(childNodes[j]).is(selector)) {
        children2.push(childNodes[j]);
      }
    }
  }
  return $(children2);
}
function remove() {
  for (let i2 = 0; i2 < this.length; i2 += 1) {
    if (this[i2].parentNode)
      this[i2].parentNode.removeChild(this[i2]);
  }
  return this;
}
const Methods = {
  addClass: addClass$1,
  removeClass: removeClass$1,
  hasClass: hasClass$1,
  toggleClass: toggleClass$1,
  attr,
  removeAttr,
  transform,
  transition: transition$1,
  on,
  off,
  trigger,
  transitionEnd: transitionEnd$1,
  outerWidth,
  outerHeight,
  styles,
  offset,
  css,
  each,
  html,
  text,
  is,
  index,
  eq,
  append,
  prepend,
  next,
  nextAll,
  prev,
  prevAll,
  parent,
  parents,
  closest,
  find,
  children,
  filter,
  remove
};
Object.keys(Methods).forEach((methodName) => {
  Object.defineProperty($.fn, methodName, {
    value: Methods[methodName],
    writable: true
  });
});
function deleteProps(obj) {
  const object = obj;
  Object.keys(object).forEach((key) => {
    try {
      object[key] = null;
    } catch (e2) {
    }
    try {
      delete object[key];
    } catch (e2) {
    }
  });
}
function nextTick(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return setTimeout(callback, delay);
}
function now() {
  return Date.now();
}
function getComputedStyle$1(el) {
  const window2 = getWindow();
  let style;
  if (window2.getComputedStyle) {
    style = window2.getComputedStyle(el, null);
  }
  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }
  if (!style) {
    style = el.style;
  }
  return style;
}
function getTranslate(el, axis) {
  if (axis === void 0) {
    axis = "x";
  }
  const window2 = getWindow();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = getComputedStyle$1(el);
  if (window2.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(",").length > 6) {
      curTransform = curTransform.split(", ").map((a2) => a2.replace(",", ".")).join(", ");
    }
    transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
    matrix = transformMatrix.toString().split(",");
  }
  if (axis === "x") {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m41;
    else if (matrix.length === 16)
      curTransform = parseFloat(matrix[12]);
    else
      curTransform = parseFloat(matrix[4]);
  }
  if (axis === "y") {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m42;
    else if (matrix.length === 16)
      curTransform = parseFloat(matrix[13]);
    else
      curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function isObject$1(o2) {
  return typeof o2 === "object" && o2 !== null && o2.constructor && Object.prototype.toString.call(o2).slice(8, -1) === "Object";
}
function isNode(node) {
  if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
    return node instanceof HTMLElement;
  }
  return node && (node.nodeType === 1 || node.nodeType === 11);
}
function extend() {
  const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
  const noExtend = ["__proto__", "constructor", "prototype"];
  for (let i2 = 1; i2 < arguments.length; i2 += 1) {
    const nextSource = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
    if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          if (isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
            to[nextKey] = {};
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function setCSSProperty(el, varName, varValue) {
  el.style.setProperty(varName, varValue);
}
function animateCSSModeScroll(_ref) {
  let {
    swiper,
    targetPosition,
    side
  } = _ref;
  const window2 = getWindow();
  const startPosition = -swiper.translate;
  let startTime = null;
  let time;
  const duration = swiper.params.speed;
  swiper.wrapperEl.style.scrollSnapType = "none";
  window2.cancelAnimationFrame(swiper.cssModeFrameID);
  const dir = targetPosition > startPosition ? "next" : "prev";
  const isOutOfBound = (current, target) => {
    return dir === "next" && current >= target || dir === "prev" && current <= target;
  };
  const animate = () => {
    time = new Date().getTime();
    if (startTime === null) {
      startTime = time;
    }
    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }
    swiper.wrapperEl.scrollTo({
      [side]: currentPosition
    });
    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper.wrapperEl.style.overflow = "hidden";
      swiper.wrapperEl.style.scrollSnapType = "";
      setTimeout(() => {
        swiper.wrapperEl.style.overflow = "";
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      });
      window2.cancelAnimationFrame(swiper.cssModeFrameID);
      return;
    }
    swiper.cssModeFrameID = window2.requestAnimationFrame(animate);
  };
  animate();
}
let support;
function calcSupport() {
  const window2 = getWindow();
  const document2 = getDocument();
  return {
    smoothScroll: document2.documentElement && "scrollBehavior" in document2.documentElement.style,
    touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch),
    passiveListener: function checkPassiveListener() {
      let supportsPassive = false;
      try {
        const opts = Object.defineProperty({}, "passive", {
          get() {
            supportsPassive = true;
          }
        });
        window2.addEventListener("testPassiveListener", null, opts);
      } catch (e2) {
      }
      return supportsPassive;
    }(),
    gestures: function checkGestures() {
      return "ongesturestart" in window2;
    }()
  };
}
function getSupport() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}
let deviceCached;
function calcDevice(_temp) {
  let {
    userAgent
  } = _temp === void 0 ? {} : _temp;
  const support2 = getSupport();
  const window2 = getWindow();
  const platform = window2.navigator.platform;
  const ua = userAgent || window2.navigator.userAgent;
  const device = {
    ios: false,
    android: false
  };
  const screenWidth = window2.screen.width;
  const screenHeight = window2.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform === "Win32";
  let macos = platform === "MacIntel";
  const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
  if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad)
      ipad = [0, 1, "13_0_0"];
    macos = false;
  }
  if (android && !windows) {
    device.os = "android";
    device.android = true;
  }
  if (ipad || iphone || ipod) {
    device.os = "ios";
    device.ios = true;
  }
  return device;
}
function getDevice(overrides) {
  if (overrides === void 0) {
    overrides = {};
  }
  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }
  return deviceCached;
}
let browser;
function calcBrowser() {
  const window2 = getWindow();
  function isSafari() {
    const ua = window2.navigator.userAgent.toLowerCase();
    return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
  }
  return {
    isSafari: isSafari(),
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)
  };
}
function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }
  return browser;
}
function Resize(_ref) {
  let {
    swiper,
    on: on2,
    emit
  } = _ref;
  const window2 = getWindow();
  let observer = null;
  const resizeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized)
      return;
    emit("beforeResize");
    emit("resize");
  };
  const createObserver = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized)
      return;
    observer = new ResizeObserver((entries) => {
      const {
        width,
        height
      } = swiper;
      let newWidth = width;
      let newHeight = height;
      entries.forEach((_ref2) => {
        let {
          contentBoxSize,
          contentRect,
          target
        } = _ref2;
        if (target && target !== swiper.el)
          return;
        newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
        newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
      });
      if (newWidth !== width || newHeight !== height) {
        resizeHandler();
      }
    });
    observer.observe(swiper.el);
  };
  const removeObserver = () => {
    if (observer && observer.unobserve && swiper.el) {
      observer.unobserve(swiper.el);
      observer = null;
    }
  };
  const orientationChangeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized)
      return;
    emit("orientationchange");
  };
  on2("init", () => {
    if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
      createObserver();
      return;
    }
    window2.addEventListener("resize", resizeHandler);
    window2.addEventListener("orientationchange", orientationChangeHandler);
  });
  on2("destroy", () => {
    removeObserver();
    window2.removeEventListener("resize", resizeHandler);
    window2.removeEventListener("orientationchange", orientationChangeHandler);
  });
}
function Observer(_ref) {
  let {
    swiper,
    extendParams,
    on: on2,
    emit
  } = _ref;
  const observers = [];
  const window2 = getWindow();
  const attach = function(target, options) {
    if (options === void 0) {
      options = {};
    }
    const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
    const observer = new ObserverFunc((mutations) => {
      if (mutations.length === 1) {
        emit("observerUpdate", mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate2() {
        emit("observerUpdate", mutations[0]);
      };
      if (window2.requestAnimationFrame) {
        window2.requestAnimationFrame(observerUpdate);
      } else {
        window2.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === "undefined" ? true : options.attributes,
      childList: typeof options.childList === "undefined" ? true : options.childList,
      characterData: typeof options.characterData === "undefined" ? true : options.characterData
    });
    observers.push(observer);
  };
  const init = () => {
    if (!swiper.params.observer)
      return;
    if (swiper.params.observeParents) {
      const containerParents = swiper.$el.parents();
      for (let i2 = 0; i2 < containerParents.length; i2 += 1) {
        attach(containerParents[i2]);
      }
    }
    attach(swiper.$el[0], {
      childList: swiper.params.observeSlideChildren
    });
    attach(swiper.$wrapperEl[0], {
      attributes: false
    });
  };
  const destroy2 = () => {
    observers.forEach((observer) => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };
  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  });
  on2("init", init);
  on2("destroy", destroy2);
}
var eventsEmitter = {
  on(events2, handler, priority) {
    const self2 = this;
    if (typeof handler !== "function")
      return self2;
    const method = priority ? "unshift" : "push";
    events2.split(" ").forEach((event) => {
      if (!self2.eventsListeners[event])
        self2.eventsListeners[event] = [];
      self2.eventsListeners[event][method](handler);
    });
    return self2;
  },
  once(events2, handler, priority) {
    const self2 = this;
    if (typeof handler !== "function")
      return self2;
    function onceHandler() {
      self2.off(events2, onceHandler);
      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      handler.apply(self2, args);
    }
    onceHandler.__emitterProxy = handler;
    return self2.on(events2, onceHandler, priority);
  },
  onAny(handler, priority) {
    const self2 = this;
    if (typeof handler !== "function")
      return self2;
    const method = priority ? "unshift" : "push";
    if (self2.eventsAnyListeners.indexOf(handler) < 0) {
      self2.eventsAnyListeners[method](handler);
    }
    return self2;
  },
  offAny(handler) {
    const self2 = this;
    if (!self2.eventsAnyListeners)
      return self2;
    const index2 = self2.eventsAnyListeners.indexOf(handler);
    if (index2 >= 0) {
      self2.eventsAnyListeners.splice(index2, 1);
    }
    return self2;
  },
  off(events2, handler) {
    const self2 = this;
    if (!self2.eventsListeners)
      return self2;
    events2.split(" ").forEach((event) => {
      if (typeof handler === "undefined") {
        self2.eventsListeners[event] = [];
      } else if (self2.eventsListeners[event]) {
        self2.eventsListeners[event].forEach((eventHandler, index2) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self2.eventsListeners[event].splice(index2, 1);
          }
        });
      }
    });
    return self2;
  },
  emit() {
    const self2 = this;
    if (!self2.eventsListeners)
      return self2;
    let events2;
    let data;
    let context2;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (typeof args[0] === "string" || Array.isArray(args[0])) {
      events2 = args[0];
      data = args.slice(1, args.length);
      context2 = self2;
    } else {
      events2 = args[0].events;
      data = args[0].data;
      context2 = args[0].context || self2;
    }
    data.unshift(context2);
    const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
    eventsArray.forEach((event) => {
      if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) {
        self2.eventsAnyListeners.forEach((eventHandler) => {
          eventHandler.apply(context2, [event, ...data]);
        });
      }
      if (self2.eventsListeners && self2.eventsListeners[event]) {
        self2.eventsListeners[event].forEach((eventHandler) => {
          eventHandler.apply(context2, data);
        });
      }
    });
    return self2;
  }
};
function updateSize() {
  const swiper = this;
  let width;
  let height;
  const $el = swiper.$el;
  if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }
  if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }
  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  }
  width = width - parseInt($el.css("padding-left") || 0, 10) - parseInt($el.css("padding-right") || 0, 10);
  height = height - parseInt($el.css("padding-top") || 0, 10) - parseInt($el.css("padding-bottom") || 0, 10);
  if (Number.isNaN(width))
    width = 0;
  if (Number.isNaN(height))
    height = 0;
  Object.assign(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height
  });
}
function updateSlides() {
  const swiper = this;
  function getDirectionLabel(property) {
    if (swiper.isHorizontal()) {
      return property;
    }
    return {
      "width": "height",
      "margin-top": "margin-left",
      "margin-bottom ": "margin-right",
      "margin-left": "margin-top",
      "margin-right": "margin-bottom",
      "padding-left": "padding-top",
      "padding-right": "padding-bottom",
      "marginRight": "marginBottom"
    }[property];
  }
  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
  }
  const params = swiper.params;
  const {
    $wrapperEl,
    size: swiperSize,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === "function") {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }
  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === "function") {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }
  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.slidesGrid.length;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index2 = 0;
  if (typeof swiperSize === "undefined") {
    return;
  }
  if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
  }
  swiper.virtualSize = -spaceBetween;
  if (rtl)
    slides.css({
      marginLeft: "",
      marginBottom: "",
      marginTop: ""
    });
  else
    slides.css({
      marginRight: "",
      marginBottom: "",
      marginTop: ""
    });
  if (params.centeredSlides && params.cssMode) {
    setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", "");
    setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", "");
  }
  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
  if (gridEnabled) {
    swiper.grid.initSlides(slidesLength);
  }
  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {
    return typeof params.breakpoints[key].slidesPerView !== "undefined";
  }).length > 0;
  for (let i2 = 0; i2 < slidesLength; i2 += 1) {
    slideSize = 0;
    const slide2 = slides.eq(i2);
    if (gridEnabled) {
      swiper.grid.updateSlide(i2, slide2, slidesLength, getDirectionLabel);
    }
    if (slide2.css("display") === "none")
      continue;
    if (params.slidesPerView === "auto") {
      if (shouldResetSlideSize) {
        slides[i2].style[getDirectionLabel("width")] = ``;
      }
      const slideStyles = getComputedStyle(slide2[0]);
      const currentTransform = slide2[0].style.transform;
      const currentWebKitTransform = slide2[0].style.webkitTransform;
      if (currentTransform) {
        slide2[0].style.transform = "none";
      }
      if (currentWebKitTransform) {
        slide2[0].style.webkitTransform = "none";
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? slide2.outerWidth(true) : slide2.outerHeight(true);
      } else {
        const width = getDirectionPropertyValue(slideStyles, "width");
        const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
        const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
        const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
        const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
        const boxSizing = slideStyles.getPropertyValue("box-sizing");
        if (boxSizing && boxSizing === "border-box") {
          slideSize = width + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth
          } = slide2[0];
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }
      if (currentTransform) {
        slide2[0].style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide2[0].style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths)
        slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths)
        slideSize = Math.floor(slideSize);
      if (slides[i2]) {
        slides[i2].style[getDirectionLabel("width")] = `${slideSize}px`;
      }
    }
    if (slides[i2]) {
      slides[i2].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);
    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i2 !== 0)
        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i2 === 0)
        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1e3)
        slidePosition = 0;
      if (params.roundLengths)
        slidePosition = Math.floor(slidePosition);
      if (index2 % params.slidesPerGroup === 0)
        snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths)
        slidePosition = Math.floor(slidePosition);
      if ((index2 - Math.min(swiper.params.slidesPerGroupSkip, index2)) % swiper.params.slidesPerGroup === 0)
        snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }
    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index2 += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
    $wrapperEl.css({
      width: `${swiper.virtualSize + params.spaceBetween}px`
    });
  }
  if (params.setWrapperSize) {
    $wrapperEl.css({
      [getDirectionLabel("width")]: `${swiper.virtualSize + params.spaceBetween}px`
    });
  }
  if (gridEnabled) {
    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
  }
  if (!params.centeredSlides) {
    const newSlidesGrid = [];
    for (let i2 = 0; i2 < snapGrid.length; i2 += 1) {
      let slidesGridItem = snapGrid[i2];
      if (params.roundLengths)
        slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i2] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (snapGrid.length === 0)
    snapGrid = [0];
  if (params.spaceBetween !== 0) {
    const key = swiper.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
    slides.filter((_2, slideIndex) => {
      if (!params.cssMode)
        return true;
      if (slideIndex === slides.length - 1) {
        return false;
      }
      return true;
    }).css({
      [key]: `${spaceBetween}px`
    });
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    const maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map((snap) => {
      if (snap < 0)
        return -offsetBefore;
      if (snap > maxSnap)
        return maxSnap + offsetAfter;
      return snap;
    });
  }
  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    if (allSlidesSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  Object.assign(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });
  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
    setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    const addToSnapGrid = -swiper.snapGrid[0];
    const addToSlidesGrid = -swiper.slidesGrid[0];
    swiper.snapGrid = swiper.snapGrid.map((v2) => v2 + addToSnapGrid);
    swiper.slidesGrid = swiper.slidesGrid.map((v2) => v2 + addToSlidesGrid);
  }
  if (slidesLength !== previousSlidesLength) {
    swiper.emit("slidesLengthChange");
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow)
      swiper.checkOverflow();
    swiper.emit("snapGridLengthChange");
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit("slidesGridLengthChange");
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
    if (slidesLength <= params.maxBackfaceHiddenSlides) {
      swiper.$el.addClass(`${params.containerModifierClass}backface-hidden`);
    } else {
      swiper.$el.removeClass(`${params.containerModifierClass}backface-hidden`);
    }
  }
}
function updateAutoHeight(speed) {
  const swiper = this;
  const activeSlides = [];
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  let newHeight = 0;
  let i2;
  if (typeof speed === "number") {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  const getSlideByIndex = (index2) => {
    if (isVirtual) {
      return swiper.slides.filter((el) => parseInt(el.getAttribute("data-swiper-slide-index"), 10) === index2)[0];
    }
    return swiper.slides.eq(index2)[0];
  };
  if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      swiper.visibleSlides.each((slide2) => {
        activeSlides.push(slide2);
      });
    } else {
      for (i2 = 0; i2 < Math.ceil(swiper.params.slidesPerView); i2 += 1) {
        const index2 = swiper.activeIndex + i2;
        if (index2 > swiper.slides.length && !isVirtual)
          break;
        activeSlides.push(getSlideByIndex(index2));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  }
  for (i2 = 0; i2 < activeSlides.length; i2 += 1) {
    if (typeof activeSlides[i2] !== "undefined") {
      const height = activeSlides[i2].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }
  if (newHeight || newHeight === 0)
    swiper.$wrapperEl.css("height", `${newHeight}px`);
}
function updateSlidesOffset() {
  const swiper = this;
  const slides = swiper.slides;
  for (let i2 = 0; i2 < slides.length; i2 += 1) {
    slides[i2].swiperSlideOffset = swiper.isHorizontal() ? slides[i2].offsetLeft : slides[i2].offsetTop;
  }
}
function updateSlidesProgress(translate2) {
  if (translate2 === void 0) {
    translate2 = this && this.translate || 0;
  }
  const swiper = this;
  const params = swiper.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper;
  if (slides.length === 0)
    return;
  if (typeof slides[0].swiperSlideOffset === "undefined")
    swiper.updateSlidesOffset();
  let offsetCenter = -translate2;
  if (rtl)
    offsetCenter = translate2;
  slides.removeClass(params.slideVisibleClass);
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];
  for (let i2 = 0; i2 < slides.length; i2 += 1) {
    const slide2 = slides[i2];
    let slideOffset = slide2.swiperSlideOffset;
    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }
    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + params.spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + params.spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper.slidesSizesGrid[i2];
    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
    if (isVisible) {
      swiper.visibleSlides.push(slide2);
      swiper.visibleSlidesIndexes.push(i2);
      slides.eq(i2).addClass(params.slideVisibleClass);
    }
    slide2.progress = rtl ? -slideProgress : slideProgress;
    slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }
  swiper.visibleSlides = $(swiper.visibleSlides);
}
function updateProgress(translate2) {
  const swiper = this;
  if (typeof translate2 === "undefined") {
    const multiplier = swiper.rtlTranslate ? -1 : 1;
    translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }
  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd
  } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate2 - swiper.minTranslate()) / translatesDiff;
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }
  Object.assign(swiper, {
    progress,
    isBeginning,
    isEnd
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight)
    swiper.updateSlidesProgress(translate2);
  if (isBeginning && !wasBeginning) {
    swiper.emit("reachBeginning toEdge");
  }
  if (isEnd && !wasEnd) {
    swiper.emit("reachEnd toEdge");
  }
  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit("fromEdge");
  }
  swiper.emit("progress", progress);
}
function updateSlidesClasses() {
  const swiper = this;
  const {
    slides,
    params,
    $wrapperEl,
    activeIndex,
    realIndex
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
  let activeSlide;
  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
  } else {
    activeSlide = slides.eq(activeIndex);
  }
  activeSlide.addClass(params.slideActiveClass);
  if (params.loop) {
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
    }
  }
  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  }
  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }
  if (params.loop) {
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass);
    }
    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass);
    }
  }
  swiper.emitSlidesClasses();
}
function updateActiveIndex(newActiveIndex) {
  const swiper = this;
  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    slidesGrid,
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  if (typeof activeIndex === "undefined") {
    for (let i2 = 0; i2 < slidesGrid.length; i2 += 1) {
      if (typeof slidesGrid[i2 + 1] !== "undefined") {
        if (translate2 >= slidesGrid[i2] && translate2 < slidesGrid[i2 + 1] - (slidesGrid[i2 + 1] - slidesGrid[i2]) / 2) {
          activeIndex = i2;
        } else if (translate2 >= slidesGrid[i2] && translate2 < slidesGrid[i2 + 1]) {
          activeIndex = i2 + 1;
        }
      } else if (translate2 >= slidesGrid[i2]) {
        activeIndex = i2;
      }
    }
    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === "undefined")
        activeIndex = 0;
    }
  }
  if (snapGrid.indexOf(translate2) >= 0) {
    snapIndex = snapGrid.indexOf(translate2);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length)
    snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit("snapIndexChange");
    }
    return;
  }
  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr("data-swiper-slide-index") || activeIndex, 10);
  Object.assign(swiper, {
    snapIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  swiper.emit("activeIndexChange");
  swiper.emit("snapIndexChange");
  if (previousRealIndex !== realIndex) {
    swiper.emit("realIndexChange");
  }
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    swiper.emit("slideChange");
  }
}
function updateClickedSlide(e2) {
  const swiper = this;
  const params = swiper.params;
  const slide2 = $(e2).closest(`.${params.slideClass}`)[0];
  let slideFound = false;
  let slideIndex;
  if (slide2) {
    for (let i2 = 0; i2 < swiper.slides.length; i2 += 1) {
      if (swiper.slides[i2] === slide2) {
        slideFound = true;
        slideIndex = i2;
        break;
      }
    }
  }
  if (slide2 && slideFound) {
    swiper.clickedSlide = slide2;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt($(slide2).attr("data-swiper-slide-index"), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = void 0;
    swiper.clickedIndex = void 0;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}
var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};
function getSwiperTranslate(axis) {
  if (axis === void 0) {
    axis = this.isHorizontal() ? "x" : "y";
  }
  const swiper = this;
  const {
    params,
    rtlTranslate: rtl,
    translate: translate2,
    $wrapperEl
  } = swiper;
  if (params.virtualTranslate) {
    return rtl ? -translate2 : translate2;
  }
  if (params.cssMode) {
    return translate2;
  }
  let currentTranslate = getTranslate($wrapperEl[0], axis);
  if (rtl)
    currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}
function setTranslate(translate2, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl,
    params,
    $wrapperEl,
    wrapperEl,
    progress
  } = swiper;
  let x2 = 0;
  let y = 0;
  const z2 = 0;
  if (swiper.isHorizontal()) {
    x2 = rtl ? -translate2 : translate2;
  } else {
    y = translate2;
  }
  if (params.roundLengths) {
    x2 = Math.floor(x2);
    y = Math.floor(y);
  }
  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x2 : -y;
  } else if (!params.virtualTranslate) {
    $wrapperEl.transform(`translate3d(${x2}px, ${y}px, ${z2}px)`);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x2 : y;
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate2);
  }
  swiper.emit("setTranslate", swiper.translate, byController);
}
function minTranslate() {
  return -this.snapGrid[0];
}
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
function translateTo(translate2, speed, runCallbacks, translateBounds, internal) {
  if (translate2 === void 0) {
    translate2 = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (translateBounds === void 0) {
    translateBounds = true;
  }
  const swiper = this;
  const {
    params,
    wrapperEl
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  const minTranslate2 = swiper.minTranslate();
  const maxTranslate2 = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate2 > minTranslate2)
    newTranslate = minTranslate2;
  else if (translateBounds && translate2 < maxTranslate2)
    newTranslate = maxTranslate2;
  else
    newTranslate = translate2;
  swiper.updateProgress(newTranslate);
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: -newTranslate,
          side: isH ? "left" : "top"
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: -newTranslate,
        behavior: "smooth"
      });
    }
    return true;
  }
  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit("beforeTransitionStart", speed, internal);
      swiper.emit("transitionEnd");
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit("beforeTransitionStart", speed, internal);
      swiper.emit("transitionStart");
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd2(e2) {
          if (!swiper || swiper.destroyed)
            return;
          if (e2.target !== this)
            return;
          swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          if (runCallbacks) {
            swiper.emit("transitionEnd");
          }
        };
      }
      swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
    }
  }
  return true;
}
var translate = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};
function setTransition(duration, byController) {
  const swiper = this;
  if (!swiper.params.cssMode) {
    swiper.$wrapperEl.transition(duration);
  }
  swiper.emit("setTransition", duration, byController);
}
function transitionEmit(_ref) {
  let {
    swiper,
    runCallbacks,
    direction,
    step
  } = _ref;
  const {
    activeIndex,
    previousIndex
  } = swiper;
  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex)
      dir = "next";
    else if (activeIndex < previousIndex)
      dir = "prev";
    else
      dir = "reset";
  }
  swiper.emit(`transition${step}`);
  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === "reset") {
      swiper.emit(`slideResetTransition${step}`);
      return;
    }
    swiper.emit(`slideChangeTransition${step}`);
    if (dir === "next") {
      swiper.emit(`slideNextTransition${step}`);
    } else {
      swiper.emit(`slidePrevTransition${step}`);
    }
  }
}
function transitionStart(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params
  } = swiper;
  if (params.cssMode)
    return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: "Start"
  });
}
function transitionEnd(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.animating = false;
  if (params.cssMode)
    return;
  swiper.setTransition(0);
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: "End"
  });
}
var transition = {
  setTransition,
  transitionStart,
  transitionEnd
};
function slideTo(index2, speed, runCallbacks, internal, initial) {
  if (index2 === void 0) {
    index2 = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index2 !== "number" && typeof index2 !== "string") {
    throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index2}] given.`);
  }
  if (typeof index2 === "string") {
    const indexAsNumber = parseInt(index2, 10);
    const isValidNumber = isFinite(indexAsNumber);
    if (!isValidNumber) {
      throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index2}] given.`);
    }
    index2 = indexAsNumber;
  }
  const swiper = this;
  let slideIndex = index2;
  if (slideIndex < 0)
    slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
    return false;
  }
  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length)
    snapIndex = snapGrid.length - 1;
  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit("beforeSlideChangeStart");
  }
  const translate2 = -snapGrid[snapIndex];
  swiper.updateProgress(translate2);
  if (params.normalizeSlideIndex) {
    for (let i2 = 0; i2 < slidesGrid.length; i2 += 1) {
      const normalizedTranslate = -Math.floor(translate2 * 100);
      const normalizedGrid = Math.floor(slidesGrid[i2] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i2 + 1] * 100);
      if (typeof slidesGrid[i2 + 1] !== "undefined") {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i2;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i2 + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i2;
      }
    }
  }
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate2 < swiper.translate && translate2 < swiper.minTranslate()) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex)
        return false;
    }
  }
  let direction;
  if (slideIndex > activeIndex)
    direction = "next";
  else if (slideIndex < activeIndex)
    direction = "prev";
  else
    direction = "reset";
  if (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate) {
    swiper.updateActiveIndex(slideIndex);
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== "slide") {
      swiper.setTranslate(translate2);
    }
    if (direction !== "reset") {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    const t2 = rtl ? translate2 : -translate2;
    if (speed === 0) {
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      if (isVirtual) {
        swiper.wrapperEl.style.scrollSnapType = "none";
        swiper._immediateVirtual = true;
      }
      wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t2;
      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper.wrapperEl.style.scrollSnapType = "";
          swiper._swiperImmediateVirtual = false;
        });
      }
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: t2,
          side: isH ? "left" : "top"
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: t2,
        behavior: "smooth"
      });
    }
    return true;
  }
  swiper.setTransition(speed);
  swiper.setTranslate(translate2);
  swiper.updateActiveIndex(slideIndex);
  swiper.updateSlidesClasses();
  swiper.emit("beforeTransitionStart", speed, internal);
  swiper.transitionStart(runCallbacks, direction);
  if (speed === 0) {
    swiper.transitionEnd(runCallbacks, direction);
  } else if (!swiper.animating) {
    swiper.animating = true;
    if (!swiper.onSlideToWrapperTransitionEnd) {
      swiper.onSlideToWrapperTransitionEnd = function transitionEnd2(e2) {
        if (!swiper || swiper.destroyed)
          return;
        if (e2.target !== this)
          return;
        swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
        swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
        swiper.onSlideToWrapperTransitionEnd = null;
        delete swiper.onSlideToWrapperTransitionEnd;
        swiper.transitionEnd(runCallbacks, direction);
      };
    }
    swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
    swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
  }
  return true;
}
function slideToLoop(index2, speed, runCallbacks, internal) {
  if (index2 === void 0) {
    index2 = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  let newIndex = index2;
  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }
  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}
function slideNext(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    animating,
    enabled,
    params
  } = swiper;
  if (!enabled)
    return swiper;
  let perGroup = params.slidesPerGroup;
  if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
  }
  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
  if (params.loop) {
    if (animating && params.loopPreventsSlide)
      return false;
    swiper.loopFix();
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  if (params.rewind && swiper.isEnd) {
    return swiper.slideTo(0, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}
function slidePrev(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params,
    animating,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled)
    return swiper;
  if (params.loop) {
    if (animating && params.loopPreventsSlide)
      return false;
    swiper.loopFix();
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize(val) {
    if (val < 0)
      return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize(translate2);
  const normalizedSnapGrid = snapGrid.map((val) => normalize(val));
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === "undefined" && params.cssMode) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        prevSnapIndex = snapIndex;
      }
    });
    if (typeof prevSnapIndex !== "undefined") {
      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }
  let prevIndex = 0;
  if (typeof prevSnap !== "undefined") {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0)
      prevIndex = swiper.activeIndex - 1;
    if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }
  if (params.rewind && swiper.isBeginning) {
    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}
function slideReset(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}
function slideToClosest(speed, runCallbacks, internal, threshold) {
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (threshold === void 0) {
    threshold = 0.5;
  }
  const swiper = this;
  let index2 = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index2);
  const snapIndex = skip + Math.floor((index2 - skip) / swiper.params.slidesPerGroup);
  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  if (translate2 >= swiper.snapGrid[snapIndex]) {
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];
    if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {
      index2 += swiper.params.slidesPerGroup;
    }
  } else {
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];
    if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {
      index2 -= swiper.params.slidesPerGroup;
    }
  }
  index2 = Math.max(index2, 0);
  index2 = Math.min(index2, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index2, speed, runCallbacks, internal);
}
function slideToClickedSlide() {
  const swiper = this;
  const {
    params,
    $wrapperEl
  } = swiper;
  const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  if (params.loop) {
    if (swiper.animating)
      return;
    realIndex = parseInt($(swiper.clickedSlide).attr("data-swiper-slide-index"), 10);
    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
        nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
      nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}
var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};
function loopCreate() {
  const swiper = this;
  const document2 = getDocument();
  const {
    params,
    $wrapperEl
  } = swiper;
  const $selector = $wrapperEl.children().length > 0 ? $($wrapperEl.children()[0].parentNode) : $wrapperEl;
  $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
  let slides = $selector.children(`.${params.slideClass}`);
  if (params.loopFillGroupWithBlank) {
    const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
    if (blankSlidesNum !== params.slidesPerGroup) {
      for (let i2 = 0; i2 < blankSlidesNum; i2 += 1) {
        const blankNode = $(document2.createElement("div")).addClass(`${params.slideClass} ${params.slideBlankClass}`);
        $selector.append(blankNode);
      }
      slides = $selector.children(`.${params.slideClass}`);
    }
  }
  if (params.slidesPerView === "auto" && !params.loopedSlides)
    params.loopedSlides = slides.length;
  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
  swiper.loopedSlides += params.loopAdditionalSlides;
  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }
  const prependSlides = [];
  const appendSlides = [];
  slides.each((el, index2) => {
    const slide2 = $(el);
    if (index2 < swiper.loopedSlides) {
      appendSlides.push(el);
    }
    if (index2 < slides.length && index2 >= slides.length - swiper.loopedSlides) {
      prependSlides.push(el);
    }
    slide2.attr("data-swiper-slide-index", index2);
  });
  for (let i2 = 0; i2 < appendSlides.length; i2 += 1) {
    $selector.append($(appendSlides[i2].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
  for (let i2 = prependSlides.length - 1; i2 >= 0; i2 -= 1) {
    $selector.prepend($(prependSlides[i2].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}
function loopFix() {
  const swiper = this;
  swiper.emit("beforeLoopFix");
  const {
    activeIndex,
    slides,
    loopedSlides,
    allowSlidePrev,
    allowSlideNext,
    snapGrid,
    rtlTranslate: rtl
  } = swiper;
  let newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  const snapTranslate = -snapGrid[activeIndex];
  const diff = snapTranslate - swiper.getTranslate();
  if (activeIndex < loopedSlides) {
    newIndex = slides.length - loopedSlides * 3 + activeIndex;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if (activeIndex >= slides.length - loopedSlides) {
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  swiper.emit("loopFix");
}
function loopDestroy() {
  const swiper = this;
  const {
    $wrapperEl,
    params,
    slides
  } = swiper;
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
  slides.removeAttr("data-swiper-slide-index");
}
var loop = {
  loopCreate,
  loopFix,
  loopDestroy
};
function setGrabCursor(moving) {
  const swiper = this;
  if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode)
    return;
  const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
  el.style.cursor = "move";
  el.style.cursor = moving ? "-webkit-grabbing" : "-webkit-grab";
  el.style.cursor = moving ? "-moz-grabbin" : "-moz-grab";
  el.style.cursor = moving ? "grabbing" : "grab";
}
function unsetGrabCursor() {
  const swiper = this;
  if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }
  swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
}
var grabCursor = {
  setGrabCursor,
  unsetGrabCursor
};
function closestElement(selector, base) {
  if (base === void 0) {
    base = this;
  }
  function __closestFrom(el) {
    if (!el || el === getDocument() || el === getWindow())
      return null;
    if (el.assignedSlot)
      el = el.assignedSlot;
    const found = el.closest(selector);
    return found || __closestFrom(el.getRootNode().host);
  }
  return __closestFrom(base);
}
function onTouchStart(event) {
  const swiper = this;
  const document2 = getDocument();
  const window2 = getWindow();
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    enabled
  } = swiper;
  if (!enabled)
    return;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  if (!swiper.animating && params.cssMode && params.loop) {
    swiper.loopFix();
  }
  let e2 = event;
  if (e2.originalEvent)
    e2 = e2.originalEvent;
  let $targetEl = $(e2.target);
  if (params.touchEventsTarget === "wrapper") {
    if (!$targetEl.closest(swiper.wrapperEl).length)
      return;
  }
  data.isTouchEvent = e2.type === "touchstart";
  if (!data.isTouchEvent && "which" in e2 && e2.which === 3)
    return;
  if (!data.isTouchEvent && "button" in e2 && e2.button > 0)
    return;
  if (data.isTouched && data.isMoved)
    return;
  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
  if (swipingClassHasValue && e2.target && e2.target.shadowRoot && event.path && event.path[0]) {
    $targetEl = $(event.path[0]);
  }
  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
  const isTargetShadow = !!(e2.target && e2.target.shadowRoot);
  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e2.target) : $targetEl.closest(noSwipingSelector)[0])) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!$targetEl.closest(params.swipeHandler)[0])
      return;
  }
  touches.currentX = e2.type === "touchstart" ? e2.targetTouches[0].pageX : e2.pageX;
  touches.currentY = e2.type === "touchstart" ? e2.targetTouches[0].pageY : e2.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;
  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === "prevent") {
      event.preventDefault();
    } else {
      return;
    }
  }
  Object.assign(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: void 0,
    startMoving: void 0
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = void 0;
  if (params.threshold > 0)
    data.allowThresholdMove = false;
  if (e2.type !== "touchstart") {
    let preventDefault = true;
    if ($targetEl.is(data.focusableElements)) {
      preventDefault = false;
      if ($targetEl[0].nodeName === "SELECT") {
        data.isTouched = false;
      }
    }
    if (document2.activeElement && $(document2.activeElement).is(data.focusableElements) && document2.activeElement !== $targetEl[0]) {
      document2.activeElement.blur();
    }
    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
      e2.preventDefault();
    }
  }
  if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
    swiper.freeMode.onTouchStart();
  }
  swiper.emit("touchStart", e2);
}
function onTouchMove(event) {
  const document2 = getDocument();
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper;
  if (!enabled)
    return;
  let e2 = event;
  if (e2.originalEvent)
    e2 = e2.originalEvent;
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit("touchMoveOpposite", e2);
    }
    return;
  }
  if (data.isTouchEvent && e2.type !== "touchmove")
    return;
  const targetTouch = e2.type === "touchmove" && e2.targetTouches && (e2.targetTouches[0] || e2.changedTouches[0]);
  const pageX = e2.type === "touchmove" ? targetTouch.pageX : e2.pageX;
  const pageY = e2.type === "touchmove" ? targetTouch.pageY : e2.pageY;
  if (e2.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    if (!$(e2.target).is(data.focusableElements)) {
      swiper.allowClick = false;
    }
    if (data.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = now();
    }
    return;
  }
  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }
  if (data.isTouchEvent && document2.activeElement) {
    if (e2.target === document2.activeElement && $(e2.target).is(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit("touchMove", e2);
  }
  if (e2.targetTouches && e2.targetTouches.length > 1)
    return;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)
    return;
  if (typeof data.isScrolling === "undefined") {
    let touchAngle;
    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit("touchMoveOpposite", e2);
  }
  if (typeof data.startMoving === "undefined") {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e2.cancelable) {
    e2.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e2.stopPropagation();
  }
  if (!data.isMoved) {
    if (params.loop && !params.cssMode) {
      swiper.loopFix();
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      swiper.$wrapperEl.trigger("webkitTransitionEnd transitionend");
    }
    data.allowMomentumBounce = false;
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit("sliderFirstMove", e2);
  }
  swiper.emit("sliderMove", e2);
  data.isMoved = true;
  let diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl)
    diff = -diff;
  swiper.swipeDirection = diff > 0 ? "prev" : "next";
  data.currentTranslate = diff + data.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
    disableParentSwiper = false;
    if (params.resistance)
      data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance)
      data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
  }
  if (disableParentSwiper) {
    e2.preventedByNestedSwiper = true;
  }
  if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  }
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }
  if (!params.followFinger || params.cssMode)
    return;
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
    swiper.freeMode.onTouchMove();
  }
  swiper.updateProgress(data.currentTranslate);
  swiper.setTranslate(data.currentTranslate);
}
function onTouchEnd(event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper;
  if (!enabled)
    return;
  let e2 = event;
  if (e2.originalEvent)
    e2 = e2.originalEvent;
  if (data.allowTouchCallbacks) {
    swiper.emit("touchEnd", e2);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }
  const touchEndTime = now();
  const timeDiff = touchEndTime - data.touchStartTime;
  if (swiper.allowClick) {
    const pathTree = e2.path || e2.composedPath && e2.composedPath();
    swiper.updateClickedSlide(pathTree && pathTree[0] || e2.target);
    swiper.emit("tap click", e2);
    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit("doubleTap doubleClick", e2);
    }
  }
  data.lastClickTime = now();
  nextTick(() => {
    if (!swiper.destroyed)
      swiper.allowClick = true;
  });
  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }
  if (params.cssMode) {
    return;
  }
  if (swiper.params.freeMode && params.freeMode.enabled) {
    swiper.freeMode.onTouchEnd({
      currentPos
    });
    return;
  }
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i2 = 0; i2 < slidesGrid.length; i2 += i2 < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment2 = i2 < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (typeof slidesGrid[i2 + increment2] !== "undefined") {
      if (currentPos >= slidesGrid[i2] && currentPos < slidesGrid[i2 + increment2]) {
        stopIndex = i2;
        groupSize = slidesGrid[i2 + increment2] - slidesGrid[i2];
      }
    } else if (currentPos >= slidesGrid[i2]) {
      stopIndex = i2;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === "next") {
      if (ratio >= params.longSwipesRatio)
        swiper.slideTo(stopIndex + increment);
      else
        swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === "prev") {
      if (ratio > 1 - params.longSwipesRatio)
        swiper.slideTo(stopIndex + increment);
      else
        swiper.slideTo(stopIndex);
    }
  } else {
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper.navigation && (e2.target === swiper.navigation.nextEl || e2.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === "next") {
        swiper.slideTo(stopIndex + increment);
      }
      if (swiper.swipeDirection === "prev") {
        swiper.slideTo(stopIndex);
      }
    } else if (e2.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}
function onResize() {
  const swiper = this;
  const {
    params,
    el
  } = swiper;
  if (el && el.offsetWidth === 0)
    return;
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }
  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper;
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();
  if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    swiper.slideTo(swiper.activeIndex, 0, false, true);
  }
  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    swiper.autoplay.run();
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}
function onClick(e2) {
  const swiper = this;
  if (!swiper.enabled)
    return;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks)
      e2.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e2.stopPropagation();
      e2.stopImmediatePropagation();
    }
  }
}
function onScroll() {
  const swiper = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled)
    return;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    swiper.translate = -wrapperEl.scrollLeft;
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  if (swiper.translate === -0)
    swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }
  swiper.emit("setTranslate", swiper.translate, false);
}
let dummyEventAttached = false;
function dummyEventListener() {
}
const events$1 = (swiper, method) => {
  const document2 = getDocument();
  const {
    params,
    touchEvents,
    el,
    wrapperEl,
    device,
    support: support2
  } = swiper;
  const capture = !!params.nested;
  const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
  const swiperMethod = method;
  if (!support2.touch) {
    el[domMethod](touchEvents.start, swiper.onTouchStart, false);
    document2[domMethod](touchEvents.move, swiper.onTouchMove, capture);
    document2[domMethod](touchEvents.end, swiper.onTouchEnd, false);
  } else {
    const passiveListener = touchEvents.start === "touchstart" && support2.passiveListener && params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
    el[domMethod](touchEvents.move, swiper.onTouchMove, support2.passiveListener ? {
      passive: false,
      capture
    } : capture);
    el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);
    if (touchEvents.cancel) {
      el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
    }
  }
  if (params.preventClicks || params.preventClicksPropagation) {
    el[domMethod]("click", swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl[domMethod]("scroll", swiper.onScroll);
  }
  if (params.updateOnWindowResize) {
    swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
  } else {
    swiper[swiperMethod]("observerUpdate", onResize, true);
  }
};
function attachEvents() {
  const swiper = this;
  const document2 = getDocument();
  const {
    params,
    support: support2
  } = swiper;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }
  swiper.onClick = onClick.bind(swiper);
  if (support2.touch && !dummyEventAttached) {
    document2.addEventListener("touchstart", dummyEventListener);
    dummyEventAttached = true;
  }
  events$1(swiper, "on");
}
function detachEvents() {
  const swiper = this;
  events$1(swiper, "off");
}
var events$2 = {
  attachEvents,
  detachEvents
};
const isGridEnabled = (swiper, params) => {
  return swiper.grid && params.grid && params.grid.rows > 1;
};
function setBreakpoint() {
  const swiper = this;
  const {
    activeIndex,
    initialized,
    loopedSlides = 0,
    params,
    $el
  } = swiper;
  const breakpoints2 = params.breakpoints;
  if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0)
    return;
  const breakpoint = swiper.getBreakpoint(breakpoints2, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint)
    return;
  const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;
  const breakpointParams = breakpointOnlyParams || swiper.originalParams;
  const wasMultiRow = isGridEnabled(swiper, params);
  const isMultiRow = isGridEnabled(swiper, breakpointParams);
  const wasEnabled = params.enabled;
  if (wasMultiRow && !isMultiRow) {
    $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    $el.addClass(`${params.containerModifierClass}grid`);
    if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
      $el.addClass(`${params.containerModifierClass}grid-column`);
    }
    swiper.emitContainerClasses();
  }
  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
  if (directionChanged && initialized) {
    swiper.changeDirection();
  }
  extend(swiper.params, breakpointParams);
  const isEnabled = swiper.params.enabled;
  Object.assign(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });
  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }
  swiper.currentBreakpoint = breakpoint;
  swiper.emit("_beforeBreakpoint", breakpointParams);
  if (needsReLoop && initialized) {
    swiper.loopDestroy();
    swiper.loopCreate();
    swiper.updateSlides();
    swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
  }
  swiper.emit("breakpoint", breakpointParams);
}
function getBreakpoint(breakpoints2, base, containerEl) {
  if (base === void 0) {
    base = "window";
  }
  if (!breakpoints2 || base === "container" && !containerEl)
    return void 0;
  let breakpoint = false;
  const window2 = getWindow();
  const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
  const points = Object.keys(breakpoints2).map((point) => {
    if (typeof point === "string" && point.indexOf("@") === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = currentHeight * minRatio;
      return {
        value,
        point
      };
    }
    return {
      value: point,
      point
    };
  });
  points.sort((a2, b2) => parseInt(a2.value, 10) - parseInt(b2.value, 10));
  for (let i2 = 0; i2 < points.length; i2 += 1) {
    const {
      point,
      value
    } = points[i2];
    if (base === "window") {
      if (window2.matchMedia(`(min-width: ${value}px)`).matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || "max";
}
var breakpoints = {
  setBreakpoint,
  getBreakpoint
};
function prepareClasses(entries, prefix) {
  const resultClasses = [];
  entries.forEach((item) => {
    if (typeof item === "object") {
      Object.keys(item).forEach((classNames) => {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === "string") {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}
function addClasses() {
  const swiper = this;
  const {
    classNames,
    params,
    rtl,
    $el,
    device,
    support: support2
  } = swiper;
  const suffixes = prepareClasses(["initialized", params.direction, {
    "pointer-events": !support2.touch
  }, {
    "free-mode": swiper.params.freeMode && params.freeMode.enabled
  }, {
    "autoheight": params.autoHeight
  }, {
    "rtl": rtl
  }, {
    "grid": params.grid && params.grid.rows > 1
  }, {
    "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
  }, {
    "android": device.android
  }, {
    "ios": device.ios
  }, {
    "css-mode": params.cssMode
  }, {
    "centered": params.cssMode && params.centeredSlides
  }], params.containerModifierClass);
  classNames.push(...suffixes);
  $el.addClass([...classNames].join(" "));
  swiper.emitContainerClasses();
}
function removeClasses() {
  const swiper = this;
  const {
    $el,
    classNames
  } = swiper;
  $el.removeClass(classNames.join(" "));
  swiper.emitContainerClasses();
}
var classes = {
  addClasses,
  removeClasses
};
function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
  const window2 = getWindow();
  let image;
  function onReady() {
    if (callback)
      callback();
  }
  const isPicture = $(imageEl).parent("picture")[0];
  if (!isPicture && (!imageEl.complete || !checkForComplete)) {
    if (src) {
      image = new window2.Image();
      image.onload = onReady;
      image.onerror = onReady;
      if (sizes) {
        image.sizes = sizes;
      }
      if (srcset) {
        image.srcset = srcset;
      }
      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    onReady();
  }
}
function preloadImages() {
  const swiper = this;
  swiper.imagesToLoad = swiper.$el.find("img");
  function onReady() {
    if (typeof swiper === "undefined" || swiper === null || !swiper || swiper.destroyed)
      return;
    if (swiper.imagesLoaded !== void 0)
      swiper.imagesLoaded += 1;
    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady)
        swiper.update();
      swiper.emit("imagesReady");
    }
  }
  for (let i2 = 0; i2 < swiper.imagesToLoad.length; i2 += 1) {
    const imageEl = swiper.imagesToLoad[i2];
    swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute("src"), imageEl.srcset || imageEl.getAttribute("srcset"), imageEl.sizes || imageEl.getAttribute("sizes"), true, onReady);
  }
}
var images = {
  loadImage,
  preloadImages
};
function checkOverflow() {
  const swiper = this;
  const {
    isLocked: wasLocked,
    params
  } = swiper;
  const {
    slidesOffsetBefore
  } = params;
  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper.slides.length - 1;
    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper.isLocked = swiper.size > lastSlideRightEdge;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }
  if (params.allowSlideNext === true) {
    swiper.allowSlideNext = !swiper.isLocked;
  }
  if (params.allowSlidePrev === true) {
    swiper.allowSlidePrev = !swiper.isLocked;
  }
  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
  }
  if (wasLocked !== swiper.isLocked) {
    swiper.emit(swiper.isLocked ? "lock" : "unlock");
  }
}
var checkOverflow$1 = {
  checkOverflow
};
var defaults = {
  init: true,
  direction: "horizontal",
  touchEventsTarget: "wrapper",
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  enabled: true,
  focusableElements: "input, select, option, textarea, button, video, label",
  width: null,
  height: null,
  preventInteractionOnTransition: false,
  userAgent: null,
  url: null,
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  autoHeight: false,
  setWrapperSize: false,
  virtualTranslate: false,
  effect: "slide",
  breakpoints: void 0,
  breakpointsBase: "window",
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  slidesOffsetAfter: 0,
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  watchOverflow: true,
  roundLengths: false,
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  uniqueNavElements: true,
  resistance: true,
  resistanceRatio: 0.85,
  watchSlidesProgress: false,
  grabCursor: false,
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  preloadImages: true,
  updateOnImagesReady: true,
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopFillGroupWithBlank: false,
  loopPreventsSlide: true,
  rewind: false,
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  noSwiping: true,
  noSwipingClass: "swiper-no-swiping",
  noSwipingSelector: null,
  passiveListeners: true,
  maxBackfaceHiddenSlides: 10,
  containerModifierClass: "swiper-",
  slideClass: "swiper-slide",
  slideBlankClass: "swiper-slide-invisible-blank",
  slideActiveClass: "swiper-slide-active",
  slideDuplicateActiveClass: "swiper-slide-duplicate-active",
  slideVisibleClass: "swiper-slide-visible",
  slideDuplicateClass: "swiper-slide-duplicate",
  slideNextClass: "swiper-slide-next",
  slideDuplicateNextClass: "swiper-slide-duplicate-next",
  slidePrevClass: "swiper-slide-prev",
  slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
  wrapperClass: "swiper-wrapper",
  runCallbacksOnInit: true,
  _emitClasses: false
};
function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj) {
    if (obj === void 0) {
      obj = {};
    }
    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];
    if (typeof moduleParams !== "object" || moduleParams === null) {
      extend(allModulesParams, obj);
      return;
    }
    if (["navigation", "pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
      params[moduleParamName] = {
        auto: true
      };
    }
    if (!(moduleParamName in params && "enabled" in moduleParams)) {
      extend(allModulesParams, obj);
      return;
    }
    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true
      };
    }
    if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }
    if (!params[moduleParamName])
      params[moduleParamName] = {
        enabled: false
      };
    extend(allModulesParams, obj);
  };
}
const prototypes = {
  eventsEmitter,
  update,
  translate,
  transition,
  slide,
  loop,
  grabCursor,
  events: events$2,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes,
  images
};
const extendedDefaults = {};
class Swiper {
  constructor() {
    let el;
    let params;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params)
      params = {};
    params = extend({}, params);
    if (el && !params.el)
      params.el = el;
    if (params.el && $(params.el).length > 1) {
      const swipers = [];
      $(params.el).each((containerEl) => {
        const newParams = extend({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    }
    const swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport();
    swiper.device = getDevice({
      userAgent: params.userAgent
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];
    swiper.modules = [...swiper.__modules__];
    if (params.modules && Array.isArray(params.modules)) {
      swiper.modules.push(...params.modules);
    }
    const allModulesParams = {};
    swiper.modules.forEach((mod) => {
      mod({
        swiper,
        extendParams: moduleExtendParams(params, allModulesParams),
        on: swiper.on.bind(swiper),
        once: swiper.once.bind(swiper),
        off: swiper.off.bind(swiper),
        emit: swiper.emit.bind(swiper)
      });
    });
    const swiperParams = extend({}, defaults, allModulesParams);
    swiper.params = extend({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = extend({}, swiper.params);
    swiper.passedParams = extend({}, params);
    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach((eventName) => {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }
    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    }
    swiper.$ = $;
    Object.assign(swiper, {
      enabled: swiper.params.enabled,
      el,
      classNames: [],
      slides: $(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      isHorizontal() {
        return swiper.params.direction === "horizontal";
      },
      isVertical() {
        return swiper.params.direction === "vertical";
      },
      activeIndex: 0,
      realIndex: 0,
      isBeginning: true,
      isEnd: false,
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      touchEvents: function touchEvents() {
        const touch = ["touchstart", "touchmove", "touchend", "touchcancel"];
        const desktop = ["pointerdown", "pointermove", "pointerup"];
        swiper.touchEventsTouch = {
          start: touch[0],
          move: touch[1],
          end: touch[2],
          cancel: touch[3]
        };
        swiper.touchEventsDesktop = {
          start: desktop[0],
          move: desktop[1],
          end: desktop[2]
        };
        return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
      }(),
      touchEventsData: {
        isTouched: void 0,
        isMoved: void 0,
        allowTouchCallbacks: void 0,
        touchStartTime: void 0,
        isScrolling: void 0,
        currentTranslate: void 0,
        startTranslate: void 0,
        allowThresholdMove: void 0,
        focusableElements: swiper.params.focusableElements,
        lastClickTime: now(),
        clickTimeout: void 0,
        velocities: [],
        allowMomentumBounce: void 0,
        isTouchEvent: void 0,
        startMoving: void 0
      },
      allowClick: true,
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper.emit("_swiper");
    if (swiper.params.init) {
      swiper.init();
    }
    return swiper;
  }
  enable() {
    const swiper = this;
    if (swiper.enabled)
      return;
    swiper.enabled = true;
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }
    swiper.emit("enable");
  }
  disable() {
    const swiper = this;
    if (!swiper.enabled)
      return;
    swiper.enabled = false;
    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }
    swiper.emit("disable");
  }
  setProgress(progress, speed) {
    const swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min = swiper.minTranslate();
    const max = swiper.maxTranslate();
    const current = (max - min) * progress + min;
    swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  emitContainerClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el)
      return;
    const cls = swiper.el.className.split(" ").filter((className) => {
      return className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit("_containerClasses", cls.join(" "));
  }
  getSlideClasses(slideEl) {
    const swiper = this;
    return slideEl.className.split(" ").filter((className) => {
      return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(" ");
  }
  emitSlidesClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el)
      return;
    const updates = [];
    swiper.slides.each((slideEl) => {
      const classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      });
      swiper.emit("_slideClass", slideEl, classNames);
    });
    swiper.emit("_slideClasses", updates);
  }
  slidesPerViewDynamic(view2, exact) {
    if (view2 === void 0) {
      view2 = "current";
    }
    if (exact === void 0) {
      exact = false;
    }
    const swiper = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper;
    let spv = 1;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex].swiperSlideSize;
      let breakLoop;
      for (let i2 = activeIndex + 1; i2 < slides.length; i2 += 1) {
        if (slides[i2] && !breakLoop) {
          slideSize += slides[i2].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize)
            breakLoop = true;
        }
      }
      for (let i2 = activeIndex - 1; i2 >= 0; i2 -= 1) {
        if (slides[i2] && !breakLoop) {
          slideSize += slides[i2].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize)
            breakLoop = true;
        }
      }
    } else {
      if (view2 === "current") {
        for (let i2 = activeIndex + 1; i2 < slides.length; i2 += 1) {
          const slideInView = exact ? slidesGrid[i2] + slidesSizesGrid[i2] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i2] - slidesGrid[activeIndex] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        for (let i2 = activeIndex - 1; i2 >= 0; i2 -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i2] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      }
    }
    return spv;
  }
  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed)
      return;
    const {
      snapGrid,
      params
    } = swiper;
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();
    function setTranslate2() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
      setTranslate2();
      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === "auto" || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate2();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit("update");
  }
  changeDirection(newDirection, needUpdate) {
    if (needUpdate === void 0) {
      needUpdate = true;
    }
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
    }
    if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
      return swiper;
    }
    swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.each((slideEl) => {
      if (newDirection === "vertical") {
        slideEl.style.width = "";
      } else {
        slideEl.style.height = "";
      }
    });
    swiper.emit("changeDirection");
    if (needUpdate)
      swiper.update();
    return swiper;
  }
  mount(el) {
    const swiper = this;
    if (swiper.mounted)
      return true;
    const $el = $(el || swiper.params.el);
    el = $el[0];
    if (!el) {
      return false;
    }
    el.swiper = swiper;
    const getWrapperSelector = () => {
      return `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
    };
    const getWrapper = () => {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        const res = $(el.shadowRoot.querySelector(getWrapperSelector()));
        res.children = (options) => $el.children(options);
        return res;
      }
      return $el.children(getWrapperSelector());
    };
    let $wrapperEl = getWrapper();
    if ($wrapperEl.length === 0 && swiper.params.createElements) {
      const document2 = getDocument();
      const wrapper = document2.createElement("div");
      $wrapperEl = $(wrapper);
      wrapper.className = swiper.params.wrapperClass;
      $el.append(wrapper);
      $el.children(`.${swiper.params.slideClass}`).each((slideEl) => {
        $wrapperEl.append(slideEl);
      });
    }
    Object.assign(swiper, {
      $el,
      el,
      $wrapperEl,
      wrapperEl: $wrapperEl[0],
      mounted: true,
      rtl: el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl",
      rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl"),
      wrongRTL: $wrapperEl.css("display") === "-webkit-box"
    });
    return true;
  }
  init(el) {
    const swiper = this;
    if (swiper.initialized)
      return swiper;
    const mounted = swiper.mount(el);
    if (mounted === false)
      return swiper;
    swiper.emit("beforeInit");
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.addClasses();
    if (swiper.params.loop) {
      swiper.loopCreate();
    }
    swiper.updateSize();
    swiper.updateSlides();
    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }
    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }
    if (swiper.params.preloadImages) {
      swiper.preloadImages();
    }
    if (swiper.params.loop) {
      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    }
    swiper.attachEvents();
    swiper.initialized = true;
    swiper.emit("init");
    swiper.emit("afterInit");
    return swiper;
  }
  destroy(deleteInstance, cleanStyles) {
    if (deleteInstance === void 0) {
      deleteInstance = true;
    }
    if (cleanStyles === void 0) {
      cleanStyles = true;
    }
    const swiper = this;
    const {
      params,
      $el,
      $wrapperEl,
      slides
    } = swiper;
    if (typeof swiper.params === "undefined" || swiper.destroyed) {
      return null;
    }
    swiper.emit("beforeDestroy");
    swiper.initialized = false;
    swiper.detachEvents();
    if (params.loop) {
      swiper.loopDestroy();
    }
    if (cleanStyles) {
      swiper.removeClasses();
      $el.removeAttr("style");
      $wrapperEl.removeAttr("style");
      if (slides && slides.length) {
        slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index");
      }
    }
    swiper.emit("destroy");
    Object.keys(swiper.eventsListeners).forEach((eventName) => {
      swiper.off(eventName);
    });
    if (deleteInstance !== false) {
      swiper.$el[0].swiper = null;
      deleteProps(swiper);
    }
    swiper.destroyed = true;
    return null;
  }
  static extendDefaults(newDefaults) {
    extend(extendedDefaults, newDefaults);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults;
  }
  static installModule(mod) {
    if (!Swiper.prototype.__modules__)
      Swiper.prototype.__modules__ = [];
    const modules = Swiper.prototype.__modules__;
    if (typeof mod === "function" && modules.indexOf(mod) < 0) {
      modules.push(mod);
    }
  }
  static use(module) {
    if (Array.isArray(module)) {
      module.forEach((m2) => Swiper.installModule(m2));
      return Swiper;
    }
    Swiper.installModule(module);
    return Swiper;
  }
}
Object.keys(prototypes).forEach((prototypeGroup) => {
  Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper.use([Resize, Observer]);
function Keyboard(_ref) {
  let {
    swiper,
    extendParams,
    on: on2,
    emit
  } = _ref;
  const document2 = getDocument();
  const window2 = getWindow();
  swiper.keyboard = {
    enabled: false
  };
  extendParams({
    keyboard: {
      enabled: false,
      onlyInViewport: true,
      pageUpDown: true
    }
  });
  function handle(event) {
    if (!swiper.enabled)
      return;
    const {
      rtlTranslate: rtl
    } = swiper;
    let e2 = event;
    if (e2.originalEvent)
      e2 = e2.originalEvent;
    const kc = e2.keyCode || e2.charCode;
    const pageUpDown = swiper.params.keyboard.pageUpDown;
    const isPageUp = pageUpDown && kc === 33;
    const isPageDown = pageUpDown && kc === 34;
    const isArrowLeft = kc === 37;
    const isArrowRight = kc === 39;
    const isArrowUp = kc === 38;
    const isArrowDown = kc === 40;
    if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
      return false;
    }
    if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
      return false;
    }
    if (e2.shiftKey || e2.altKey || e2.ctrlKey || e2.metaKey) {
      return void 0;
    }
    if (document2.activeElement && document2.activeElement.nodeName && (document2.activeElement.nodeName.toLowerCase() === "input" || document2.activeElement.nodeName.toLowerCase() === "textarea")) {
      return void 0;
    }
    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
      let inView = false;
      if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
        return void 0;
      }
      const $el = swiper.$el;
      const swiperWidth = $el[0].clientWidth;
      const swiperHeight = $el[0].clientHeight;
      const windowWidth = window2.innerWidth;
      const windowHeight = window2.innerHeight;
      const swiperOffset = swiper.$el.offset();
      if (rtl)
        swiperOffset.left -= swiper.$el[0].scrollLeft;
      const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];
      for (let i2 = 0; i2 < swiperCoord.length; i2 += 1) {
        const point = swiperCoord[i2];
        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
          if (point[0] === 0 && point[1] === 0)
            continue;
          inView = true;
        }
      }
      if (!inView)
        return void 0;
    }
    if (swiper.isHorizontal()) {
      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
        if (e2.preventDefault)
          e2.preventDefault();
        else
          e2.returnValue = false;
      }
      if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl)
        swiper.slideNext();
      if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl)
        swiper.slidePrev();
    } else {
      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
        if (e2.preventDefault)
          e2.preventDefault();
        else
          e2.returnValue = false;
      }
      if (isPageDown || isArrowDown)
        swiper.slideNext();
      if (isPageUp || isArrowUp)
        swiper.slidePrev();
    }
    emit("keyPress", kc);
    return void 0;
  }
  function enable() {
    if (swiper.keyboard.enabled)
      return;
    $(document2).on("keydown", handle);
    swiper.keyboard.enabled = true;
  }
  function disable() {
    if (!swiper.keyboard.enabled)
      return;
    $(document2).off("keydown", handle);
    swiper.keyboard.enabled = false;
  }
  on2("init", () => {
    if (swiper.params.keyboard.enabled) {
      enable();
    }
  });
  on2("destroy", () => {
    if (swiper.keyboard.enabled) {
      disable();
    }
  });
  Object.assign(swiper.keyboard, {
    enable,
    disable
  });
}
function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
  const document2 = getDocument();
  if (swiper.params.createElements) {
    Object.keys(checkProps).forEach((key) => {
      if (!params[key] && params.auto === true) {
        let element = swiper.$el.children(`.${checkProps[key]}`)[0];
        if (!element) {
          element = document2.createElement("div");
          element.className = checkProps[key];
          swiper.$el.append(element);
        }
        params[key] = element;
        originalParams[key] = element;
      }
    });
  }
  return params;
}
function Navigation(_ref) {
  let {
    swiper,
    extendParams,
    on: on2,
    emit
  } = _ref;
  extendParams({
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: false,
      disabledClass: "swiper-button-disabled",
      hiddenClass: "swiper-button-hidden",
      lockClass: "swiper-button-lock"
    }
  });
  swiper.navigation = {
    nextEl: null,
    $nextEl: null,
    prevEl: null,
    $prevEl: null
  };
  function getEl(el) {
    let $el;
    if (el) {
      $el = $(el);
      if (swiper.params.uniqueNavElements && typeof el === "string" && $el.length > 1 && swiper.$el.find(el).length === 1) {
        $el = swiper.$el.find(el);
      }
    }
    return $el;
  }
  function toggleEl($el, disabled) {
    const params = swiper.params.navigation;
    if ($el && $el.length > 0) {
      $el[disabled ? "addClass" : "removeClass"](params.disabledClass);
      if ($el[0] && $el[0].tagName === "BUTTON")
        $el[0].disabled = disabled;
      if (swiper.params.watchOverflow && swiper.enabled) {
        $el[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
      }
    }
  }
  function update3() {
    if (swiper.params.loop)
      return;
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;
    toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
    toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
  }
  function onPrevClick(e2) {
    e2.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind)
      return;
    swiper.slidePrev();
  }
  function onNextClick(e2) {
    e2.preventDefault();
    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind)
      return;
    swiper.slideNext();
  }
  function init() {
    const params = swiper.params.navigation;
    swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
      nextEl: "swiper-button-next",
      prevEl: "swiper-button-prev"
    });
    if (!(params.nextEl || params.prevEl))
      return;
    const $nextEl = getEl(params.nextEl);
    const $prevEl = getEl(params.prevEl);
    if ($nextEl && $nextEl.length > 0) {
      $nextEl.on("click", onNextClick);
    }
    if ($prevEl && $prevEl.length > 0) {
      $prevEl.on("click", onPrevClick);
    }
    Object.assign(swiper.navigation, {
      $nextEl,
      nextEl: $nextEl && $nextEl[0],
      $prevEl,
      prevEl: $prevEl && $prevEl[0]
    });
    if (!swiper.enabled) {
      if ($nextEl)
        $nextEl.addClass(params.lockClass);
      if ($prevEl)
        $prevEl.addClass(params.lockClass);
    }
  }
  function destroy2() {
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;
    if ($nextEl && $nextEl.length) {
      $nextEl.off("click", onNextClick);
      $nextEl.removeClass(swiper.params.navigation.disabledClass);
    }
    if ($prevEl && $prevEl.length) {
      $prevEl.off("click", onPrevClick);
      $prevEl.removeClass(swiper.params.navigation.disabledClass);
    }
  }
  on2("init", () => {
    init();
    update3();
  });
  on2("toEdge fromEdge lock unlock", () => {
    update3();
  });
  on2("destroy", () => {
    destroy2();
  });
  on2("enable disable", () => {
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;
    if ($nextEl) {
      $nextEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
    }
    if ($prevEl) {
      $prevEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
    }
  });
  on2("click", (_s, e2) => {
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;
    const targetEl = e2.target;
    if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {
      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl)))
        return;
      let isHidden;
      if ($nextEl) {
        isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
      } else if ($prevEl) {
        isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
      }
      if (isHidden === true) {
        emit("navigationShow");
      } else {
        emit("navigationHide");
      }
      if ($nextEl) {
        $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
      }
      if ($prevEl) {
        $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
      }
    }
  });
  Object.assign(swiper.navigation, {
    update: update3,
    init,
    destroy: destroy2
  });
}
function classesToSelector(classes2) {
  if (classes2 === void 0) {
    classes2 = "";
  }
  return `.${classes2.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}`;
}
function Pagination(_ref) {
  let {
    swiper,
    extendParams,
    on: on2,
    emit
  } = _ref;
  const pfx = "swiper-pagination";
  extendParams({
    pagination: {
      el: null,
      bulletElement: "span",
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: "bullets",
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: (number) => number,
      formatFractionTotal: (number) => number,
      bulletClass: `${pfx}-bullet`,
      bulletActiveClass: `${pfx}-bullet-active`,
      modifierClass: `${pfx}-`,
      currentClass: `${pfx}-current`,
      totalClass: `${pfx}-total`,
      hiddenClass: `${pfx}-hidden`,
      progressbarFillClass: `${pfx}-progressbar-fill`,
      progressbarOppositeClass: `${pfx}-progressbar-opposite`,
      clickableClass: `${pfx}-clickable`,
      lockClass: `${pfx}-lock`,
      horizontalClass: `${pfx}-horizontal`,
      verticalClass: `${pfx}-vertical`
    }
  });
  swiper.pagination = {
    el: null,
    $el: null,
    bullets: []
  };
  let bulletSize;
  let dynamicBulletIndex = 0;
  function isPaginationDisabled() {
    return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;
  }
  function setSideBullets($bulletEl, position) {
    const {
      bulletActiveClass
    } = swiper.params.pagination;
    $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
  }
  function update3() {
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (isPaginationDisabled())
      return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const $el = swiper.pagination.$el;
    let current;
    const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop) {
      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
      if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
        current -= slidesLength - swiper.loopedSlides * 2;
      }
      if (current > total - 1)
        current -= total;
      if (current < 0 && swiper.params.paginationType !== "bullets")
        current = total + current;
    } else if (typeof swiper.snapIndex !== "undefined") {
      current = swiper.snapIndex;
    } else {
      current = swiper.activeIndex || 0;
    }
    if (params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;
      if (params.dynamicBullets) {
        bulletSize = bullets.eq(0)[swiper.isHorizontal() ? "outerWidth" : "outerHeight"](true);
        $el.css(swiper.isHorizontal() ? "width" : "height", `${bulletSize * (params.dynamicMainBullets + 4)}px`);
        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== void 0) {
          dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);
          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
            dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (dynamicBulletIndex < 0) {
            dynamicBulletIndex = 0;
          }
        }
        firstIndex = Math.max(current - dynamicBulletIndex, 0);
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }
      bullets.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((suffix) => `${params.bulletActiveClass}${suffix}`).join(" "));
      if ($el.length > 1) {
        bullets.each((bullet) => {
          const $bullet = $(bullet);
          const bulletIndex = $bullet.index();
          if (bulletIndex === current) {
            $bullet.addClass(params.bulletActiveClass);
          }
          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              $bullet.addClass(`${params.bulletActiveClass}-main`);
            }
            if (bulletIndex === firstIndex) {
              setSideBullets($bullet, "prev");
            }
            if (bulletIndex === lastIndex) {
              setSideBullets($bullet, "next");
            }
          }
        });
      } else {
        const $bullet = bullets.eq(current);
        const bulletIndex = $bullet.index();
        $bullet.addClass(params.bulletActiveClass);
        if (params.dynamicBullets) {
          const $firstDisplayedBullet = bullets.eq(firstIndex);
          const $lastDisplayedBullet = bullets.eq(lastIndex);
          for (let i2 = firstIndex; i2 <= lastIndex; i2 += 1) {
            bullets.eq(i2).addClass(`${params.bulletActiveClass}-main`);
          }
          if (swiper.params.loop) {
            if (bulletIndex >= bullets.length) {
              for (let i2 = params.dynamicMainBullets; i2 >= 0; i2 -= 1) {
                bullets.eq(bullets.length - i2).addClass(`${params.bulletActiveClass}-main`);
              }
              bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
            } else {
              setSideBullets($firstDisplayedBullet, "prev");
              setSideBullets($lastDisplayedBullet, "next");
            }
          } else {
            setSideBullets($firstDisplayedBullet, "prev");
            setSideBullets($lastDisplayedBullet, "next");
          }
        }
      }
      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
        const offsetProp = rtl ? "right" : "left";
        bullets.css(swiper.isHorizontal() ? offsetProp : "top", `${bulletsOffset}px`);
      }
    }
    if (params.type === "fraction") {
      $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
      $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
    }
    if (params.type === "progressbar") {
      let progressbarDirection;
      if (params.progressbarOpposite) {
        progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal";
      } else {
        progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
      }
      const scale2 = (current + 1) / total;
      let scaleX2 = 1;
      let scaleY2 = 1;
      if (progressbarDirection === "horizontal") {
        scaleX2 = scale2;
      } else {
        scaleY2 = scale2;
      }
      $el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX2}) scaleY(${scaleY2})`).transition(swiper.params.speed);
    }
    if (params.type === "custom" && params.renderCustom) {
      $el.html(params.renderCustom(swiper, current + 1, total));
      emit("paginationRender", $el[0]);
    } else {
      emit("paginationUpdate", $el[0]);
    }
    if (swiper.params.watchOverflow && swiper.enabled) {
      $el[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
    }
  }
  function render3() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled())
      return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const $el = swiper.pagination.$el;
    let paginationHTML = "";
    if (params.type === "bullets") {
      let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {
        numberOfBullets = slidesLength;
      }
      for (let i2 = 0; i2 < numberOfBullets; i2 += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i2, params.bulletClass);
        } else {
          paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }
      $el.html(paginationHTML);
      swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
    }
    if (params.type === "fraction") {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = `<span class="${params.currentClass}"></span> / <span class="${params.totalClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type === "progressbar") {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type !== "custom") {
      emit("paginationRender", swiper.pagination.$el[0]);
    }
  }
  function init() {
    swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
      el: "swiper-pagination"
    });
    const params = swiper.params.pagination;
    if (!params.el)
      return;
    let $el = $(params.el);
    if ($el.length === 0)
      return;
    if (swiper.params.uniqueNavElements && typeof params.el === "string" && $el.length > 1) {
      $el = swiper.$el.find(params.el);
      if ($el.length > 1) {
        $el = $el.filter((el) => {
          if ($(el).parents(".swiper")[0] !== swiper.el)
            return false;
          return true;
        });
      }
    }
    if (params.type === "bullets" && params.clickable) {
      $el.addClass(params.clickableClass);
    }
    $el.addClass(params.modifierClass + params.type);
    $el.addClass(params.modifierClass + swiper.params.direction);
    if (params.type === "bullets" && params.dynamicBullets) {
      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
      dynamicBulletIndex = 0;
      if (params.dynamicMainBullets < 1) {
        params.dynamicMainBullets = 1;
      }
    }
    if (params.type === "progressbar" && params.progressbarOpposite) {
      $el.addClass(params.progressbarOppositeClass);
    }
    if (params.clickable) {
      $el.on("click", classesToSelector(params.bulletClass), function onClick2(e2) {
        e2.preventDefault();
        let index2 = $(this).index() * swiper.params.slidesPerGroup;
        if (swiper.params.loop)
          index2 += swiper.loopedSlides;
        swiper.slideTo(index2);
      });
    }
    Object.assign(swiper.pagination, {
      $el,
      el: $el[0]
    });
    if (!swiper.enabled) {
      $el.addClass(params.lockClass);
    }
  }
  function destroy2() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled())
      return;
    const $el = swiper.pagination.$el;
    $el.removeClass(params.hiddenClass);
    $el.removeClass(params.modifierClass + params.type);
    $el.removeClass(params.modifierClass + swiper.params.direction);
    if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass)
      swiper.pagination.bullets.removeClass(params.bulletActiveClass);
    if (params.clickable) {
      $el.off("click", classesToSelector(params.bulletClass));
    }
  }
  on2("init", () => {
    init();
    render3();
    update3();
  });
  on2("activeIndexChange", () => {
    if (swiper.params.loop) {
      update3();
    } else if (typeof swiper.snapIndex === "undefined") {
      update3();
    }
  });
  on2("snapIndexChange", () => {
    if (!swiper.params.loop) {
      update3();
    }
  });
  on2("slidesLengthChange", () => {
    if (swiper.params.loop) {
      render3();
      update3();
    }
  });
  on2("snapGridLengthChange", () => {
    if (!swiper.params.loop) {
      render3();
      update3();
    }
  });
  on2("destroy", () => {
    destroy2();
  });
  on2("enable disable", () => {
    const {
      $el
    } = swiper.pagination;
    if ($el) {
      $el[swiper.enabled ? "removeClass" : "addClass"](swiper.params.pagination.lockClass);
    }
  });
  on2("lock unlock", () => {
    update3();
  });
  on2("click", (_s, e2) => {
    const targetEl = e2.target;
    const {
      $el
    } = swiper.pagination;
    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl))
        return;
      const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);
      if (isHidden === true) {
        emit("paginationShow");
      } else {
        emit("paginationHide");
      }
      $el.toggleClass(swiper.params.pagination.hiddenClass);
    }
  });
  Object.assign(swiper.pagination, {
    render: render3,
    update: update3,
    init,
    destroy: destroy2
  });
}
function Scrollbar(_ref) {
  let {
    swiper,
    extendParams,
    on: on2,
    emit
  } = _ref;
  const document2 = getDocument();
  let isTouched = false;
  let timeout = null;
  let dragTimeout = null;
  let dragStartPos;
  let dragSize;
  let trackSize;
  let divider;
  extendParams({
    scrollbar: {
      el: null,
      dragSize: "auto",
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: "swiper-scrollbar-lock",
      dragClass: "swiper-scrollbar-drag"
    }
  });
  swiper.scrollbar = {
    el: null,
    dragEl: null,
    $el: null,
    $dragEl: null
  };
  function setTranslate2() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
      return;
    const {
      scrollbar,
      rtlTranslate: rtl,
      progress
    } = swiper;
    const {
      $dragEl,
      $el
    } = scrollbar;
    const params = swiper.params.scrollbar;
    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;
    if (rtl) {
      newPos = -newPos;
      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }
    if (swiper.isHorizontal()) {
      $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
      $dragEl[0].style.width = `${newSize}px`;
    } else {
      $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
      $dragEl[0].style.height = `${newSize}px`;
    }
    if (params.hide) {
      clearTimeout(timeout);
      $el[0].style.opacity = 1;
      timeout = setTimeout(() => {
        $el[0].style.opacity = 0;
        $el.transition(400);
      }, 1e3);
    }
  }
  function setTransition2(duration) {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
      return;
    swiper.scrollbar.$dragEl.transition(duration);
  }
  function updateSize2() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
      return;
    const {
      scrollbar
    } = swiper;
    const {
      $dragEl,
      $el
    } = scrollbar;
    $dragEl[0].style.width = "";
    $dragEl[0].style.height = "";
    trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
    divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
    if (swiper.params.scrollbar.dragSize === "auto") {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }
    if (swiper.isHorizontal()) {
      $dragEl[0].style.width = `${dragSize}px`;
    } else {
      $dragEl[0].style.height = `${dragSize}px`;
    }
    if (divider >= 1) {
      $el[0].style.display = "none";
    } else {
      $el[0].style.display = "";
    }
    if (swiper.params.scrollbar.hide) {
      $el[0].style.opacity = 0;
    }
    if (swiper.params.watchOverflow && swiper.enabled) {
      scrollbar.$el[swiper.isLocked ? "addClass" : "removeClass"](swiper.params.scrollbar.lockClass);
    }
  }
  function getPointerPosition(e2) {
    if (swiper.isHorizontal()) {
      return e2.type === "touchstart" || e2.type === "touchmove" ? e2.targetTouches[0].clientX : e2.clientX;
    }
    return e2.type === "touchstart" || e2.type === "touchmove" ? e2.targetTouches[0].clientY : e2.clientY;
  }
  function setDragPosition(e2) {
    const {
      scrollbar,
      rtlTranslate: rtl
    } = swiper;
    const {
      $el
    } = scrollbar;
    let positionRatio;
    positionRatio = (getPointerPosition(e2) - $el.offset()[swiper.isHorizontal() ? "left" : "top"] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
    if (rtl) {
      positionRatio = 1 - positionRatio;
    }
    const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  function onDragStart(e2) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      $wrapperEl
    } = swiper;
    const {
      $el,
      $dragEl
    } = scrollbar;
    isTouched = true;
    dragStartPos = e2.target === $dragEl[0] || e2.target === $dragEl ? getPointerPosition(e2) - e2.target.getBoundingClientRect()[swiper.isHorizontal() ? "left" : "top"] : null;
    e2.preventDefault();
    e2.stopPropagation();
    $wrapperEl.transition(100);
    $dragEl.transition(100);
    setDragPosition(e2);
    clearTimeout(dragTimeout);
    $el.transition(0);
    if (params.hide) {
      $el.css("opacity", 1);
    }
    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css("scroll-snap-type", "none");
    }
    emit("scrollbarDragStart", e2);
  }
  function onDragMove(e2) {
    const {
      scrollbar,
      $wrapperEl
    } = swiper;
    const {
      $el,
      $dragEl
    } = scrollbar;
    if (!isTouched)
      return;
    if (e2.preventDefault)
      e2.preventDefault();
    else
      e2.returnValue = false;
    setDragPosition(e2);
    $wrapperEl.transition(0);
    $el.transition(0);
    $dragEl.transition(0);
    emit("scrollbarDragMove", e2);
  }
  function onDragEnd(e2) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      $wrapperEl
    } = swiper;
    const {
      $el
    } = scrollbar;
    if (!isTouched)
      return;
    isTouched = false;
    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css("scroll-snap-type", "");
      $wrapperEl.transition("");
    }
    if (params.hide) {
      clearTimeout(dragTimeout);
      dragTimeout = nextTick(() => {
        $el.css("opacity", 0);
        $el.transition(400);
      }, 1e3);
    }
    emit("scrollbarDragEnd", e2);
    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  }
  function events2(method) {
    const {
      scrollbar,
      touchEventsTouch,
      touchEventsDesktop,
      params,
      support: support2
    } = swiper;
    const $el = scrollbar.$el;
    const target = $el[0];
    const activeListener = support2.passiveListener && params.passiveListeners ? {
      passive: false,
      capture: false
    } : false;
    const passiveListener = support2.passiveListener && params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    if (!target)
      return;
    const eventMethod = method === "on" ? "addEventListener" : "removeEventListener";
    if (!support2.touch) {
      target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
      document2[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
      document2[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
    } else {
      target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
      target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
      target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
    }
  }
  function enableDraggable() {
    if (!swiper.params.scrollbar.el)
      return;
    events2("on");
  }
  function disableDraggable() {
    if (!swiper.params.scrollbar.el)
      return;
    events2("off");
  }
  function init() {
    const {
      scrollbar,
      $el: $swiperEl
    } = swiper;
    swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
      el: "swiper-scrollbar"
    });
    const params = swiper.params.scrollbar;
    if (!params.el)
      return;
    let $el = $(params.el);
    if (swiper.params.uniqueNavElements && typeof params.el === "string" && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
      $el = $swiperEl.find(params.el);
    }
    let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);
    if ($dragEl.length === 0) {
      $dragEl = $(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
      $el.append($dragEl);
    }
    Object.assign(scrollbar, {
      $el,
      el: $el[0],
      $dragEl,
      dragEl: $dragEl[0]
    });
    if (params.draggable) {
      enableDraggable();
    }
    if ($el) {
      $el[swiper.enabled ? "removeClass" : "addClass"](swiper.params.scrollbar.lockClass);
    }
  }
  function destroy2() {
    disableDraggable();
  }
  on2("init", () => {
    init();
    updateSize2();
    setTranslate2();
  });
  on2("update resize observerUpdate lock unlock", () => {
    updateSize2();
  });
  on2("setTranslate", () => {
    setTranslate2();
  });
  on2("setTransition", (_s, duration) => {
    setTransition2(duration);
  });
  on2("enable disable", () => {
    const {
      $el
    } = swiper.scrollbar;
    if ($el) {
      $el[swiper.enabled ? "removeClass" : "addClass"](swiper.params.scrollbar.lockClass);
    }
  });
  on2("destroy", () => {
    destroy2();
  });
  Object.assign(swiper.scrollbar, {
    updateSize: updateSize2,
    setTranslate: setTranslate2,
    init,
    destroy: destroy2
  });
}
function Autoplay(_ref) {
  let {
    swiper,
    extendParams,
    on: on2,
    emit
  } = _ref;
  let timeout;
  swiper.autoplay = {
    running: false,
    paused: false
  };
  extendParams({
    autoplay: {
      enabled: false,
      delay: 3e3,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false,
      pauseOnMouseEnter: false
    }
  });
  function run() {
    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
    let delay = swiper.params.autoplay.delay;
    if ($activeSlideEl.attr("data-swiper-autoplay")) {
      delay = $activeSlideEl.attr("data-swiper-autoplay") || swiper.params.autoplay.delay;
    }
    clearTimeout(timeout);
    timeout = nextTick(() => {
      let autoplayResult;
      if (swiper.params.autoplay.reverseDirection) {
        if (swiper.params.loop) {
          swiper.loopFix();
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          emit("autoplay");
        } else if (!swiper.isBeginning) {
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          emit("autoplay");
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
          emit("autoplay");
        } else {
          stop2();
        }
      } else if (swiper.params.loop) {
        swiper.loopFix();
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        emit("autoplay");
      } else if (!swiper.isEnd) {
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        emit("autoplay");
      } else if (!swiper.params.autoplay.stopOnLastSlide) {
        autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
        emit("autoplay");
      } else {
        stop2();
      }
      if (swiper.params.cssMode && swiper.autoplay.running)
        run();
      else if (autoplayResult === false) {
        run();
      }
    }, delay);
  }
  function start() {
    if (typeof timeout !== "undefined")
      return false;
    if (swiper.autoplay.running)
      return false;
    swiper.autoplay.running = true;
    emit("autoplayStart");
    run();
    return true;
  }
  function stop2() {
    if (!swiper.autoplay.running)
      return false;
    if (typeof timeout === "undefined")
      return false;
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
    swiper.autoplay.running = false;
    emit("autoplayStop");
    return true;
  }
  function pause(speed) {
    if (!swiper.autoplay.running)
      return;
    if (swiper.autoplay.paused)
      return;
    if (timeout)
      clearTimeout(timeout);
    swiper.autoplay.paused = true;
    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
      swiper.autoplay.paused = false;
      run();
    } else {
      ["transitionend", "webkitTransitionEnd"].forEach((event) => {
        swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
      });
    }
  }
  function onVisibilityChange() {
    const document2 = getDocument();
    if (document2.visibilityState === "hidden" && swiper.autoplay.running) {
      pause();
    }
    if (document2.visibilityState === "visible" && swiper.autoplay.paused) {
      run();
      swiper.autoplay.paused = false;
    }
  }
  function onTransitionEnd(e2) {
    if (!swiper || swiper.destroyed || !swiper.$wrapperEl)
      return;
    if (e2.target !== swiper.$wrapperEl[0])
      return;
    ["transitionend", "webkitTransitionEnd"].forEach((event) => {
      swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
    });
    swiper.autoplay.paused = false;
    if (!swiper.autoplay.running) {
      stop2();
    } else {
      run();
    }
  }
  function onMouseEnter() {
    if (swiper.params.autoplay.disableOnInteraction) {
      stop2();
    } else {
      emit("autoplayPause");
      pause();
    }
    ["transitionend", "webkitTransitionEnd"].forEach((event) => {
      swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
    });
  }
  function onMouseLeave() {
    if (swiper.params.autoplay.disableOnInteraction) {
      return;
    }
    swiper.autoplay.paused = false;
    emit("autoplayResume");
    run();
  }
  function attachMouseEvents() {
    if (swiper.params.autoplay.pauseOnMouseEnter) {
      swiper.$el.on("mouseenter", onMouseEnter);
      swiper.$el.on("mouseleave", onMouseLeave);
    }
  }
  function detachMouseEvents() {
    swiper.$el.off("mouseenter", onMouseEnter);
    swiper.$el.off("mouseleave", onMouseLeave);
  }
  on2("init", () => {
    if (swiper.params.autoplay.enabled) {
      start();
      const document2 = getDocument();
      document2.addEventListener("visibilitychange", onVisibilityChange);
      attachMouseEvents();
    }
  });
  on2("beforeTransitionStart", (_s, speed, internal) => {
    if (swiper.autoplay.running) {
      if (internal || !swiper.params.autoplay.disableOnInteraction) {
        swiper.autoplay.pause(speed);
      } else {
        stop2();
      }
    }
  });
  on2("sliderFirstMove", () => {
    if (swiper.autoplay.running) {
      if (swiper.params.autoplay.disableOnInteraction) {
        stop2();
      } else {
        pause();
      }
    }
  });
  on2("touchEnd", () => {
    if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
      run();
    }
  });
  on2("destroy", () => {
    detachMouseEvents();
    if (swiper.autoplay.running) {
      stop2();
    }
    const document2 = getDocument();
    document2.removeEventListener("visibilitychange", onVisibilityChange);
  });
  Object.assign(swiper.autoplay, {
    pause,
    run,
    start,
    stop: stop2
  });
}
function Thumb(_ref) {
  let {
    swiper,
    extendParams,
    on: on2
  } = _ref;
  extendParams({
    thumbs: {
      swiper: null,
      multipleActiveThumbs: true,
      autoScrollOffset: 0,
      slideThumbActiveClass: "swiper-slide-thumb-active",
      thumbsContainerClass: "swiper-thumbs"
    }
  });
  let initialized = false;
  let swiperCreated = false;
  swiper.thumbs = {
    swiper: null
  };
  function onThumbClick() {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper)
      return;
    const clickedIndex = thumbsSwiper.clickedIndex;
    const clickedSlide = thumbsSwiper.clickedSlide;
    if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass))
      return;
    if (typeof clickedIndex === "undefined" || clickedIndex === null)
      return;
    let slideToIndex;
    if (thumbsSwiper.params.loop) {
      slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr("data-swiper-slide-index"), 10);
    } else {
      slideToIndex = clickedIndex;
    }
    if (swiper.params.loop) {
      let currentIndex = swiper.activeIndex;
      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
        swiper.loopFix();
        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        currentIndex = swiper.activeIndex;
      }
      const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      if (typeof prevIndex === "undefined")
        slideToIndex = nextIndex;
      else if (typeof nextIndex === "undefined")
        slideToIndex = prevIndex;
      else if (nextIndex - currentIndex < currentIndex - prevIndex)
        slideToIndex = nextIndex;
      else
        slideToIndex = prevIndex;
    }
    swiper.slideTo(slideToIndex);
  }
  function init() {
    const {
      thumbs: thumbsParams
    } = swiper.params;
    if (initialized)
      return false;
    initialized = true;
    const SwiperClass = swiper.constructor;
    if (thumbsParams.swiper instanceof SwiperClass) {
      swiper.thumbs.swiper = thumbsParams.swiper;
      Object.assign(swiper.thumbs.swiper.originalParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      Object.assign(swiper.thumbs.swiper.params, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
    } else if (isObject$1(thumbsParams.swiper)) {
      const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
      Object.assign(thumbsSwiperParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
      swiperCreated = true;
    }
    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
    swiper.thumbs.swiper.on("tap", onThumbClick);
    return true;
  }
  function update3(initial) {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper)
      return;
    const slidesPerView = thumbsSwiper.params.slidesPerView === "auto" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
      let currentThumbsIndex = thumbsSwiper.activeIndex;
      let newThumbsIndex;
      let direction;
      if (thumbsSwiper.params.loop) {
        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
          thumbsSwiper.loopFix();
          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
          currentThumbsIndex = thumbsSwiper.activeIndex;
        }
        const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
        const nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
        if (typeof prevThumbsIndex === "undefined") {
          newThumbsIndex = nextThumbsIndex;
        } else if (typeof nextThumbsIndex === "undefined") {
          newThumbsIndex = prevThumbsIndex;
        } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
          newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
        } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
          newThumbsIndex = nextThumbsIndex;
        } else {
          newThumbsIndex = prevThumbsIndex;
        }
        direction = swiper.activeIndex > swiper.previousIndex ? "next" : "prev";
      } else {
        newThumbsIndex = swiper.realIndex;
        direction = newThumbsIndex > swiper.previousIndex ? "next" : "prev";
      }
      if (useOffset) {
        newThumbsIndex += direction === "next" ? autoScrollOffset : -1 * autoScrollOffset;
      }
      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
        if (thumbsSwiper.params.centeredSlides) {
          if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
          } else {
            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
          }
        } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1)
          ;
        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : void 0);
      }
    }
    let thumbsToActivate = 1;
    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
      thumbsToActivate = swiper.params.slidesPerView;
    }
    if (!swiper.params.thumbs.multipleActiveThumbs) {
      thumbsToActivate = 1;
    }
    thumbsToActivate = Math.floor(thumbsToActivate);
    thumbsSwiper.slides.removeClass(thumbActiveClass);
    if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
      for (let i2 = 0; i2 < thumbsToActivate; i2 += 1) {
        thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper.realIndex + i2}"]`).addClass(thumbActiveClass);
      }
    } else {
      for (let i2 = 0; i2 < thumbsToActivate; i2 += 1) {
        thumbsSwiper.slides.eq(swiper.realIndex + i2).addClass(thumbActiveClass);
      }
    }
  }
  on2("beforeInit", () => {
    const {
      thumbs
    } = swiper.params;
    if (!thumbs || !thumbs.swiper)
      return;
    init();
    update3(true);
  });
  on2("slideChange update resize observerUpdate", () => {
    if (!swiper.thumbs.swiper)
      return;
    update3();
  });
  on2("setTransition", (_s, duration) => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper)
      return;
    thumbsSwiper.setTransition(duration);
  });
  on2("beforeDestroy", () => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper)
      return;
    if (swiperCreated && thumbsSwiper) {
      thumbsSwiper.destroy();
    }
  });
  Object.assign(swiper.thumbs, {
    init,
    update: update3
  });
}
var __defProp$6 = Object.defineProperty;
var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
var __decorateClass$6 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$6(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$6(target, key, result);
  return result;
};
let QySwiper = class extends s {
  constructor() {
    super(...arguments);
    this.hasThumb = false;
    this.autoplay = false;
  }
  static get styles() {
    return swiperStyles;
  }
  get slides() {
    var _a, _b;
    return [
      ...Array.from(this.querySelectorAll("qy-swiper-slide")),
      ...Array.from((_b = (_a = this.divSlides) == null ? void 0 : _a.querySelectorAll("qy-swiper-slide")) != null ? _b : [])
    ];
  }
  async openViewer(imageUrl, imageType) {
    let qyView = document.querySelector("qy-viewer");
    if (!qyView) {
      const viewerElement = document.createElement("qy-viewer");
      document.body.appendChild(viewerElement);
      qyView = await new Promise((res) => {
        viewerElement.addEventListener("load", () => {
          res(document.querySelector("qy-viewer"));
        });
      });
    }
    qyView.open(imageUrl, imageType);
  }
  firstUpdated() {
    Swiper.use([
      Navigation,
      Pagination,
      Scrollbar,
      Autoplay,
      Thumb,
      Keyboard
    ]);
    this.slider = new Swiper(this.divContainer, {
      navigation: {
        prevEl: this.divPrevious,
        nextEl: this.divNext
      },
      pagination: this.hasThumb ? {} : {
        el: this.divPagination
      },
      autoplay: this.autoplay ? {
        delay: 5e3,
        disableOnInteraction: false,
        reverseDirection: false,
        stopOnLastSlide: false,
        waitForTransition: true
      } : false,
      thumbs: this.hasThumb ? {
        swiper: new Swiper(this.divGallery, {
          spaceBetween: 10,
          slidesPerView: Math.min(Math.max(4, this.slides.length), 8),
          watchSlidesProgress: true
        })
      } : {},
      preventClicks: false,
      preventClicksPropagation: true,
      loop: true
    });
  }
  render() {
    return $$1`
      <style>
        :host {
          display: block;
          --swiper-theme-color: var(--lit-slider-theme-color);
          --swiper-navigation-color: var(--lit-slider-navigation-color);
          --swiper-gallery-height: 0px;
          --swiper-slider-margin-bottom: 0px;
          --swiper-navigation-size: 30px;
          --swiper-navigation-color: blue;
        }

        :host([hasThumb]) {
          --swiper-slider-margin-bottom: 10px;
          --swiper-gallery-height: calc(100px - var(--swiper-slider-margin-bottom));
        }

        #divContainer {
          height: calc(100% - calc(var(--swiper-gallery-height)) - var(--swiper-slider-margin-bottom));
          margin-bottom: var(--swiper-slider-margin-bottom);
        }

        #divGallery {
          height: var(--swiper-gallery-height);
        }

        .gallery-thumbs .swiper-slide {
          height: 100%;
          opacity: 0.25;
          transition: 200ms;
          cursor: pointer;
        }

        .gallery-thumbs .swiper-slide-thumb-active {
          opacity: 1;
        }

        .gallery-thumb {
          background-position: center !important;
          background-repeat: no-repeat !important;
          background-size: cover !important;
        }

        .swiper-wrapper {
          text-align: center;
        }

        .swiper-slide {
          background-color: white;
          height: 200px;
        }

        img.viewer {
          object-fit: contain;
          height: 100%;
          width: 100%;
          cursor: pointer;
        }

        img.viewer {
          object-fit: contain;
          height: 100%;
          width: 100%;
          cursor: pointer;
        }

        img.viewer.w-caption {
          height: calc(100% - 10px - 1.5rem);
        }

        .slider-caption {
          padding: 5px;
          margin: 0;
          line-height: 1.5em;
          background: #000000;
          color: #ffffff;
          font-size: 0.6rem;
          font-weight: 700;
        }
      </style>
      <div id='divContainer' class='swiper-container gallery-top'>
        <div id='divSlides' class='swiper-wrapper'>
          ${this.slides.map((slide2) => {
      return $$1`
              <div class='swiper-slide'>
                <img src="${slide2.thumbnailUrl}" onclick="this.getRootNode().host.openViewer('${slide2.imageUrl}', '${slide2.imageType}')" class="viewer${slide2.caption !== "" ? ` w-caption` : ""}">
                ${slide2.caption !== "" ? $$1`<p class="slider-caption">${slide2.caption}</p>` : ""}
              </div>
            `;
    })}
        </div>

        <div id='divPagination' class='swiper-pagination'></div>
        <div id='divPrevious' class='swiper-button-prev'></div>
        <div id='divNext' class='swiper-button-next'></div>
      </div>
      <div id='divGallery' class='swiper-container gallery-thumbs'>
        <div class='swiper-wrapper'>
          ${this.slides.map((_2, index2) => $$1`
            <div class='swiper-slide gallery-thumb'
              @click=${() => {
      var _a;
      return (_a = this.slider) == null ? void 0 : _a.slideTo(index2);
    }}
            ></div>
          `)}
        </div>
      </div>
      <qy-viewer id="qyViewer"></qy-viewerid>
    `;
  }
};
__decorateClass$6([
  e({ type: Boolean, reflect: true })
], QySwiper.prototype, "hasThumb", 2);
__decorateClass$6([
  e({ type: Boolean, reflect: true })
], QySwiper.prototype, "autoplay", 2);
__decorateClass$6([
  i("#divContainer")
], QySwiper.prototype, "divContainer", 2);
__decorateClass$6([
  i("#divSlides")
], QySwiper.prototype, "divSlides", 2);
__decorateClass$6([
  i("#divGallery")
], QySwiper.prototype, "divGallery", 2);
__decorateClass$6([
  i("#divPagination")
], QySwiper.prototype, "divPagination", 2);
__decorateClass$6([
  i("#divPrevious")
], QySwiper.prototype, "divPrevious", 2);
__decorateClass$6([
  i("#divNext")
], QySwiper.prototype, "divNext", 2);
QySwiper = __decorateClass$6([
  n$1("qy-swiper")
], QySwiper);
var __defProp$5 = Object.defineProperty;
var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
var __decorateClass$5 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$5(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$5(target, key, result);
  return result;
};
let QySwiperSlide = class extends s {
  constructor() {
    super(...arguments);
    this.thumbnailUrl = "";
    this.imageUrl = "";
    this.imageType = "";
    this.caption = "";
  }
  static get styles() {
    return r$2`
      :host {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
        width: 100%;
        background-size: cover !important;
        background-repeat: no-repeat !important;
        background-position: center !important;
      }
    `;
  }
  render() {
    return $$1``;
  }
};
__decorateClass$5([
  e({ type: String, reflect: true })
], QySwiperSlide.prototype, "thumbnailUrl", 2);
__decorateClass$5([
  e({ type: String, reflect: true })
], QySwiperSlide.prototype, "imageUrl", 2);
__decorateClass$5([
  e({ type: String, reflect: true })
], QySwiperSlide.prototype, "imageType", 2);
__decorateClass$5([
  e({ type: String, reflect: true })
], QySwiperSlide.prototype, "caption", 2);
QySwiperSlide = __decorateClass$5([
  n$1("qy-swiper-slide")
], QySwiperSlide);
const viewerIconCss = r$2`
  /*!
   *  Font Awesome 4.7.0 by @davegandy - http://fontawesome.io - @fontawesome
   *  License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License)
   */
  @font-face {
    font-family: qy-viewer-fontawesome-subset;
    src: url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAQ4AAsAAAAACNQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAEEAAABgiDOFTGNtYXAAAAFMAAAALwAAADTgCxBwZ2FzcAAAAXwAAAAIAAAACP//AANnbHlmAAABhAAAAHkAAACgt8J71mhlYWQAAAIAAAAAMAAAADYM/OLiaGhlYQAAAjAAAAAfAAAAJAuCBnJobXR4AAACUAAAAAwAAAAMDkADLWxvY2EAAAJcAAAADwAAABAAAADYbWF4cAAAAmwAAAAdAAAAIABGACduYW1lAAACjAAAAaAAAAYkHs+aNnBvc3QAAAQsAAAADAAAACAAAwAAeNpjYGbLZJzAwMrAwNLDYszAwNAGoZmKGRgYuxhQAaMAEqegsqiYwYFB4QMvG8N/IJ+NgRGsBkmJAgMDANUACIYAAAB42mNgYGBkYAZiBgYeBhYGDSDNBqQZGZgYFD7w/v8P5IPp/w/5v4JVAQEAnEUJZgAAAAAB//8AAnjaY2BknMRUxJTH7MfAzMDAKKgoyDiJ4Q5TEcOd/yoMjAx5/9+xCrFMYlBmYFAR4WdkU1LnBBL6jGom5pxAwp7RzEicE0jIM4qJsHMysgrJdMgEyPy79e8WkOqQkWFUA7LAYoxqjGoQsX+3gKJ4ZWXgpjAAAIY0J64AAAB42mNgZGBgAOKitvO74/ltvjIwsjOAwBXjs0ZwOu//O1YhlklALgcDE0g1AEMQC0t42mNgZGBgY/jPwMDAzsCQx5DHKsQAFEEBzAA0VQIFAAcAAr8BwAAABYAAbnjaY2AAAxkoXgAAAjgA2QB42mNgZGBgYGZQYQDRDAxMQMwIZjuA+QwABiUAbgAAAHja7dKxSsNAGAfw/yXRIqKgiKDTDQ4uxraIgltRWjdpC0UchJYebSEmeklbOro4iJuv4OggvoMvIg4+gA/gv9dvcHGog4jYkt7vu7vvfwkpAK2uoTD5bPOaWGGN1cQecjgS+5w/Fgd0VzyDZVyJZzl/J87RD7TCvMt/Fo/z38XMVwti5qsVMfPVlpj5qixmvjoRM19dsksFc8w/UzdihaJ6E3tY9NbFPorepjigT8Uz2PBuxbOcfxTn6BfnpXG+vyJmvm/FzPfvxcz3n8TM91/FzA9WxcwP9sXMD6KD5GJke51upg+bA6Mrzbg90sV8YTfUpSjSbinV1qTGDkw7rI4aPTM0tpzEWWlo0uTc1Put1GQ10+lHTfvl+pcLDWPTXhLrnXAvzLuTp8/4Ew+BAyS4wAgWPXT4786gcYgmBjBUhYrR5rpGEXkUsIuQLiHiV3/qSl1lOBqO4+42d1bZ2eAeg6GbL/O0mLtLrk5ZnXOso4+W68xQ42+HdcST7Tf6p+9ouH0pe8Y7NXZ433u88p+e+Sfu4/9N/JI38QFM0j60eNpjYGbACwAAfQAE') format('woff');
    font-weight: normal;
    font-style: normal;
  }
`;
injectCSS(viewerIconCss);
const viewerStyles = r$2`.fa {display: inline-block;font: normal normal normal 14px/1 qy-viewer-fontawesome-subset;font-size: inherit;text-rendering: auto;-webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;}.fa-times:before {content: "\\f00d";}`;
var __defProp$4 = Object.defineProperty;
var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
var __decorateClass$4 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$4(target, key, result);
  return result;
};
class QyViewerBase extends s {
  constructor() {
    super(...arguments);
    this.canBackdropClose = false;
    this.isShow = false;
  }
  open(_imgUrl) {
    this.isShow = true;
  }
  close() {
    this.isShow = false;
  }
  renderViewer() {
    return $$1``;
  }
  render() {
    return $$1`
      <style>
        .backdrop {
          z-index: var(--qy-viewer-z-index-each);
        }
      </style>
      <div
        class="backdrop"
        style="${this.isShow ? "visibility: visible" : "visibility: hidden"}"
      >
        <div class="close" @click="${() => this.close()}">
          <i class="fa fa-times" aria-hidden="true"></i>
        </div>
        <div class="viewer">${this.renderViewer()}</div>
      </div>
    `;
  }
}
QyViewerBase.styles = r$2`
    ${viewerStyles}
  
    .backdrop {
      justify-content: center;
      align-items: center;
      position: fixed;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
    }

    .close {
      position: absolute;
      right: 0;
      top: 0;
      margin: 10px;
      cursor: pointer;
    }

    .close > i {
      color: #fff;
      font-size: 30px;
    }
    
    .viewer {
      position: absolute;
      width: 100%;
      height: 80%;
      inset: 0px;
      margin: auto;
      align-self: center;
      background-color: #000;
    }
  `;
__decorateClass$4([
  e({ type: Boolean, attribute: "close-backdrop" })
], QyViewerBase.prototype, "canBackdropClose", 2);
__decorateClass$4([
  e({ type: Boolean, attribute: "show" })
], QyViewerBase.prototype, "isShow", 2);
/*!
 * Viewer.js v1.10.3
 * https://fengyuanchen.github.io/viewerjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2022-02-02T05:15:01.702Z
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DEFAULTS = {
  backdrop: true,
  button: true,
  navbar: true,
  title: true,
  toolbar: true,
  className: "",
  container: "body",
  filter: null,
  fullscreen: true,
  inheritedAttributes: ["crossOrigin", "decoding", "isMap", "loading", "referrerPolicy", "sizes", "srcset", "useMap"],
  initialViewIndex: 0,
  inline: false,
  interval: 5e3,
  keyboard: true,
  focus: true,
  loading: true,
  loop: true,
  minWidth: 200,
  minHeight: 100,
  movable: true,
  rotatable: true,
  scalable: true,
  zoomable: true,
  zoomOnTouch: true,
  zoomOnWheel: true,
  slideOnTouch: true,
  toggleOnDblclick: true,
  tooltip: true,
  transition: true,
  zIndex: 2015,
  zIndexInline: 0,
  zoomRatio: 0.1,
  minZoomRatio: 0.01,
  maxZoomRatio: 100,
  url: "src",
  ready: null,
  show: null,
  shown: null,
  hide: null,
  hidden: null,
  view: null,
  viewed: null,
  move: null,
  moved: null,
  rotate: null,
  rotated: null,
  scale: null,
  scaled: null,
  zoom: null,
  zoomed: null,
  play: null,
  stop: null
};
var TEMPLATE = '<div class="viewer-container" tabindex="-1" touch-action="none"><div class="viewer-canvas"></div><div class="viewer-footer"><div class="viewer-title"></div><div class="viewer-toolbar"></div><div class="viewer-navbar"><ul class="viewer-list" role="navigation"></ul></div></div><div class="viewer-tooltip" role="alert" aria-hidden="true"></div><div class="viewer-button" data-viewer-action="mix" role="button"></div><div class="viewer-player"></div></div>';
var IS_BROWSER = typeof window !== "undefined" && typeof window.document !== "undefined";
var WINDOW = IS_BROWSER ? window : {};
var IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? "ontouchstart" in WINDOW.document.documentElement : false;
var HAS_POINTER_EVENT = IS_BROWSER ? "PointerEvent" in WINDOW : false;
var NAMESPACE = "viewer";
var ACTION_MOVE = "move";
var ACTION_SWITCH = "switch";
var ACTION_ZOOM = "zoom";
var CLASS_ACTIVE = "".concat(NAMESPACE, "-active");
var CLASS_CLOSE = "".concat(NAMESPACE, "-close");
var CLASS_FADE = "".concat(NAMESPACE, "-fade");
var CLASS_FIXED = "".concat(NAMESPACE, "-fixed");
var CLASS_FULLSCREEN = "".concat(NAMESPACE, "-fullscreen");
var CLASS_FULLSCREEN_EXIT = "".concat(NAMESPACE, "-fullscreen-exit");
var CLASS_HIDE = "".concat(NAMESPACE, "-hide");
var CLASS_HIDE_MD_DOWN = "".concat(NAMESPACE, "-hide-md-down");
var CLASS_HIDE_SM_DOWN = "".concat(NAMESPACE, "-hide-sm-down");
var CLASS_HIDE_XS_DOWN = "".concat(NAMESPACE, "-hide-xs-down");
var CLASS_IN = "".concat(NAMESPACE, "-in");
var CLASS_INVISIBLE = "".concat(NAMESPACE, "-invisible");
var CLASS_LOADING = "".concat(NAMESPACE, "-loading");
var CLASS_MOVE = "".concat(NAMESPACE, "-move");
var CLASS_OPEN = "".concat(NAMESPACE, "-open");
var CLASS_SHOW = "".concat(NAMESPACE, "-show");
var CLASS_TRANSITION = "".concat(NAMESPACE, "-transition");
var EVENT_CLICK = "click";
var EVENT_DBLCLICK = "dblclick";
var EVENT_DRAG_START = "dragstart";
var EVENT_FOCUSIN = "focusin";
var EVENT_KEY_DOWN = "keydown";
var EVENT_LOAD = "load";
var EVENT_ERROR = "error";
var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? "touchend touchcancel" : "mouseup";
var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? "touchmove" : "mousemove";
var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? "touchstart" : "mousedown";
var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? "pointerdown" : EVENT_TOUCH_START;
var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? "pointermove" : EVENT_TOUCH_MOVE;
var EVENT_POINTER_UP = HAS_POINTER_EVENT ? "pointerup pointercancel" : EVENT_TOUCH_END;
var EVENT_RESIZE = "resize";
var EVENT_TRANSITION_END = "transitionend";
var EVENT_WHEEL = "wheel";
var EVENT_READY = "ready";
var EVENT_SHOW = "show";
var EVENT_SHOWN = "shown";
var EVENT_HIDE = "hide";
var EVENT_HIDDEN = "hidden";
var EVENT_VIEW = "view";
var EVENT_VIEWED = "viewed";
var EVENT_MOVE = "move";
var EVENT_MOVED = "moved";
var EVENT_ROTATE = "rotate";
var EVENT_ROTATED = "rotated";
var EVENT_SCALE = "scale";
var EVENT_SCALED = "scaled";
var EVENT_ZOOM = "zoom";
var EVENT_ZOOMED = "zoomed";
var EVENT_PLAY = "play";
var EVENT_STOP = "stop";
var DATA_ACTION = "".concat(NAMESPACE, "Action");
var REGEXP_SPACES = /\s\s*/;
var BUTTONS = ["zoom-in", "zoom-out", "one-to-one", "reset", "prev", "play", "next", "rotate-left", "rotate-right", "flip-horizontal", "flip-vertical"];
function isString(value) {
  return typeof value === "string";
}
var isNaN$1 = Number.isNaN || WINDOW.isNaN;
function isNumber(value) {
  return typeof value === "number" && !isNaN$1(value);
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isObject(value) {
  return _typeof(value) === "object" && value !== null;
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function isPlainObject(value) {
  if (!isObject(value)) {
    return false;
  }
  try {
    var _constructor = value.constructor;
    var prototype = _constructor.prototype;
    return _constructor && prototype && hasOwnProperty.call(prototype, "isPrototypeOf");
  } catch (error) {
    return false;
  }
}
function isFunction(value) {
  return typeof value === "function";
}
function forEach(data, callback) {
  if (data && isFunction(callback)) {
    if (Array.isArray(data) || isNumber(data.length)) {
      var length = data.length;
      var i2;
      for (i2 = 0; i2 < length; i2 += 1) {
        if (callback.call(data, data[i2], i2, data) === false) {
          break;
        }
      }
    } else if (isObject(data)) {
      Object.keys(data).forEach(function(key) {
        callback.call(data, data[key], key, data);
      });
    }
  }
  return data;
}
var assign = Object.assign || function assign2(obj) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  if (isObject(obj) && args.length > 0) {
    args.forEach(function(arg) {
      if (isObject(arg)) {
        Object.keys(arg).forEach(function(key) {
          obj[key] = arg[key];
        });
      }
    });
  }
  return obj;
};
var REGEXP_SUFFIX = /^(?:width|height|left|top|marginLeft|marginTop)$/;
function setStyle(element, styles2) {
  var style = element.style;
  forEach(styles2, function(value, property) {
    if (REGEXP_SUFFIX.test(property) && isNumber(value)) {
      value += "px";
    }
    style[property] = value;
  });
}
function escapeHTMLEntities(value) {
  return isString(value) ? value.replace(/&(?!amp;|quot;|#39;|lt;|gt;)/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;") : value;
}
function hasClass(element, value) {
  if (!element || !value) {
    return false;
  }
  return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;
}
function addClass(element, value) {
  if (!element || !value) {
    return;
  }
  if (isNumber(element.length)) {
    forEach(element, function(elem) {
      addClass(elem, value);
    });
    return;
  }
  if (element.classList) {
    element.classList.add(value);
    return;
  }
  var className = element.className.trim();
  if (!className) {
    element.className = value;
  } else if (className.indexOf(value) < 0) {
    element.className = "".concat(className, " ").concat(value);
  }
}
function removeClass(element, value) {
  if (!element || !value) {
    return;
  }
  if (isNumber(element.length)) {
    forEach(element, function(elem) {
      removeClass(elem, value);
    });
    return;
  }
  if (element.classList) {
    element.classList.remove(value);
    return;
  }
  if (element.className.indexOf(value) >= 0) {
    element.className = element.className.replace(value, "");
  }
}
function toggleClass(element, value, added) {
  if (!value) {
    return;
  }
  if (isNumber(element.length)) {
    forEach(element, function(elem) {
      toggleClass(elem, value, added);
    });
    return;
  }
  if (added) {
    addClass(element, value);
  } else {
    removeClass(element, value);
  }
}
var REGEXP_HYPHENATE = /([a-z\d])([A-Z])/g;
function hyphenate(value) {
  return value.replace(REGEXP_HYPHENATE, "$1-$2").toLowerCase();
}
function getData(element, name) {
  if (isObject(element[name])) {
    return element[name];
  }
  if (element.dataset) {
    return element.dataset[name];
  }
  return element.getAttribute("data-".concat(hyphenate(name)));
}
function setData(element, name, data) {
  if (isObject(data)) {
    element[name] = data;
  } else if (element.dataset) {
    element.dataset[name] = data;
  } else {
    element.setAttribute("data-".concat(hyphenate(name)), data);
  }
}
var onceSupported = function() {
  var supported = false;
  if (IS_BROWSER) {
    var once = false;
    var listener = function listener2() {
    };
    var options = Object.defineProperty({}, "once", {
      get: function get() {
        supported = true;
        return once;
      },
      set: function set(value) {
        once = value;
      }
    });
    WINDOW.addEventListener("test", listener, options);
    WINDOW.removeEventListener("test", listener, options);
  }
  return supported;
}();
function removeListener(element, type, listener) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var handler = listener;
  type.trim().split(REGEXP_SPACES).forEach(function(event) {
    if (!onceSupported) {
      var listeners = element.listeners;
      if (listeners && listeners[event] && listeners[event][listener]) {
        handler = listeners[event][listener];
        delete listeners[event][listener];
        if (Object.keys(listeners[event]).length === 0) {
          delete listeners[event];
        }
        if (Object.keys(listeners).length === 0) {
          delete element.listeners;
        }
      }
    }
    element.removeEventListener(event, handler, options);
  });
}
function addListener(element, type, listener) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var _handler = listener;
  type.trim().split(REGEXP_SPACES).forEach(function(event) {
    if (options.once && !onceSupported) {
      var _element$listeners = element.listeners, listeners = _element$listeners === void 0 ? {} : _element$listeners;
      _handler = function handler() {
        delete listeners[event][listener];
        element.removeEventListener(event, _handler, options);
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        listener.apply(element, args);
      };
      if (!listeners[event]) {
        listeners[event] = {};
      }
      if (listeners[event][listener]) {
        element.removeEventListener(event, listeners[event][listener], options);
      }
      listeners[event][listener] = _handler;
      element.listeners = listeners;
    }
    element.addEventListener(event, _handler, options);
  });
}
function dispatchEvent(element, type, data, options) {
  var event;
  if (isFunction(Event) && isFunction(CustomEvent)) {
    event = new CustomEvent(type, _objectSpread2({
      bubbles: true,
      cancelable: true,
      detail: data
    }, options));
  } else {
    event = document.createEvent("CustomEvent");
    event.initCustomEvent(type, true, true, data);
  }
  return element.dispatchEvent(event);
}
function getOffset(element) {
  var box = element.getBoundingClientRect();
  return {
    left: box.left + (window.pageXOffset - document.documentElement.clientLeft),
    top: box.top + (window.pageYOffset - document.documentElement.clientTop)
  };
}
function getTransforms(_ref) {
  var rotate2 = _ref.rotate, scaleX2 = _ref.scaleX, scaleY2 = _ref.scaleY, translateX = _ref.translateX, translateY = _ref.translateY;
  var values = [];
  if (isNumber(translateX) && translateX !== 0) {
    values.push("translateX(".concat(translateX, "px)"));
  }
  if (isNumber(translateY) && translateY !== 0) {
    values.push("translateY(".concat(translateY, "px)"));
  }
  if (isNumber(rotate2) && rotate2 !== 0) {
    values.push("rotate(".concat(rotate2, "deg)"));
  }
  if (isNumber(scaleX2) && scaleX2 !== 1) {
    values.push("scaleX(".concat(scaleX2, ")"));
  }
  if (isNumber(scaleY2) && scaleY2 !== 1) {
    values.push("scaleY(".concat(scaleY2, ")"));
  }
  var transform2 = values.length ? values.join(" ") : "none";
  return {
    WebkitTransform: transform2,
    msTransform: transform2,
    transform: transform2
  };
}
function getImageNameFromURL(url) {
  return isString(url) ? decodeURIComponent(url.replace(/^.*\//, "").replace(/[?&#].*$/, "")) : "";
}
var IS_SAFARI = WINDOW.navigator && /(Macintosh|iPhone|iPod|iPad).*AppleWebKit/i.test(WINDOW.navigator.userAgent);
function getImageNaturalSizes(image, options, callback) {
  var newImage = document.createElement("img");
  if (image.naturalWidth && !IS_SAFARI) {
    callback(image.naturalWidth, image.naturalHeight);
    return newImage;
  }
  var body = document.body || document.documentElement;
  newImage.onload = function() {
    callback(newImage.width, newImage.height);
    if (!IS_SAFARI) {
      body.removeChild(newImage);
    }
  };
  forEach(options.inheritedAttributes, function(name) {
    var value = image.getAttribute(name);
    if (value !== null) {
      newImage.setAttribute(name, value);
    }
  });
  newImage.src = image.src;
  if (!IS_SAFARI) {
    newImage.style.cssText = "left:0;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;opacity:0;position:absolute;top:0;z-index:-1;";
    body.appendChild(newImage);
  }
  return newImage;
}
function getResponsiveClass(type) {
  switch (type) {
    case 2:
      return CLASS_HIDE_XS_DOWN;
    case 3:
      return CLASS_HIDE_SM_DOWN;
    case 4:
      return CLASS_HIDE_MD_DOWN;
    default:
      return "";
  }
}
function getMaxZoomRatio(pointers) {
  var pointers2 = _objectSpread2({}, pointers);
  var ratios = [];
  forEach(pointers, function(pointer, pointerId) {
    delete pointers2[pointerId];
    forEach(pointers2, function(pointer2) {
      var x1 = Math.abs(pointer.startX - pointer2.startX);
      var y1 = Math.abs(pointer.startY - pointer2.startY);
      var x2 = Math.abs(pointer.endX - pointer2.endX);
      var y2 = Math.abs(pointer.endY - pointer2.endY);
      var z1 = Math.sqrt(x1 * x1 + y1 * y1);
      var z2 = Math.sqrt(x2 * x2 + y2 * y2);
      var ratio = (z2 - z1) / z1;
      ratios.push(ratio);
    });
  });
  ratios.sort(function(a2, b2) {
    return Math.abs(a2) < Math.abs(b2);
  });
  return ratios[0];
}
function getPointer(_ref2, endOnly) {
  var pageX = _ref2.pageX, pageY = _ref2.pageY;
  var end = {
    endX: pageX,
    endY: pageY
  };
  return endOnly ? end : _objectSpread2({
    timeStamp: Date.now(),
    startX: pageX,
    startY: pageY
  }, end);
}
function getPointersCenter(pointers) {
  var pageX = 0;
  var pageY = 0;
  var count2 = 0;
  forEach(pointers, function(_ref3) {
    var startX = _ref3.startX, startY = _ref3.startY;
    pageX += startX;
    pageY += startY;
    count2 += 1;
  });
  pageX /= count2;
  pageY /= count2;
  return {
    pageX,
    pageY
  };
}
var render = {
  render: function render2() {
    this.initContainer();
    this.initViewer();
    this.initList();
    this.renderViewer();
  },
  initBody: function initBody() {
    var ownerDocument = this.element.ownerDocument;
    var body = ownerDocument.body || ownerDocument.documentElement;
    this.body = body;
    this.scrollbarWidth = window.innerWidth - ownerDocument.documentElement.clientWidth;
    this.initialBodyPaddingRight = body.style.paddingRight;
    this.initialBodyComputedPaddingRight = window.getComputedStyle(body).paddingRight;
  },
  initContainer: function initContainer() {
    this.containerData = {
      width: window.innerWidth,
      height: window.innerHeight
    };
  },
  initViewer: function initViewer() {
    var options = this.options, parent2 = this.parent;
    var viewerData;
    if (options.inline) {
      viewerData = {
        width: Math.max(parent2.offsetWidth, options.minWidth),
        height: Math.max(parent2.offsetHeight, options.minHeight)
      };
      this.parentData = viewerData;
    }
    if (this.fulled || !viewerData) {
      viewerData = this.containerData;
    }
    this.viewerData = assign({}, viewerData);
  },
  renderViewer: function renderViewer() {
    if (this.options.inline && !this.fulled) {
      setStyle(this.viewer, this.viewerData);
    }
  },
  initList: function initList() {
    var _this = this;
    var element = this.element, options = this.options, list = this.list;
    var items = [];
    list.innerHTML = "";
    forEach(this.images, function(image, index2) {
      var src = image.src;
      var alt = image.alt || getImageNameFromURL(src);
      var url = _this.getImageURL(image);
      if (src || url) {
        var item = document.createElement("li");
        var img = document.createElement("img");
        forEach(options.inheritedAttributes, function(name) {
          var value = image.getAttribute(name);
          if (value !== null) {
            img.setAttribute(name, value);
          }
        });
        img.src = src || url;
        img.alt = alt;
        img.setAttribute("data-original-url", url || src);
        item.setAttribute("data-index", index2);
        item.setAttribute("data-viewer-action", "view");
        item.setAttribute("role", "button");
        if (options.keyboard) {
          item.setAttribute("tabindex", 0);
        }
        item.appendChild(img);
        list.appendChild(item);
        items.push(item);
      }
    });
    this.items = items;
    forEach(items, function(item) {
      var image = item.firstElementChild;
      var onLoad;
      var onError;
      setData(image, "filled", true);
      if (options.loading) {
        addClass(item, CLASS_LOADING);
      }
      addListener(image, EVENT_LOAD, onLoad = function onLoad2(event) {
        removeListener(image, EVENT_ERROR, onError);
        if (options.loading) {
          removeClass(item, CLASS_LOADING);
        }
        _this.loadImage(event);
      }, {
        once: true
      });
      addListener(image, EVENT_ERROR, onError = function onError2() {
        removeListener(image, EVENT_LOAD, onLoad);
        if (options.loading) {
          removeClass(item, CLASS_LOADING);
        }
      }, {
        once: true
      });
    });
    if (options.transition) {
      addListener(element, EVENT_VIEWED, function() {
        addClass(list, CLASS_TRANSITION);
      }, {
        once: true
      });
    }
  },
  renderList: function renderList() {
    var index2 = this.index;
    var item = this.items[index2];
    if (!item) {
      return;
    }
    var next3 = item.nextElementSibling;
    var gutter = parseInt(window.getComputedStyle(next3 || item).marginLeft, 10);
    var offsetWidth = item.offsetWidth;
    var outerWidth2 = offsetWidth + gutter;
    setStyle(this.list, assign({
      width: outerWidth2 * this.length - gutter
    }, getTransforms({
      translateX: (this.viewerData.width - offsetWidth) / 2 - outerWidth2 * index2
    })));
  },
  resetList: function resetList() {
    var list = this.list;
    list.innerHTML = "";
    removeClass(list, CLASS_TRANSITION);
    setStyle(list, getTransforms({
      translateX: 0
    }));
  },
  initImage: function initImage(done) {
    var _this2 = this;
    var options = this.options, image = this.image, viewerData = this.viewerData;
    var footerHeight = this.footer.offsetHeight;
    var viewerWidth = viewerData.width;
    var viewerHeight = Math.max(viewerData.height - footerHeight, footerHeight);
    var oldImageData = this.imageData || {};
    var sizingImage;
    this.imageInitializing = {
      abort: function abort() {
        sizingImage.onload = null;
      }
    };
    sizingImage = getImageNaturalSizes(image, options, function(naturalWidth, naturalHeight) {
      var aspectRatio = naturalWidth / naturalHeight;
      var width = viewerWidth;
      var height = viewerHeight;
      _this2.imageInitializing = false;
      if (viewerHeight * aspectRatio > viewerWidth) {
        height = viewerWidth / aspectRatio;
      } else {
        width = viewerHeight * aspectRatio;
      }
      width = Math.min(width * 0.9, naturalWidth);
      height = Math.min(height * 0.9, naturalHeight);
      var left = (viewerWidth - width) / 2;
      var top = (viewerHeight - height) / 2;
      var imageData = {
        left,
        top,
        x: left,
        y: top,
        width,
        height,
        oldRatio: 1,
        ratio: width / naturalWidth,
        aspectRatio,
        naturalWidth,
        naturalHeight
      };
      var initialImageData = assign({}, imageData);
      if (options.rotatable) {
        imageData.rotate = oldImageData.rotate || 0;
        initialImageData.rotate = 0;
      }
      if (options.scalable) {
        imageData.scaleX = oldImageData.scaleX || 1;
        imageData.scaleY = oldImageData.scaleY || 1;
        initialImageData.scaleX = 1;
        initialImageData.scaleY = 1;
      }
      _this2.imageData = imageData;
      _this2.initialImageData = initialImageData;
      if (done) {
        done();
      }
    });
  },
  renderImage: function renderImage(done) {
    var _this3 = this;
    var image = this.image, imageData = this.imageData;
    setStyle(image, assign({
      width: imageData.width,
      height: imageData.height,
      marginLeft: imageData.x,
      marginTop: imageData.y
    }, getTransforms(imageData)));
    if (done) {
      if ((this.viewing || this.moving || this.rotating || this.scaling || this.zooming) && this.options.transition && hasClass(image, CLASS_TRANSITION)) {
        var onTransitionEnd = function onTransitionEnd2() {
          _this3.imageRendering = false;
          done();
        };
        this.imageRendering = {
          abort: function abort() {
            removeListener(image, EVENT_TRANSITION_END, onTransitionEnd);
          }
        };
        addListener(image, EVENT_TRANSITION_END, onTransitionEnd, {
          once: true
        });
      } else {
        done();
      }
    }
  },
  resetImage: function resetImage() {
    if (this.viewing || this.viewed) {
      var image = this.image;
      if (this.viewing) {
        this.viewing.abort();
      }
      image.parentNode.removeChild(image);
      this.image = null;
    }
  }
};
var events = {
  bind: function bind() {
    var options = this.options, viewer = this.viewer, canvas = this.canvas;
    var document2 = this.element.ownerDocument;
    addListener(viewer, EVENT_CLICK, this.onClick = this.click.bind(this));
    addListener(viewer, EVENT_DRAG_START, this.onDragStart = this.dragstart.bind(this));
    addListener(canvas, EVENT_POINTER_DOWN, this.onPointerDown = this.pointerdown.bind(this));
    addListener(document2, EVENT_POINTER_MOVE, this.onPointerMove = this.pointermove.bind(this));
    addListener(document2, EVENT_POINTER_UP, this.onPointerUp = this.pointerup.bind(this));
    addListener(document2, EVENT_KEY_DOWN, this.onKeyDown = this.keydown.bind(this));
    addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));
    if (options.zoomable && options.zoomOnWheel) {
      addListener(viewer, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {
        passive: false,
        capture: true
      });
    }
    if (options.toggleOnDblclick) {
      addListener(canvas, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));
    }
  },
  unbind: function unbind() {
    var options = this.options, viewer = this.viewer, canvas = this.canvas;
    var document2 = this.element.ownerDocument;
    removeListener(viewer, EVENT_CLICK, this.onClick);
    removeListener(viewer, EVENT_DRAG_START, this.onDragStart);
    removeListener(canvas, EVENT_POINTER_DOWN, this.onPointerDown);
    removeListener(document2, EVENT_POINTER_MOVE, this.onPointerMove);
    removeListener(document2, EVENT_POINTER_UP, this.onPointerUp);
    removeListener(document2, EVENT_KEY_DOWN, this.onKeyDown);
    removeListener(window, EVENT_RESIZE, this.onResize);
    if (options.zoomable && options.zoomOnWheel) {
      removeListener(viewer, EVENT_WHEEL, this.onWheel, {
        passive: false,
        capture: true
      });
    }
    if (options.toggleOnDblclick) {
      removeListener(canvas, EVENT_DBLCLICK, this.onDblclick);
    }
  }
};
var handlers = {
  click: function click(event) {
    var options = this.options, imageData = this.imageData;
    var target = event.target;
    var action = getData(target, DATA_ACTION);
    if (!action && target.localName === "img" && target.parentElement.localName === "li") {
      target = target.parentElement;
      action = getData(target, DATA_ACTION);
    }
    if (IS_TOUCH_DEVICE && event.isTrusted && target === this.canvas) {
      clearTimeout(this.clickCanvasTimeout);
    }
    switch (action) {
      case "mix":
        if (this.played) {
          this.stop();
        } else if (options.inline) {
          if (this.fulled) {
            this.exit();
          } else {
            this.full();
          }
        } else {
          this.hide();
        }
        break;
      case "hide":
        this.hide();
        break;
      case "view":
        this.view(getData(target, "index"));
        break;
      case "zoom-in":
        this.zoom(0.1, true);
        break;
      case "zoom-out":
        this.zoom(-0.1, true);
        break;
      case "one-to-one":
        this.toggle();
        break;
      case "reset":
        this.reset();
        break;
      case "prev":
        this.prev(options.loop);
        break;
      case "play":
        this.play(options.fullscreen);
        break;
      case "next":
        this.next(options.loop);
        break;
      case "rotate-left":
        this.rotate(-90);
        break;
      case "rotate-right":
        this.rotate(90);
        break;
      case "flip-horizontal":
        this.scaleX(-imageData.scaleX || -1);
        break;
      case "flip-vertical":
        this.scaleY(-imageData.scaleY || -1);
        break;
      default:
        if (this.played) {
          this.stop();
        }
    }
  },
  dblclick: function dblclick(event) {
    event.preventDefault();
    if (this.viewed && event.target === this.image) {
      if (IS_TOUCH_DEVICE && event.isTrusted) {
        clearTimeout(this.doubleClickImageTimeout);
      }
      this.toggle(event.isTrusted ? event : event.detail && event.detail.originalEvent);
    }
  },
  load: function load() {
    var _this = this;
    if (this.timeout) {
      clearTimeout(this.timeout);
      this.timeout = false;
    }
    var element = this.element, options = this.options, image = this.image, index2 = this.index, viewerData = this.viewerData;
    removeClass(image, CLASS_INVISIBLE);
    if (options.loading) {
      removeClass(this.canvas, CLASS_LOADING);
    }
    image.style.cssText = "height:0;" + "margin-left:".concat(viewerData.width / 2, "px;") + "margin-top:".concat(viewerData.height / 2, "px;") + "max-width:none!important;position:relative;width:0;";
    this.initImage(function() {
      toggleClass(image, CLASS_MOVE, options.movable);
      toggleClass(image, CLASS_TRANSITION, options.transition);
      _this.renderImage(function() {
        _this.viewed = true;
        _this.viewing = false;
        if (isFunction(options.viewed)) {
          addListener(element, EVENT_VIEWED, options.viewed, {
            once: true
          });
        }
        dispatchEvent(element, EVENT_VIEWED, {
          originalImage: _this.images[index2],
          index: index2,
          image
        }, {
          cancelable: false
        });
      });
    });
  },
  loadImage: function loadImage2(event) {
    var image = event.target;
    var parent2 = image.parentNode;
    var parentWidth = parent2.offsetWidth || 30;
    var parentHeight = parent2.offsetHeight || 50;
    var filled = !!getData(image, "filled");
    getImageNaturalSizes(image, this.options, function(naturalWidth, naturalHeight) {
      var aspectRatio = naturalWidth / naturalHeight;
      var width = parentWidth;
      var height = parentHeight;
      if (parentHeight * aspectRatio > parentWidth) {
        if (filled) {
          width = parentHeight * aspectRatio;
        } else {
          height = parentWidth / aspectRatio;
        }
      } else if (filled) {
        height = parentWidth / aspectRatio;
      } else {
        width = parentHeight * aspectRatio;
      }
      setStyle(image, assign({
        width,
        height
      }, getTransforms({
        translateX: (parentWidth - width) / 2,
        translateY: (parentHeight - height) / 2
      })));
    });
  },
  keydown: function keydown(event) {
    var options = this.options;
    if (!options.keyboard) {
      return;
    }
    var keyCode = event.keyCode || event.which || event.charCode;
    switch (keyCode) {
      case 13:
        if (this.viewer.contains(event.target)) {
          this.click(event);
        }
        break;
    }
    if (!this.fulled) {
      return;
    }
    switch (keyCode) {
      case 27:
        if (this.played) {
          this.stop();
        } else if (options.inline) {
          if (this.fulled) {
            this.exit();
          }
        } else {
          this.hide();
        }
        break;
      case 32:
        if (this.played) {
          this.stop();
        }
        break;
      case 37:
        this.prev(options.loop);
        break;
      case 38:
        event.preventDefault();
        this.zoom(options.zoomRatio, true);
        break;
      case 39:
        this.next(options.loop);
        break;
      case 40:
        event.preventDefault();
        this.zoom(-options.zoomRatio, true);
        break;
      case 48:
      case 49:
        if (event.ctrlKey) {
          event.preventDefault();
          this.toggle();
        }
        break;
    }
  },
  dragstart: function dragstart(event) {
    if (event.target.localName === "img") {
      event.preventDefault();
    }
  },
  pointerdown: function pointerdown(event) {
    var options = this.options, pointers = this.pointers;
    var buttons = event.buttons, button = event.button;
    if (!this.viewed || this.showing || this.viewing || this.hiding || (event.type === "mousedown" || event.type === "pointerdown" && event.pointerType === "mouse") && (isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0 || event.ctrlKey)) {
      return;
    }
    event.preventDefault();
    if (event.changedTouches) {
      forEach(event.changedTouches, function(touch) {
        pointers[touch.identifier] = getPointer(touch);
      });
    } else {
      pointers[event.pointerId || 0] = getPointer(event);
    }
    var action = options.movable ? ACTION_MOVE : false;
    if (options.zoomOnTouch && options.zoomable && Object.keys(pointers).length > 1) {
      action = ACTION_ZOOM;
    } else if (options.slideOnTouch && (event.pointerType === "touch" || event.type === "touchstart") && this.isSwitchable()) {
      action = ACTION_SWITCH;
    }
    if (options.transition && (action === ACTION_MOVE || action === ACTION_ZOOM)) {
      removeClass(this.image, CLASS_TRANSITION);
    }
    this.action = action;
  },
  pointermove: function pointermove(event) {
    var pointers = this.pointers, action = this.action;
    if (!this.viewed || !action) {
      return;
    }
    event.preventDefault();
    if (event.changedTouches) {
      forEach(event.changedTouches, function(touch) {
        assign(pointers[touch.identifier] || {}, getPointer(touch, true));
      });
    } else {
      assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));
    }
    this.change(event);
  },
  pointerup: function pointerup(event) {
    var _this2 = this;
    var options = this.options, action = this.action, pointers = this.pointers;
    var pointer;
    if (event.changedTouches) {
      forEach(event.changedTouches, function(touch) {
        pointer = pointers[touch.identifier];
        delete pointers[touch.identifier];
      });
    } else {
      pointer = pointers[event.pointerId || 0];
      delete pointers[event.pointerId || 0];
    }
    if (!action) {
      return;
    }
    event.preventDefault();
    if (options.transition && (action === ACTION_MOVE || action === ACTION_ZOOM)) {
      addClass(this.image, CLASS_TRANSITION);
    }
    this.action = false;
    if (IS_TOUCH_DEVICE && action !== ACTION_ZOOM && pointer && Date.now() - pointer.timeStamp < 500) {
      clearTimeout(this.clickCanvasTimeout);
      clearTimeout(this.doubleClickImageTimeout);
      if (options.toggleOnDblclick && this.viewed && event.target === this.image) {
        if (this.imageClicked) {
          this.imageClicked = false;
          this.doubleClickImageTimeout = setTimeout(function() {
            dispatchEvent(_this2.image, EVENT_DBLCLICK, {
              originalEvent: event
            });
          }, 50);
        } else {
          this.imageClicked = true;
          this.doubleClickImageTimeout = setTimeout(function() {
            _this2.imageClicked = false;
          }, 500);
        }
      } else {
        this.imageClicked = false;
        if (options.backdrop && options.backdrop !== "static" && event.target === this.canvas) {
          this.clickCanvasTimeout = setTimeout(function() {
            dispatchEvent(_this2.canvas, EVENT_CLICK, {
              originalEvent: event
            });
          }, 50);
        }
      }
    }
  },
  resize: function resize() {
    var _this3 = this;
    if (!this.isShown || this.hiding) {
      return;
    }
    if (this.fulled) {
      this.close();
      this.initBody();
      this.open();
    }
    this.initContainer();
    this.initViewer();
    this.renderViewer();
    this.renderList();
    if (this.viewed) {
      this.initImage(function() {
        _this3.renderImage();
      });
    }
    if (this.played) {
      if (this.options.fullscreen && this.fulled && !(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
        this.stop();
        return;
      }
      forEach(this.player.getElementsByTagName("img"), function(image) {
        addListener(image, EVENT_LOAD, _this3.loadImage.bind(_this3), {
          once: true
        });
        dispatchEvent(image, EVENT_LOAD);
      });
    }
  },
  wheel: function wheel(event) {
    var _this4 = this;
    if (!this.viewed) {
      return;
    }
    event.preventDefault();
    if (this.wheeling) {
      return;
    }
    this.wheeling = true;
    setTimeout(function() {
      _this4.wheeling = false;
    }, 50);
    var ratio = Number(this.options.zoomRatio) || 0.1;
    var delta = 1;
    if (event.deltaY) {
      delta = event.deltaY > 0 ? 1 : -1;
    } else if (event.wheelDelta) {
      delta = -event.wheelDelta / 120;
    } else if (event.detail) {
      delta = event.detail > 0 ? 1 : -1;
    }
    this.zoom(-delta * ratio, true, event);
  }
};
var methods = {
  show: function show() {
    var immediate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var element = this.element, options = this.options;
    if (options.inline || this.showing || this.isShown || this.showing) {
      return this;
    }
    if (!this.ready) {
      this.build();
      if (this.ready) {
        this.show(immediate);
      }
      return this;
    }
    if (isFunction(options.show)) {
      addListener(element, EVENT_SHOW, options.show, {
        once: true
      });
    }
    if (dispatchEvent(element, EVENT_SHOW) === false || !this.ready) {
      return this;
    }
    if (this.hiding) {
      this.transitioning.abort();
    }
    this.showing = true;
    this.open();
    var viewer = this.viewer;
    removeClass(viewer, CLASS_HIDE);
    viewer.setAttribute("role", "dialog");
    viewer.setAttribute("aria-labelledby", this.title.id);
    viewer.setAttribute("aria-modal", true);
    viewer.removeAttribute("aria-hidden");
    if (options.transition && !immediate) {
      var shown2 = this.shown.bind(this);
      this.transitioning = {
        abort: function abort() {
          removeListener(viewer, EVENT_TRANSITION_END, shown2);
          removeClass(viewer, CLASS_IN);
        }
      };
      addClass(viewer, CLASS_TRANSITION);
      viewer.initialOffsetWidth = viewer.offsetWidth;
      addListener(viewer, EVENT_TRANSITION_END, shown2, {
        once: true
      });
      addClass(viewer, CLASS_IN);
    } else {
      addClass(viewer, CLASS_IN);
      this.shown();
    }
    return this;
  },
  hide: function hide() {
    var _this = this;
    var immediate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var element = this.element, options = this.options;
    if (options.inline || this.hiding || !(this.isShown || this.showing)) {
      return this;
    }
    if (isFunction(options.hide)) {
      addListener(element, EVENT_HIDE, options.hide, {
        once: true
      });
    }
    if (dispatchEvent(element, EVENT_HIDE) === false) {
      return this;
    }
    if (this.showing) {
      this.transitioning.abort();
    }
    this.hiding = true;
    if (this.played) {
      this.stop();
    } else if (this.viewing) {
      this.viewing.abort();
    }
    var viewer = this.viewer, image = this.image;
    var hideImmediately = function hideImmediately2() {
      removeClass(viewer, CLASS_IN);
      _this.hidden();
    };
    if (options.transition && !immediate) {
      var onViewerTransitionEnd = function onViewerTransitionEnd2(event) {
        if (event && event.target === viewer) {
          removeListener(viewer, EVENT_TRANSITION_END, onViewerTransitionEnd2);
          _this.hidden();
        }
      };
      var onImageTransitionEnd = function onImageTransitionEnd2() {
        if (hasClass(viewer, CLASS_TRANSITION)) {
          addListener(viewer, EVENT_TRANSITION_END, onViewerTransitionEnd);
          removeClass(viewer, CLASS_IN);
        } else {
          hideImmediately();
        }
      };
      this.transitioning = {
        abort: function abort() {
          if (_this.viewed && hasClass(image, CLASS_TRANSITION)) {
            removeListener(image, EVENT_TRANSITION_END, onImageTransitionEnd);
          } else if (hasClass(viewer, CLASS_TRANSITION)) {
            removeListener(viewer, EVENT_TRANSITION_END, onViewerTransitionEnd);
          }
        }
      };
      if (this.viewed && hasClass(image, CLASS_TRANSITION)) {
        addListener(image, EVENT_TRANSITION_END, onImageTransitionEnd, {
          once: true
        });
        this.zoomTo(0, false, null, true);
      } else {
        onImageTransitionEnd();
      }
    } else {
      hideImmediately();
    }
    return this;
  },
  view: function view() {
    var _this2 = this;
    var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.initialViewIndex;
    index2 = Number(index2) || 0;
    if (this.hiding || this.played || index2 < 0 || index2 >= this.length || this.viewed && index2 === this.index) {
      return this;
    }
    if (!this.isShown) {
      this.index = index2;
      return this.show();
    }
    if (this.viewing) {
      this.viewing.abort();
    }
    var element = this.element, options = this.options, title = this.title, canvas = this.canvas;
    var item = this.items[index2];
    var img = item.querySelector("img");
    var url = getData(img, "originalUrl");
    var alt = img.getAttribute("alt");
    var image = document.createElement("img");
    forEach(options.inheritedAttributes, function(name) {
      var value = img.getAttribute(name);
      if (value !== null) {
        image.setAttribute(name, value);
      }
    });
    image.src = url;
    image.alt = alt;
    if (isFunction(options.view)) {
      addListener(element, EVENT_VIEW, options.view, {
        once: true
      });
    }
    if (dispatchEvent(element, EVENT_VIEW, {
      originalImage: this.images[index2],
      index: index2,
      image
    }) === false || !this.isShown || this.hiding || this.played) {
      return this;
    }
    var activeItem = this.items[this.index];
    if (activeItem) {
      removeClass(activeItem, CLASS_ACTIVE);
      activeItem.removeAttribute("aria-selected");
    }
    addClass(item, CLASS_ACTIVE);
    item.setAttribute("aria-selected", true);
    if (options.focus) {
      item.focus();
    }
    this.image = image;
    this.viewed = false;
    this.index = index2;
    this.imageData = {};
    addClass(image, CLASS_INVISIBLE);
    if (options.loading) {
      addClass(canvas, CLASS_LOADING);
    }
    canvas.innerHTML = "";
    canvas.appendChild(image);
    this.renderList();
    title.innerHTML = "";
    var onViewed = function onViewed2() {
      var imageData = _this2.imageData;
      var render3 = Array.isArray(options.title) ? options.title[1] : options.title;
      title.innerHTML = escapeHTMLEntities(isFunction(render3) ? render3.call(_this2, image, imageData) : "".concat(alt, " (").concat(imageData.naturalWidth, " \xD7 ").concat(imageData.naturalHeight, ")"));
    };
    var onLoad;
    var onError;
    addListener(element, EVENT_VIEWED, onViewed, {
      once: true
    });
    this.viewing = {
      abort: function abort() {
        removeListener(element, EVENT_VIEWED, onViewed);
        if (image.complete) {
          if (_this2.imageRendering) {
            _this2.imageRendering.abort();
          } else if (_this2.imageInitializing) {
            _this2.imageInitializing.abort();
          }
        } else {
          image.src = "";
          removeListener(image, EVENT_LOAD, onLoad);
          if (_this2.timeout) {
            clearTimeout(_this2.timeout);
          }
        }
      }
    };
    if (image.complete) {
      this.load();
    } else {
      addListener(image, EVENT_LOAD, onLoad = function onLoad2() {
        removeListener(image, EVENT_ERROR, onError);
        _this2.load();
      }, {
        once: true
      });
      addListener(image, EVENT_ERROR, onError = function onError2() {
        removeListener(image, EVENT_LOAD, onLoad);
        if (_this2.timeout) {
          clearTimeout(_this2.timeout);
          _this2.timeout = false;
        }
        removeClass(image, CLASS_INVISIBLE);
        if (options.loading) {
          removeClass(_this2.canvas, CLASS_LOADING);
        }
      }, {
        once: true
      });
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
      this.timeout = setTimeout(function() {
        removeClass(image, CLASS_INVISIBLE);
        _this2.timeout = false;
      }, 1e3);
    }
    return this;
  },
  prev: function prev2() {
    var loop2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var index2 = this.index - 1;
    if (index2 < 0) {
      index2 = loop2 ? this.length - 1 : 0;
    }
    this.view(index2);
    return this;
  },
  next: function next2() {
    var loop2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var maxIndex = this.length - 1;
    var index2 = this.index + 1;
    if (index2 > maxIndex) {
      index2 = loop2 ? 0 : maxIndex;
    }
    this.view(index2);
    return this;
  },
  move: function move(x2) {
    var y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : x2;
    var imageData = this.imageData;
    this.moveTo(isUndefined(x2) ? x2 : imageData.x + Number(x2), isUndefined(y) ? y : imageData.y + Number(y));
    return this;
  },
  moveTo: function moveTo(x2) {
    var _this3 = this;
    var y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : x2;
    var _originalEvent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    var element = this.element, options = this.options, imageData = this.imageData;
    x2 = Number(x2);
    y = Number(y);
    if (this.viewed && !this.played && options.movable) {
      var oldX = imageData.x;
      var oldY = imageData.y;
      var changed = false;
      if (isNumber(x2)) {
        changed = true;
      } else {
        x2 = oldX;
      }
      if (isNumber(y)) {
        changed = true;
      } else {
        y = oldY;
      }
      if (changed) {
        if (isFunction(options.move)) {
          addListener(element, EVENT_MOVE, options.move, {
            once: true
          });
        }
        if (dispatchEvent(element, EVENT_MOVE, {
          x: x2,
          y,
          oldX,
          oldY,
          originalEvent: _originalEvent
        }) === false) {
          return this;
        }
        imageData.x = x2;
        imageData.y = y;
        imageData.left = x2;
        imageData.top = y;
        this.moving = true;
        this.renderImage(function() {
          _this3.moving = false;
          if (isFunction(options.moved)) {
            addListener(element, EVENT_MOVED, options.moved, {
              once: true
            });
          }
          dispatchEvent(element, EVENT_MOVED, {
            x: x2,
            y,
            oldX,
            oldY,
            originalEvent: _originalEvent
          }, {
            cancelable: false
          });
        });
      }
    }
    return this;
  },
  rotate: function rotate(degree) {
    this.rotateTo((this.imageData.rotate || 0) + Number(degree));
    return this;
  },
  rotateTo: function rotateTo(degree) {
    var _this4 = this;
    var element = this.element, options = this.options, imageData = this.imageData;
    degree = Number(degree);
    if (isNumber(degree) && this.viewed && !this.played && options.rotatable) {
      var oldDegree = imageData.rotate;
      if (isFunction(options.rotate)) {
        addListener(element, EVENT_ROTATE, options.rotate, {
          once: true
        });
      }
      if (dispatchEvent(element, EVENT_ROTATE, {
        degree,
        oldDegree
      }) === false) {
        return this;
      }
      imageData.rotate = degree;
      this.rotating = true;
      this.renderImage(function() {
        _this4.rotating = false;
        if (isFunction(options.rotated)) {
          addListener(element, EVENT_ROTATED, options.rotated, {
            once: true
          });
        }
        dispatchEvent(element, EVENT_ROTATED, {
          degree,
          oldDegree
        }, {
          cancelable: false
        });
      });
    }
    return this;
  },
  scaleX: function scaleX(_scaleX) {
    this.scale(_scaleX, this.imageData.scaleY);
    return this;
  },
  scaleY: function scaleY(_scaleY) {
    this.scale(this.imageData.scaleX, _scaleY);
    return this;
  },
  scale: function scale(scaleX2) {
    var _this5 = this;
    var scaleY2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : scaleX2;
    var element = this.element, options = this.options, imageData = this.imageData;
    scaleX2 = Number(scaleX2);
    scaleY2 = Number(scaleY2);
    if (this.viewed && !this.played && options.scalable) {
      var oldScaleX = imageData.scaleX;
      var oldScaleY = imageData.scaleY;
      var changed = false;
      if (isNumber(scaleX2)) {
        changed = true;
      } else {
        scaleX2 = oldScaleX;
      }
      if (isNumber(scaleY2)) {
        changed = true;
      } else {
        scaleY2 = oldScaleY;
      }
      if (changed) {
        if (isFunction(options.scale)) {
          addListener(element, EVENT_SCALE, options.scale, {
            once: true
          });
        }
        if (dispatchEvent(element, EVENT_SCALE, {
          scaleX: scaleX2,
          scaleY: scaleY2,
          oldScaleX,
          oldScaleY
        }) === false) {
          return this;
        }
        imageData.scaleX = scaleX2;
        imageData.scaleY = scaleY2;
        this.scaling = true;
        this.renderImage(function() {
          _this5.scaling = false;
          if (isFunction(options.scaled)) {
            addListener(element, EVENT_SCALED, options.scaled, {
              once: true
            });
          }
          dispatchEvent(element, EVENT_SCALED, {
            scaleX: scaleX2,
            scaleY: scaleY2,
            oldScaleX,
            oldScaleY
          }, {
            cancelable: false
          });
        });
      }
    }
    return this;
  },
  zoom: function zoom(ratio) {
    var hasTooltip = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var _originalEvent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    var imageData = this.imageData;
    ratio = Number(ratio);
    if (ratio < 0) {
      ratio = 1 / (1 - ratio);
    } else {
      ratio = 1 + ratio;
    }
    this.zoomTo(imageData.width * ratio / imageData.naturalWidth, hasTooltip, _originalEvent);
    return this;
  },
  zoomTo: function zoomTo(ratio) {
    var _this6 = this;
    var hasTooltip = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var _originalEvent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    var _zoomable = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    var element = this.element, options = this.options, pointers = this.pointers, imageData = this.imageData;
    var x2 = imageData.x, y = imageData.y, width = imageData.width, height = imageData.height, naturalWidth = imageData.naturalWidth, naturalHeight = imageData.naturalHeight;
    ratio = Math.max(0, ratio);
    if (isNumber(ratio) && this.viewed && !this.played && (_zoomable || options.zoomable)) {
      if (!_zoomable) {
        var minZoomRatio = Math.max(0.01, options.minZoomRatio);
        var maxZoomRatio = Math.min(100, options.maxZoomRatio);
        ratio = Math.min(Math.max(ratio, minZoomRatio), maxZoomRatio);
      }
      if (_originalEvent) {
        switch (_originalEvent.type) {
          case "wheel":
            if (options.zoomRatio >= 0.055 && ratio > 0.95 && ratio < 1.05) {
              ratio = 1;
            }
            break;
          case "pointermove":
          case "touchmove":
          case "mousemove":
            if (ratio > 0.99 && ratio < 1.01) {
              ratio = 1;
            }
            break;
        }
      }
      var newWidth = naturalWidth * ratio;
      var newHeight = naturalHeight * ratio;
      var offsetWidth = newWidth - width;
      var offsetHeight = newHeight - height;
      var oldRatio = imageData.ratio;
      if (isFunction(options.zoom)) {
        addListener(element, EVENT_ZOOM, options.zoom, {
          once: true
        });
      }
      if (dispatchEvent(element, EVENT_ZOOM, {
        ratio,
        oldRatio,
        originalEvent: _originalEvent
      }) === false) {
        return this;
      }
      this.zooming = true;
      if (_originalEvent) {
        var offset2 = getOffset(this.viewer);
        var center = pointers && Object.keys(pointers).length > 0 ? getPointersCenter(pointers) : {
          pageX: _originalEvent.pageX,
          pageY: _originalEvent.pageY
        };
        imageData.x -= offsetWidth * ((center.pageX - offset2.left - x2) / width);
        imageData.y -= offsetHeight * ((center.pageY - offset2.top - y) / height);
      } else {
        imageData.x -= offsetWidth / 2;
        imageData.y -= offsetHeight / 2;
      }
      imageData.left = imageData.x;
      imageData.top = imageData.y;
      imageData.width = newWidth;
      imageData.height = newHeight;
      imageData.oldRatio = oldRatio;
      imageData.ratio = ratio;
      this.renderImage(function() {
        _this6.zooming = false;
        if (isFunction(options.zoomed)) {
          addListener(element, EVENT_ZOOMED, options.zoomed, {
            once: true
          });
        }
        dispatchEvent(element, EVENT_ZOOMED, {
          ratio,
          oldRatio,
          originalEvent: _originalEvent
        }, {
          cancelable: false
        });
      });
      if (hasTooltip) {
        this.tooltip();
      }
    }
    return this;
  },
  play: function play() {
    var _this7 = this;
    var fullscreen = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (!this.isShown || this.played) {
      return this;
    }
    var element = this.element, options = this.options;
    if (isFunction(options.play)) {
      addListener(element, EVENT_PLAY, options.play, {
        once: true
      });
    }
    if (dispatchEvent(element, EVENT_PLAY) === false) {
      return this;
    }
    var player = this.player;
    var onLoad = this.loadImage.bind(this);
    var list = [];
    var total = 0;
    var index2 = 0;
    this.played = true;
    this.onLoadWhenPlay = onLoad;
    if (fullscreen) {
      this.requestFullscreen(fullscreen);
    }
    addClass(player, CLASS_SHOW);
    forEach(this.items, function(item, i2) {
      var img = item.querySelector("img");
      var image = document.createElement("img");
      image.src = getData(img, "originalUrl");
      image.alt = img.getAttribute("alt");
      image.referrerPolicy = img.referrerPolicy;
      total += 1;
      addClass(image, CLASS_FADE);
      toggleClass(image, CLASS_TRANSITION, options.transition);
      if (hasClass(item, CLASS_ACTIVE)) {
        addClass(image, CLASS_IN);
        index2 = i2;
      }
      list.push(image);
      addListener(image, EVENT_LOAD, onLoad, {
        once: true
      });
      player.appendChild(image);
    });
    if (isNumber(options.interval) && options.interval > 0) {
      var play2 = function play3() {
        _this7.playing = setTimeout(function() {
          removeClass(list[index2], CLASS_IN);
          index2 += 1;
          index2 = index2 < total ? index2 : 0;
          addClass(list[index2], CLASS_IN);
          play3();
        }, options.interval);
      };
      if (total > 1) {
        play2();
      }
    }
    return this;
  },
  stop: function stop() {
    var _this8 = this;
    if (!this.played) {
      return this;
    }
    var element = this.element, options = this.options;
    if (isFunction(options.stop)) {
      addListener(element, EVENT_STOP, options.stop, {
        once: true
      });
    }
    if (dispatchEvent(element, EVENT_STOP) === false) {
      return this;
    }
    var player = this.player;
    this.played = false;
    clearTimeout(this.playing);
    forEach(player.getElementsByTagName("img"), function(image) {
      removeListener(image, EVENT_LOAD, _this8.onLoadWhenPlay);
    });
    removeClass(player, CLASS_SHOW);
    player.innerHTML = "";
    this.exitFullscreen();
    return this;
  },
  full: function full() {
    var _this9 = this;
    var options = this.options, viewer = this.viewer, image = this.image, list = this.list;
    if (!this.isShown || this.played || this.fulled || !options.inline) {
      return this;
    }
    this.fulled = true;
    this.open();
    addClass(this.button, CLASS_FULLSCREEN_EXIT);
    if (options.transition) {
      removeClass(list, CLASS_TRANSITION);
      if (this.viewed) {
        removeClass(image, CLASS_TRANSITION);
      }
    }
    addClass(viewer, CLASS_FIXED);
    viewer.setAttribute("role", "dialog");
    viewer.setAttribute("aria-labelledby", this.title.id);
    viewer.setAttribute("aria-modal", true);
    viewer.removeAttribute("style");
    setStyle(viewer, {
      zIndex: options.zIndex
    });
    if (options.focus) {
      this.enforceFocus();
    }
    this.initContainer();
    this.viewerData = assign({}, this.containerData);
    this.renderList();
    if (this.viewed) {
      this.initImage(function() {
        _this9.renderImage(function() {
          if (options.transition) {
            setTimeout(function() {
              addClass(image, CLASS_TRANSITION);
              addClass(list, CLASS_TRANSITION);
            }, 0);
          }
        });
      });
    }
    return this;
  },
  exit: function exit() {
    var _this10 = this;
    var options = this.options, viewer = this.viewer, image = this.image, list = this.list;
    if (!this.isShown || this.played || !this.fulled || !options.inline) {
      return this;
    }
    this.fulled = false;
    this.close();
    removeClass(this.button, CLASS_FULLSCREEN_EXIT);
    if (options.transition) {
      removeClass(list, CLASS_TRANSITION);
      if (this.viewed) {
        removeClass(image, CLASS_TRANSITION);
      }
    }
    if (options.focus) {
      this.clearEnforceFocus();
    }
    viewer.removeAttribute("role");
    viewer.removeAttribute("aria-labelledby");
    viewer.removeAttribute("aria-modal");
    removeClass(viewer, CLASS_FIXED);
    setStyle(viewer, {
      zIndex: options.zIndexInline
    });
    this.viewerData = assign({}, this.parentData);
    this.renderViewer();
    this.renderList();
    if (this.viewed) {
      this.initImage(function() {
        _this10.renderImage(function() {
          if (options.transition) {
            setTimeout(function() {
              addClass(image, CLASS_TRANSITION);
              addClass(list, CLASS_TRANSITION);
            }, 0);
          }
        });
      });
    }
    return this;
  },
  tooltip: function tooltip() {
    var _this11 = this;
    var options = this.options, tooltipBox = this.tooltipBox, imageData = this.imageData;
    if (!this.viewed || this.played || !options.tooltip) {
      return this;
    }
    tooltipBox.textContent = "".concat(Math.round(imageData.ratio * 100), "%");
    if (!this.tooltipping) {
      if (options.transition) {
        if (this.fading) {
          dispatchEvent(tooltipBox, EVENT_TRANSITION_END);
        }
        addClass(tooltipBox, CLASS_SHOW);
        addClass(tooltipBox, CLASS_FADE);
        addClass(tooltipBox, CLASS_TRANSITION);
        tooltipBox.removeAttribute("aria-hidden");
        tooltipBox.initialOffsetWidth = tooltipBox.offsetWidth;
        addClass(tooltipBox, CLASS_IN);
      } else {
        addClass(tooltipBox, CLASS_SHOW);
        tooltipBox.removeAttribute("aria-hidden");
      }
    } else {
      clearTimeout(this.tooltipping);
    }
    this.tooltipping = setTimeout(function() {
      if (options.transition) {
        addListener(tooltipBox, EVENT_TRANSITION_END, function() {
          removeClass(tooltipBox, CLASS_SHOW);
          removeClass(tooltipBox, CLASS_FADE);
          removeClass(tooltipBox, CLASS_TRANSITION);
          tooltipBox.setAttribute("aria-hidden", true);
          _this11.fading = false;
        }, {
          once: true
        });
        removeClass(tooltipBox, CLASS_IN);
        _this11.fading = true;
      } else {
        removeClass(tooltipBox, CLASS_SHOW);
        tooltipBox.setAttribute("aria-hidden", true);
      }
      _this11.tooltipping = false;
    }, 1e3);
    return this;
  },
  toggle: function toggle() {
    var _originalEvent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    if (this.imageData.ratio === 1) {
      this.zoomTo(this.imageData.oldRatio, true, _originalEvent);
    } else {
      this.zoomTo(1, true, _originalEvent);
    }
    return this;
  },
  reset: function reset() {
    if (this.viewed && !this.played) {
      this.imageData = assign({}, this.initialImageData);
      this.renderImage();
    }
    return this;
  },
  update: function update2() {
    var _this12 = this;
    var element = this.element, options = this.options, isImg = this.isImg;
    if (isImg && !element.parentNode) {
      return this.destroy();
    }
    var images2 = [];
    forEach(isImg ? [element] : element.querySelectorAll("img"), function(image) {
      if (isFunction(options.filter)) {
        if (options.filter.call(_this12, image)) {
          images2.push(image);
        }
      } else if (_this12.getImageURL(image)) {
        images2.push(image);
      }
    });
    if (!images2.length) {
      return this;
    }
    this.images = images2;
    this.length = images2.length;
    if (this.ready) {
      var changedIndexes = [];
      forEach(this.items, function(item, i2) {
        var img = item.querySelector("img");
        var image = images2[i2];
        if (image && img) {
          if (image.src !== img.src || image.alt !== img.alt) {
            changedIndexes.push(i2);
          }
        } else {
          changedIndexes.push(i2);
        }
      });
      setStyle(this.list, {
        width: "auto"
      });
      this.initList();
      if (this.isShown) {
        if (this.length) {
          if (this.viewed) {
            var changedIndex = changedIndexes.indexOf(this.index);
            if (changedIndex >= 0) {
              this.viewed = false;
              this.view(Math.max(Math.min(this.index - changedIndex, this.length - 1), 0));
            } else {
              var activeItem = this.items[this.index];
              addClass(activeItem, CLASS_ACTIVE);
              activeItem.setAttribute("aria-selected", true);
            }
          }
        } else {
          this.image = null;
          this.viewed = false;
          this.index = 0;
          this.imageData = {};
          this.canvas.innerHTML = "";
          this.title.innerHTML = "";
        }
      }
    } else {
      this.build();
    }
    return this;
  },
  destroy: function destroy() {
    var element = this.element, options = this.options;
    if (!element[NAMESPACE]) {
      return this;
    }
    this.destroyed = true;
    if (this.ready) {
      if (this.played) {
        this.stop();
      }
      if (options.inline) {
        if (this.fulled) {
          this.exit();
        }
        this.unbind();
      } else if (this.isShown) {
        if (this.viewing) {
          if (this.imageRendering) {
            this.imageRendering.abort();
          } else if (this.imageInitializing) {
            this.imageInitializing.abort();
          }
        }
        if (this.hiding) {
          this.transitioning.abort();
        }
        this.hidden();
      } else if (this.showing) {
        this.transitioning.abort();
        this.hidden();
      }
      this.ready = false;
      this.viewer.parentNode.removeChild(this.viewer);
    } else if (options.inline) {
      if (this.delaying) {
        this.delaying.abort();
      } else if (this.initializing) {
        this.initializing.abort();
      }
    }
    if (!options.inline) {
      removeListener(element, EVENT_CLICK, this.onStart);
    }
    element[NAMESPACE] = void 0;
    return this;
  }
};
var others = {
  getImageURL: function getImageURL(image) {
    var url = this.options.url;
    if (isString(url)) {
      url = image.getAttribute(url);
    } else if (isFunction(url)) {
      url = url.call(this, image);
    } else {
      url = "";
    }
    return url;
  },
  enforceFocus: function enforceFocus() {
    var _this = this;
    this.clearEnforceFocus();
    addListener(document, EVENT_FOCUSIN, this.onFocusin = function(event) {
      var viewer = _this.viewer;
      var target = event.target;
      if (target !== document && target !== viewer && !viewer.contains(target) && (target.getAttribute("tabindex") === null || target.getAttribute("aria-modal") !== "true")) {
        viewer.focus();
      }
    });
  },
  clearEnforceFocus: function clearEnforceFocus() {
    if (this.onFocusin) {
      removeListener(document, EVENT_FOCUSIN, this.onFocusin);
      this.onFocusin = null;
    }
  },
  open: function open() {
    var body = this.body;
    addClass(body, CLASS_OPEN);
    body.style.paddingRight = "".concat(this.scrollbarWidth + (parseFloat(this.initialBodyComputedPaddingRight) || 0), "px");
  },
  close: function close() {
    var body = this.body;
    removeClass(body, CLASS_OPEN);
    body.style.paddingRight = this.initialBodyPaddingRight;
  },
  shown: function shown() {
    var element = this.element, options = this.options, viewer = this.viewer;
    this.fulled = true;
    this.isShown = true;
    this.render();
    this.bind();
    this.showing = false;
    if (options.focus) {
      viewer.focus();
      this.enforceFocus();
    }
    if (isFunction(options.shown)) {
      addListener(element, EVENT_SHOWN, options.shown, {
        once: true
      });
    }
    if (dispatchEvent(element, EVENT_SHOWN) === false) {
      return;
    }
    if (this.ready && this.isShown && !this.hiding) {
      this.view(this.index);
    }
  },
  hidden: function hidden() {
    var element = this.element, options = this.options, viewer = this.viewer;
    if (options.fucus) {
      this.clearEnforceFocus();
    }
    this.fulled = false;
    this.viewed = false;
    this.isShown = false;
    this.close();
    this.unbind();
    addClass(viewer, CLASS_HIDE);
    viewer.removeAttribute("role");
    viewer.removeAttribute("aria-labelledby");
    viewer.removeAttribute("aria-modal");
    viewer.setAttribute("aria-hidden", true);
    this.resetList();
    this.resetImage();
    this.hiding = false;
    if (!this.destroyed) {
      if (isFunction(options.hidden)) {
        addListener(element, EVENT_HIDDEN, options.hidden, {
          once: true
        });
      }
      dispatchEvent(element, EVENT_HIDDEN, null, {
        cancelable: false
      });
    }
  },
  requestFullscreen: function requestFullscreen(options) {
    var document2 = this.element.ownerDocument;
    if (this.fulled && !(document2.fullscreenElement || document2.webkitFullscreenElement || document2.mozFullScreenElement || document2.msFullscreenElement)) {
      var documentElement = document2.documentElement;
      if (documentElement.requestFullscreen) {
        if (isPlainObject(options)) {
          documentElement.requestFullscreen(options);
        } else {
          documentElement.requestFullscreen();
        }
      } else if (documentElement.webkitRequestFullscreen) {
        documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
      } else if (documentElement.mozRequestFullScreen) {
        documentElement.mozRequestFullScreen();
      } else if (documentElement.msRequestFullscreen) {
        documentElement.msRequestFullscreen();
      }
    }
  },
  exitFullscreen: function exitFullscreen() {
    var document2 = this.element.ownerDocument;
    if (this.fulled && (document2.fullscreenElement || document2.webkitFullscreenElement || document2.mozFullScreenElement || document2.msFullscreenElement)) {
      if (document2.exitFullscreen) {
        document2.exitFullscreen();
      } else if (document2.webkitExitFullscreen) {
        document2.webkitExitFullscreen();
      } else if (document2.mozCancelFullScreen) {
        document2.mozCancelFullScreen();
      } else if (document2.msExitFullscreen) {
        document2.msExitFullscreen();
      }
    }
  },
  change: function change(event) {
    var options = this.options, pointers = this.pointers;
    var pointer = pointers[Object.keys(pointers)[0]];
    if (!pointer) {
      return;
    }
    var offsetX = pointer.endX - pointer.startX;
    var offsetY = pointer.endY - pointer.startY;
    switch (this.action) {
      case ACTION_MOVE:
        this.move(offsetX, offsetY, event);
        break;
      case ACTION_ZOOM:
        this.zoom(getMaxZoomRatio(pointers), false, event);
        break;
      case ACTION_SWITCH: {
        this.action = "switched";
        var absoluteOffsetX = Math.abs(offsetX);
        if (absoluteOffsetX > 1 && absoluteOffsetX > Math.abs(offsetY)) {
          this.pointers = {};
          if (offsetX > 1) {
            this.prev(options.loop);
          } else if (offsetX < -1) {
            this.next(options.loop);
          }
        }
        break;
      }
    }
    forEach(pointers, function(p2) {
      p2.startX = p2.endX;
      p2.startY = p2.endY;
    });
  },
  isSwitchable: function isSwitchable() {
    var imageData = this.imageData, viewerData = this.viewerData;
    return this.length > 1 && imageData.x >= 0 && imageData.y >= 0 && imageData.width <= viewerData.width && imageData.height <= viewerData.height;
  }
};
var AnotherViewer = WINDOW.Viewer;
var getUniqueID = function(id) {
  return function() {
    id += 1;
    return id;
  };
}(-1);
var Viewer$1 = /* @__PURE__ */ function() {
  function Viewer2(element) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Viewer2);
    if (!element || element.nodeType !== 1) {
      throw new Error("The first argument is required and must be an element.");
    }
    this.element = element;
    this.options = assign({}, DEFAULTS, isPlainObject(options) && options);
    this.action = false;
    this.fading = false;
    this.fulled = false;
    this.hiding = false;
    this.imageClicked = false;
    this.imageData = {};
    this.index = this.options.initialViewIndex;
    this.isImg = false;
    this.isShown = false;
    this.length = 0;
    this.moving = false;
    this.played = false;
    this.playing = false;
    this.pointers = {};
    this.ready = false;
    this.rotating = false;
    this.scaling = false;
    this.showing = false;
    this.timeout = false;
    this.tooltipping = false;
    this.viewed = false;
    this.viewing = false;
    this.wheeling = false;
    this.zooming = false;
    this.id = getUniqueID();
    this.init();
  }
  _createClass(Viewer2, [{
    key: "init",
    value: function init() {
      var _this = this;
      var element = this.element, options = this.options;
      if (element[NAMESPACE]) {
        return;
      }
      element[NAMESPACE] = this;
      if (options.focus && !options.keyboard) {
        options.focus = false;
      }
      var isImg = element.localName === "img";
      var images2 = [];
      forEach(isImg ? [element] : element.querySelectorAll("img"), function(image) {
        if (isFunction(options.filter)) {
          if (options.filter.call(_this, image)) {
            images2.push(image);
          }
        } else if (_this.getImageURL(image)) {
          images2.push(image);
        }
      });
      this.isImg = isImg;
      this.length = images2.length;
      this.images = images2;
      this.initBody();
      if (isUndefined(document.createElement(NAMESPACE).style.transition)) {
        options.transition = false;
      }
      if (options.inline) {
        var count2 = 0;
        var progress = function progress2() {
          count2 += 1;
          if (count2 === _this.length) {
            var timeout;
            _this.initializing = false;
            _this.delaying = {
              abort: function abort() {
                clearTimeout(timeout);
              }
            };
            timeout = setTimeout(function() {
              _this.delaying = false;
              _this.build();
            }, 0);
          }
        };
        this.initializing = {
          abort: function abort() {
            forEach(images2, function(image) {
              if (!image.complete) {
                removeListener(image, EVENT_LOAD, progress);
              }
            });
          }
        };
        forEach(images2, function(image) {
          if (image.complete) {
            progress();
          } else {
            addListener(image, EVENT_LOAD, progress, {
              once: true
            });
          }
        });
      } else {
        addListener(element, EVENT_CLICK, this.onStart = function(_ref) {
          var target = _ref.target;
          if (target.localName === "img" && (!isFunction(options.filter) || options.filter.call(_this, target))) {
            _this.view(_this.images.indexOf(target));
          }
        });
      }
    }
  }, {
    key: "build",
    value: function build() {
      if (this.ready) {
        return;
      }
      var element = this.element, options = this.options;
      var parent2 = element.parentNode;
      var template = document.createElement("div");
      template.innerHTML = TEMPLATE;
      var viewer = template.querySelector(".".concat(NAMESPACE, "-container"));
      var title = viewer.querySelector(".".concat(NAMESPACE, "-title"));
      var toolbar = viewer.querySelector(".".concat(NAMESPACE, "-toolbar"));
      var navbar = viewer.querySelector(".".concat(NAMESPACE, "-navbar"));
      var button = viewer.querySelector(".".concat(NAMESPACE, "-button"));
      var canvas = viewer.querySelector(".".concat(NAMESPACE, "-canvas"));
      this.parent = parent2;
      this.viewer = viewer;
      this.title = title;
      this.toolbar = toolbar;
      this.navbar = navbar;
      this.button = button;
      this.canvas = canvas;
      this.footer = viewer.querySelector(".".concat(NAMESPACE, "-footer"));
      this.tooltipBox = viewer.querySelector(".".concat(NAMESPACE, "-tooltip"));
      this.player = viewer.querySelector(".".concat(NAMESPACE, "-player"));
      this.list = viewer.querySelector(".".concat(NAMESPACE, "-list"));
      viewer.id = "".concat(NAMESPACE).concat(this.id);
      title.id = "".concat(NAMESPACE, "Title").concat(this.id);
      addClass(title, !options.title ? CLASS_HIDE : getResponsiveClass(Array.isArray(options.title) ? options.title[0] : options.title));
      addClass(navbar, !options.navbar ? CLASS_HIDE : getResponsiveClass(options.navbar));
      toggleClass(button, CLASS_HIDE, !options.button);
      if (options.keyboard) {
        button.setAttribute("tabindex", 0);
      }
      if (options.backdrop) {
        addClass(viewer, "".concat(NAMESPACE, "-backdrop"));
        if (!options.inline && options.backdrop !== "static") {
          setData(canvas, DATA_ACTION, "hide");
        }
      }
      if (isString(options.className) && options.className) {
        options.className.split(REGEXP_SPACES).forEach(function(className) {
          addClass(viewer, className);
        });
      }
      if (options.toolbar) {
        var list = document.createElement("ul");
        var custom = isPlainObject(options.toolbar);
        var zoomButtons = BUTTONS.slice(0, 3);
        var rotateButtons = BUTTONS.slice(7, 9);
        var scaleButtons = BUTTONS.slice(9);
        if (!custom) {
          addClass(toolbar, getResponsiveClass(options.toolbar));
        }
        forEach(custom ? options.toolbar : BUTTONS, function(value, index2) {
          var deep = custom && isPlainObject(value);
          var name = custom ? hyphenate(index2) : value;
          var show2 = deep && !isUndefined(value.show) ? value.show : value;
          if (!show2 || !options.zoomable && zoomButtons.indexOf(name) !== -1 || !options.rotatable && rotateButtons.indexOf(name) !== -1 || !options.scalable && scaleButtons.indexOf(name) !== -1) {
            return;
          }
          var size = deep && !isUndefined(value.size) ? value.size : value;
          var click2 = deep && !isUndefined(value.click) ? value.click : value;
          var item = document.createElement("li");
          if (options.keyboard) {
            item.setAttribute("tabindex", 0);
          }
          item.setAttribute("role", "button");
          addClass(item, "".concat(NAMESPACE, "-").concat(name));
          if (!isFunction(click2)) {
            setData(item, DATA_ACTION, name);
          }
          if (isNumber(show2)) {
            addClass(item, getResponsiveClass(show2));
          }
          if (["small", "large"].indexOf(size) !== -1) {
            addClass(item, "".concat(NAMESPACE, "-").concat(size));
          } else if (name === "play") {
            addClass(item, "".concat(NAMESPACE, "-large"));
          }
          if (isFunction(click2)) {
            addListener(item, EVENT_CLICK, click2);
          }
          list.appendChild(item);
        });
        toolbar.appendChild(list);
      } else {
        addClass(toolbar, CLASS_HIDE);
      }
      if (!options.rotatable) {
        var rotates = toolbar.querySelectorAll('li[class*="rotate"]');
        addClass(rotates, CLASS_INVISIBLE);
        forEach(rotates, function(rotate2) {
          toolbar.appendChild(rotate2);
        });
      }
      if (options.inline) {
        addClass(button, CLASS_FULLSCREEN);
        setStyle(viewer, {
          zIndex: options.zIndexInline
        });
        if (window.getComputedStyle(parent2).position === "static") {
          setStyle(parent2, {
            position: "relative"
          });
        }
        parent2.insertBefore(viewer, element.nextSibling);
      } else {
        addClass(button, CLASS_CLOSE);
        addClass(viewer, CLASS_FIXED);
        addClass(viewer, CLASS_FADE);
        addClass(viewer, CLASS_HIDE);
        setStyle(viewer, {
          zIndex: options.zIndex
        });
        var container = options.container;
        if (isString(container)) {
          container = element.ownerDocument.querySelector(container);
        }
        if (!container) {
          container = this.body;
        }
        container.appendChild(viewer);
      }
      if (options.inline) {
        this.render();
        this.bind();
        this.isShown = true;
      }
      this.ready = true;
      if (isFunction(options.ready)) {
        addListener(element, EVENT_READY, options.ready, {
          once: true
        });
      }
      if (dispatchEvent(element, EVENT_READY) === false) {
        this.ready = false;
        return;
      }
      if (this.ready && options.inline) {
        this.view(this.index);
      }
    }
  }], [{
    key: "noConflict",
    value: function noConflict() {
      window.Viewer = AnotherViewer;
      return Viewer2;
    }
  }, {
    key: "setDefaults",
    value: function setDefaults(options) {
      assign(DEFAULTS, isPlainObject(options) && options);
    }
  }]);
  return Viewer2;
}();
assign(Viewer$1.prototype, render, events, handlers, methods, others);
var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __getProtoOf$2 = Object.getPrototypeOf;
var __reflectGet$2 = Reflect.get;
var __decorateClass$3 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$3(target, key, result);
  return result;
};
var __superStaticGet$2 = (obj, member) => __reflectGet$2(__getProtoOf$2(obj), member, obj);
let QyViewerImage = class extends QyViewerBase {
  constructor() {
    super(...arguments);
    this.viewer = null;
  }
  open(imgUrl) {
    const imgEl = this.shadowRoot.querySelector(".img_template");
    imgEl.src = imgUrl;
    this.viewer = new Viewer$1(imgEl, {
      inline: true,
      navbar: false,
      toolbar: false,
      backdrop: false,
      title: false,
      transition: false
    });
    super.open(imgUrl);
  }
  close() {
    const imgEl = this.shadowRoot.querySelector(".img_template");
    imgEl.src = "";
    const viewer = this.viewer;
    viewer.destroy();
    this.viewer = null;
    super.close();
  }
  renderViewer() {
    return $$1`<img class="img_template">`;
  }
  render() {
    return $$1`
      <style>
/*!
 * Viewer.js v1.10.3
 * https://fengyuanchen.github.io/viewerjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2022-02-02T05:14:59.271Z
 */
        .viewer-close:before,.viewer-flip-horizontal:before,.viewer-flip-vertical:before,.viewer-fullscreen-exit:before,.viewer-fullscreen:before,.viewer-next:before,.viewer-one-to-one:before,.viewer-play:before,.viewer-prev:before,.viewer-reset:before,.viewer-rotate-left:before,.viewer-rotate-right:before,.viewer-zoom-in:before,.viewer-zoom-out:before{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAAAUCAYAAABWOyJDAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAQPSURBVHic7Zs/iFxVFMa/0U2UaJGksUgnIVhYxVhpjDbZCBmLdAYECxsRFBTUamcXUiSNncgKQbSxsxH8gzAP3FU2jY0kKKJNiiiIghFlccnP4p3nPCdv3p9778vsLOcHB2bfveeb7955c3jvvNkBIMdxnD64a94GHMfZu3iBcRynN7zAOI7TG15gHCeeNUkr8zaxG2lbYDYsdgMbktBsP03jdQwljSXdtBhLOmtjowC9Mg9L+knSlcD8TNKpSA9lBpK2JF2VdDSR5n5J64m0qli399hNFMUlpshQii5jbXTbHGviB0nLNeNDSd9VO4A2UdB2fp+x0eCnaXxWXGA2X0au/3HgN9P4LFCjIANOJdrLr0zzZ+BEpNYDwKbpnQMeAw4m8HjQtM6Z9qa917zPQwFr3M5KgA6J5rTJCdFZJj9/lyvGhsDvwFNVuV2MhhjrK6b9bFiE+j1r87eBl4HDwCF7/U/k+ofAX5b/EXBv5JoLMuILzf3Ap6Z3EzgdqHMCuF7hcQf4HDgeoHnccncqdK/TvSDWffFXI/exICY/xZyqc6XLWF1UFZna4gJ7q8BsRvgd2/xXpo6P+D9dfT7PpECtA3cnWPM0GXGFZh/wgWltA+cDNC7X+AP4GzjZQe+k5dRxuYPeiuXU7e1qwLpDz7dFjXKRaSwuMLvAlG8zZlG+YmiK1HoFqT7wP2z+4Q45TfEGcMt01xLoNZEBTwRqD4BLpnMLeC1A41UmVxsXgXeBayV/Wx20rpTyrpnWRft7p6O/FdqzGrDukPNtkaMoMo3FBdBSQMOnYBCReyf05s126fU9ytfX98+mY54Kxnp7S9K3kj6U9KYdG0h6UdLbkh7poFXMfUnSOyVvL0h6VtIXHbS6nOP+s/Zm9mvyXW1uuC9ohZ72E9uDmXWLJOB1GxsH+DxPftsB8B6wlGDN02TAkxG6+4D3TWsbeC5CS8CDFce+AW500LhhOW2020TRjK3b21HEmgti9m0RonxbdMZeVzV+/4tF3cBpP7E9mKHNL5q8h5g0eYsCMQz0epq8gQrwMXAgcs0FGXGFRcB9wCemF9PkbYqM/Bas7fxLwNeJPdTdpo4itQti8lPMqTpXuozVRVXPpbHI3KkNTB1NfkL81j2mvhDp91HgV9MKuRIqrykj3WPq4rHyL+axj8/qGPmTqi6F9YDlHOvJU6oYcTsh/TYSzWmTE6JT19CtLTJt32D6CmHe0eQn1O8z5AXgT4sx4Vcu0/EQecMydB8z0hUWkTd2t4CrwNEePqMBcAR4mrBbwyXLPWJa8zrXmmLEhNBmfpkuY2102xxrih+pb+ieAb6vGhuA97UcJ5KR8gZ77K+99xxeYBzH6Q3/Z0fHcXrDC4zjOL3hBcZxnN74F+zlvXFWXF9PAAAAAElFTkSuQmCC");background-repeat:no-repeat;background-size:280px;color:transparent;display:block;font-size:0;height:20px;line-height:0;width:20px}.viewer-zoom-in:before{background-position:0 0;content:"Zoom In"}.viewer-zoom-out:before{background-position:-20px 0;content:"Zoom Out"}.viewer-one-to-one:before{background-position:-40px 0;content:"One to One"}.viewer-reset:before{background-position:-60px 0;content:"Reset"}.viewer-prev:before{background-position:-80px 0;content:"Previous"}.viewer-play:before{background-position:-100px 0;content:"Play"}.viewer-next:before{background-position:-120px 0;content:"Next"}.viewer-rotate-left:before{background-position:-140px 0;content:"Rotate Left"}.viewer-rotate-right:before{background-position:-160px 0;content:"Rotate Right"}.viewer-flip-horizontal:before{background-position:-180px 0;content:"Flip Horizontal"}.viewer-flip-vertical:before{background-position:-200px 0;content:"Flip Vertical"}.viewer-fullscreen:before{background-position:-220px 0;content:"Enter Full Screen"}.viewer-fullscreen-exit:before{background-position:-240px 0;content:"Exit Full Screen"}.viewer-close:before{background-position:-260px 0;content:"Close"}.viewer-container{-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none;bottom:0;direction:ltr;font-size:0;left:0;line-height:0;overflow:hidden;position:absolute;right:0;top:0;touch-action:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.viewer-container ::-moz-selection,.viewer-container::-moz-selection{background-color:transparent}.viewer-container ::selection,.viewer-container::selection{background-color:transparent}.viewer-container:focus{outline:0}.viewer-container img{display:block;height:auto;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;width:100%}.viewer-canvas{bottom:0;left:0;overflow:hidden;position:absolute;right:0;top:0}.viewer-canvas>img{height:auto;margin:15px auto;max-width:90%!important;width:auto}.viewer-footer{bottom:0;left:0;overflow:hidden;position:absolute;right:0;text-align:center}.viewer-navbar{background-color:rgba(0,0,0,.5);overflow:hidden}.viewer-list{box-sizing:content-box;height:50px;margin:0;overflow:hidden;padding:1px 0}.viewer-list>li{color:transparent;cursor:pointer;float:left;font-size:0;height:50px;line-height:0;opacity:.5;overflow:hidden;transition:opacity .15s;width:30px}.viewer-list>li:focus,.viewer-list>li:hover{opacity:.75}.viewer-list>li:focus{outline:0}.viewer-list>li+li{margin-left:1px}.viewer-list>.viewer-loading{position:relative}.viewer-list>.viewer-loading:after{border-width:2px;height:20px;margin-left:-10px;margin-top:-10px;width:20px}.viewer-list>.viewer-active,.viewer-list>.viewer-active:focus,.viewer-list>.viewer-active:hover{opacity:1}.viewer-player{background-color:#000;bottom:0;cursor:none;display:none;right:0;z-index:1}.viewer-player,.viewer-player>img{left:0;position:absolute;top:0}.viewer-toolbar>ul{display:inline-block;margin:0 auto 5px;overflow:hidden;padding:6px 3px}.viewer-toolbar>ul>li{background-color:rgba(0,0,0,.5);border-radius:50%;cursor:pointer;float:left;height:24px;overflow:hidden;transition:background-color .15s;width:24px}.viewer-toolbar>ul>li:focus,.viewer-toolbar>ul>li:hover{background-color:rgba(0,0,0,.8)}.viewer-toolbar>ul>li:focus{box-shadow:0 0 3px #fff;outline:0;position:relative;z-index:1}.viewer-toolbar>ul>li:before{margin:2px}.viewer-toolbar>ul>li+li{margin-left:1px}.viewer-toolbar>ul>.viewer-small{height:18px;margin-bottom:3px;margin-top:3px;width:18px}.viewer-toolbar>ul>.viewer-small:before{margin:-1px}.viewer-toolbar>ul>.viewer-large{height:30px;margin-bottom:-3px;margin-top:-3px;width:30px}.viewer-toolbar>ul>.viewer-large:before{margin:5px}.viewer-tooltip{background-color:rgba(0,0,0,.8);border-radius:10px;color:#fff;display:none;font-size:12px;height:20px;left:50%;line-height:20px;margin-left:-25px;margin-top:-10px;position:absolute;text-align:center;top:50%;width:50px}.viewer-title{color:#ccc;display:inline-block;font-size:12px;line-height:1.2;margin:0 5% 5px;max-width:90%;opacity:.8;overflow:hidden;text-overflow:ellipsis;transition:opacity .15s;white-space:nowrap}.viewer-title:hover{opacity:1}.viewer-button{background-color:rgba(0,0,0,.5);border-radius:50%;cursor:pointer;height:80px;overflow:hidden;position:absolute;right:-40px;top:-40px;transition:background-color .15s;width:80px}.viewer-button:focus,.viewer-button:hover{background-color:rgba(0,0,0,.8)}.viewer-button:focus{box-shadow:0 0 3px #fff;outline:0}.viewer-button:before{bottom:15px;left:15px;position:absolute}.viewer-fixed{position:fixed}.viewer-open{overflow:hidden}.viewer-show{display:block}.viewer-hide{display:none}.viewer-backdrop{background-color:rgba(0,0,0,.5)}.viewer-invisible{visibility:hidden}.viewer-move{cursor:move;cursor:-webkit-grab;cursor:grab}.viewer-fade{opacity:0}.viewer-in{opacity:1}.viewer-transition{transition:all .3s}@-webkit-keyframes viewer-spinner{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}@keyframes viewer-spinner{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.viewer-loading:after{-webkit-animation:viewer-spinner 1s linear infinite;animation:viewer-spinner 1s linear infinite;border:4px solid hsla(0,0%,100%,.1);border-left-color:hsla(0,0%,100%,.5);border-radius:50%;content:"";display:inline-block;height:40px;left:50%;margin-left:-20px;margin-top:-20px;position:absolute;top:50%;width:40px;z-index:1}@media (max-width:767px){.viewer-hide-xs-down{display:none}}@media (max-width:991px){.viewer-hide-sm-down{display:none}}@media (max-width:1199px){.viewer-hide-md-down{display:none}}
      </style>
      ${super.render()}
    `;
  }
};
QyViewerImage.styles = r$2`
    ${__superStaticGet$2(QyViewerImage, "styles")}

    .img_template {
      display: none;
    }
  `;
__decorateClass$3([
  e()
], QyViewerImage.prototype, "viewer", 2);
QyViewerImage = __decorateClass$3([
  n$1("qy-viewer-image")
], QyViewerImage);
if (Number.EPSILON === void 0) {
  Number.EPSILON = Math.pow(2, -52);
}
if (Number.isInteger === void 0) {
  Number.isInteger = function(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
}
if (Math.sign === void 0) {
  Math.sign = function(x2) {
    return x2 < 0 ? -1 : x2 > 0 ? 1 : +x2;
  };
}
if ("name" in Function.prototype === false) {
  Object.defineProperty(Function.prototype, "name", {
    get: function() {
      return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
    }
  });
}
if (Object.assign === void 0) {
  (function() {
    Object.assign = function(target) {
      if (target === void 0 || target === null) {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      var output = Object(target);
      for (var index2 = 1; index2 < arguments.length; index2++) {
        var source = arguments[index2];
        if (source !== void 0 && source !== null) {
          for (var nextKey in source) {
            if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }
      return output;
    };
  })();
}
function EventDispatcher() {
}
Object.assign(EventDispatcher.prototype, {
  addEventListener: function(type, listener) {
    if (this._listeners === void 0)
      this._listeners = {};
    var listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  },
  hasEventListener: function(type, listener) {
    if (this._listeners === void 0)
      return false;
    var listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  },
  removeEventListener: function(type, listener) {
    if (this._listeners === void 0)
      return;
    var listeners = this._listeners;
    var listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      var index2 = listenerArray.indexOf(listener);
      if (index2 !== -1) {
        listenerArray.splice(index2, 1);
      }
    }
  },
  dispatchEvent: function(event) {
    if (this._listeners === void 0)
      return;
    var listeners = this._listeners;
    var listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      var array = listenerArray.slice(0);
      for (var i2 = 0, l2 = array.length; i2 < l2; i2++) {
        array[i2].call(this, event);
      }
    }
  }
});
var REVISION$1 = "105";
var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var Uncharted2ToneMapping = 3;
var CineonToneMapping = 4;
var ACESFilmicToneMapping = 5;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var SphericalReflectionMapping = 305;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1e3;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipMapNearestFilter = 1004;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipMapNearestFilter = 1007;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3e3;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;
var _Math = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function() {
    var lut = [];
    for (var i2 = 0; i2 < 256; i2++) {
      lut[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
    }
    return function generateUUID() {
      var d0 = Math.random() * 4294967295 | 0;
      var d1 = Math.random() * 4294967295 | 0;
      var d2 = Math.random() * 4294967295 | 0;
      var d3 = Math.random() * 4294967295 | 0;
      var uuid = lut[d0 & 255] + lut[d0 >> 8 & 255] + lut[d0 >> 16 & 255] + lut[d0 >> 24 & 255] + "-" + lut[d1 & 255] + lut[d1 >> 8 & 255] + "-" + lut[d1 >> 16 & 15 | 64] + lut[d1 >> 24 & 255] + "-" + lut[d2 & 63 | 128] + lut[d2 >> 8 & 255] + "-" + lut[d2 >> 16 & 255] + lut[d2 >> 24 & 255] + lut[d3 & 255] + lut[d3 >> 8 & 255] + lut[d3 >> 16 & 255] + lut[d3 >> 24 & 255];
      return uuid.toUpperCase();
    };
  }(),
  clamp: function(value, min, max) {
    return Math.max(min, Math.min(max, value));
  },
  euclideanModulo: function(n2, m2) {
    return (n2 % m2 + m2) % m2;
  },
  mapLinear: function(x2, a1, a2, b1, b2) {
    return b1 + (x2 - a1) * (b2 - b1) / (a2 - a1);
  },
  lerp: function(x2, y, t2) {
    return (1 - t2) * x2 + t2 * y;
  },
  smoothstep: function(x2, min, max) {
    if (x2 <= min)
      return 0;
    if (x2 >= max)
      return 1;
    x2 = (x2 - min) / (max - min);
    return x2 * x2 * (3 - 2 * x2);
  },
  smootherstep: function(x2, min, max) {
    if (x2 <= min)
      return 0;
    if (x2 >= max)
      return 1;
    x2 = (x2 - min) / (max - min);
    return x2 * x2 * x2 * (x2 * (x2 * 6 - 15) + 10);
  },
  randInt: function(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  randFloat: function(low, high) {
    return low + Math.random() * (high - low);
  },
  randFloatSpread: function(range) {
    return range * (0.5 - Math.random());
  },
  degToRad: function(degrees) {
    return degrees * _Math.DEG2RAD;
  },
  radToDeg: function(radians) {
    return radians * _Math.RAD2DEG;
  },
  isPowerOfTwo: function(value) {
    return (value & value - 1) === 0 && value !== 0;
  },
  ceilPowerOfTwo: function(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  },
  floorPowerOfTwo: function(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  }
};
function Vector2(x2, y) {
  this.x = x2 || 0;
  this.y = y || 0;
}
Object.defineProperties(Vector2.prototype, {
  "width": {
    get: function() {
      return this.x;
    },
    set: function(value) {
      this.x = value;
    }
  },
  "height": {
    get: function() {
      return this.y;
    },
    set: function(value) {
      this.y = value;
    }
  }
});
Object.assign(Vector2.prototype, {
  isVector2: true,
  set: function(x2, y) {
    this.x = x2;
    this.y = y;
    return this;
  },
  setScalar: function(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  },
  setX: function(x2) {
    this.x = x2;
    return this;
  },
  setY: function(y) {
    this.y = y;
    return this;
  },
  setComponent: function(index2, value) {
    switch (index2) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index2);
    }
    return this;
  },
  getComponent: function(index2) {
    switch (index2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index2);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y);
  },
  copy: function(v2) {
    this.x = v2.x;
    this.y = v2.y;
    return this;
  },
  add: function(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    return this;
  },
  addScalar: function(s2) {
    this.x += s2;
    this.y += s2;
    return this;
  },
  addVectors: function(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    return this;
  },
  addScaledVector: function(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    return this;
  },
  sub: function(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    return this;
  },
  subScalar: function(s2) {
    this.x -= s2;
    this.y -= s2;
    return this;
  },
  subVectors: function(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    return this;
  },
  multiply: function(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    return this;
  },
  multiplyScalar: function(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  },
  divide: function(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    return this;
  },
  divideScalar: function(scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  applyMatrix3: function(m2) {
    var x2 = this.x, y = this.y;
    var e2 = m2.elements;
    this.x = e2[0] * x2 + e2[3] * y + e2[6];
    this.y = e2[1] * x2 + e2[4] * y + e2[7];
    return this;
  },
  min: function(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    return this;
  },
  max: function(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    return this;
  },
  clamp: function(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  },
  clampScalar: function(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  },
  clampLength: function(min, max) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  },
  floor: function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  },
  ceil: function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  },
  round: function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  },
  roundToZero: function() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  },
  negate: function() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  },
  dot: function(v2) {
    return this.x * v2.x + this.y * v2.y;
  },
  cross: function(v2) {
    return this.x * v2.y - this.y * v2.x;
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  angle: function() {
    var angle = Math.atan2(this.y, this.x);
    if (angle < 0)
      angle += 2 * Math.PI;
    return angle;
  },
  distanceTo: function(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  },
  distanceToSquared: function(v2) {
    var dx = this.x - v2.x, dy = this.y - v2.y;
    return dx * dx + dy * dy;
  },
  manhattanDistanceTo: function(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y);
  },
  setLength: function(length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    return this;
  },
  lerpVectors: function(v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },
  equals: function(v2) {
    return v2.x === this.x && v2.y === this.y;
  },
  fromArray: function(array, offset2) {
    if (offset2 === void 0)
      offset2 = 0;
    this.x = array[offset2];
    this.y = array[offset2 + 1];
    return this;
  },
  toArray: function(array, offset2) {
    if (array === void 0)
      array = [];
    if (offset2 === void 0)
      offset2 = 0;
    array[offset2] = this.x;
    array[offset2 + 1] = this.y;
    return array;
  },
  fromBufferAttribute: function(attribute, index2, offset2) {
    if (offset2 !== void 0) {
      console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index2);
    this.y = attribute.getY(index2);
    return this;
  },
  rotateAround: function(center, angle) {
    var c2 = Math.cos(angle), s2 = Math.sin(angle);
    var x2 = this.x - center.x;
    var y = this.y - center.y;
    this.x = x2 * c2 - y * s2 + center.x;
    this.y = x2 * s2 + y * c2 + center.y;
    return this;
  }
});
function Quaternion(x2, y, z2, w2) {
  this._x = x2 || 0;
  this._y = y || 0;
  this._z = z2 || 0;
  this._w = w2 !== void 0 ? w2 : 1;
}
Object.assign(Quaternion, {
  slerp: function(qa, qb, qm, t2) {
    return qm.copy(qa).slerp(qb, t2);
  },
  slerpFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
    var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      var s2 = 1 - t2, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s2 = Math.sin(s2 * len) / sin;
        t2 = Math.sin(t2 * len) / sin;
      }
      var tDir = t2 * dir;
      x0 = x0 * s2 + x1 * tDir;
      y0 = y0 * s2 + y1 * tDir;
      z0 = z0 * s2 + z1 * tDir;
      w0 = w0 * s2 + w1 * tDir;
      if (s2 === 1 - t2) {
        var f2 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f2;
        y0 *= f2;
        z0 *= f2;
        w0 *= f2;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
});
Object.defineProperties(Quaternion.prototype, {
  x: {
    get: function() {
      return this._x;
    },
    set: function(value) {
      this._x = value;
      this.onChangeCallback();
    }
  },
  y: {
    get: function() {
      return this._y;
    },
    set: function(value) {
      this._y = value;
      this.onChangeCallback();
    }
  },
  z: {
    get: function() {
      return this._z;
    },
    set: function(value) {
      this._z = value;
      this.onChangeCallback();
    }
  },
  w: {
    get: function() {
      return this._w;
    },
    set: function(value) {
      this._w = value;
      this.onChangeCallback();
    }
  }
});
Object.assign(Quaternion.prototype, {
  isQuaternion: true,
  set: function(x2, y, z2, w2) {
    this._x = x2;
    this._y = y;
    this._z = z2;
    this._w = w2;
    this.onChangeCallback();
    return this;
  },
  clone: function() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  },
  copy: function(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this.onChangeCallback();
    return this;
  },
  setFromEuler: function(euler, update3) {
    if (!(euler && euler.isEuler)) {
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    var x2 = euler._x, y = euler._y, z2 = euler._z, order = euler.order;
    var cos = Math.cos;
    var sin = Math.sin;
    var c1 = cos(x2 / 2);
    var c2 = cos(y / 2);
    var c3 = cos(z2 / 2);
    var s1 = sin(x2 / 2);
    var s2 = sin(y / 2);
    var s3 = sin(z2 / 2);
    if (order === "XYZ") {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === "YXZ") {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === "ZXY") {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === "ZYX") {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === "YZX") {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === "XZY") {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    }
    if (update3 !== false)
      this.onChangeCallback();
    return this;
  },
  setFromAxisAngle: function(axis, angle) {
    var halfAngle = angle / 2, s2 = Math.sin(halfAngle);
    this._x = axis.x * s2;
    this._y = axis.y * s2;
    this._z = axis.z * s2;
    this._w = Math.cos(halfAngle);
    this.onChangeCallback();
    return this;
  },
  setFromRotationMatrix: function(m2) {
    var te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s2;
    if (trace > 0) {
      s2 = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s2;
      this._x = (m32 - m23) * s2;
      this._y = (m13 - m31) * s2;
      this._z = (m21 - m12) * s2;
    } else if (m11 > m22 && m11 > m33) {
      s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s2;
      this._x = 0.25 * s2;
      this._y = (m12 + m21) / s2;
      this._z = (m13 + m31) / s2;
    } else if (m22 > m33) {
      s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s2;
      this._x = (m12 + m21) / s2;
      this._y = 0.25 * s2;
      this._z = (m23 + m32) / s2;
    } else {
      s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s2;
      this._x = (m13 + m31) / s2;
      this._y = (m23 + m32) / s2;
      this._z = 0.25 * s2;
    }
    this.onChangeCallback();
    return this;
  },
  setFromUnitVectors: function(vFrom, vTo) {
    var EPS = 1e-6;
    var r2 = vFrom.dot(vTo) + 1;
    if (r2 < EPS) {
      r2 = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r2;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r2;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r2;
    }
    return this.normalize();
  },
  angleTo: function(q) {
    return 2 * Math.acos(Math.abs(_Math.clamp(this.dot(q), -1, 1)));
  },
  rotateTowards: function(q, step) {
    var angle = this.angleTo(q);
    if (angle === 0)
      return this;
    var t2 = Math.min(1, step / angle);
    this.slerp(q, t2);
    return this;
  },
  inverse: function() {
    return this.conjugate();
  },
  conjugate: function() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this.onChangeCallback();
    return this;
  },
  dot: function(v2) {
    return this._x * v2._x + this._y * v2._y + this._z * v2._z + this._w * v2._w;
  },
  lengthSq: function() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function() {
    var l2 = this.length();
    if (l2 === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l2 = 1 / l2;
      this._x = this._x * l2;
      this._y = this._y * l2;
      this._z = this._z * l2;
      this._w = this._w * l2;
    }
    this.onChangeCallback();
    return this;
  },
  multiply: function(q, p2) {
    if (p2 !== void 0) {
      console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
      return this.multiplyQuaternions(q, p2);
    }
    return this.multiplyQuaternions(this, q);
  },
  premultiply: function(q) {
    return this.multiplyQuaternions(q, this);
  },
  multiplyQuaternions: function(a2, b2) {
    var qax = a2._x, qay = a2._y, qaz = a2._z, qaw = a2._w;
    var qbx = b2._x, qby = b2._y, qbz = b2._z, qbw = b2._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this.onChangeCallback();
    return this;
  },
  slerp: function(qb, t2) {
    if (t2 === 0)
      return this;
    if (t2 === 1)
      return this.copy(qb);
    var x2 = this._x, y = this._y, z2 = this._z, w2 = this._w;
    var cosHalfTheta = w2 * qb._w + x2 * qb._x + y * qb._y + z2 * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w2;
      this._x = x2;
      this._y = y;
      this._z = z2;
      return this;
    }
    var sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      var s2 = 1 - t2;
      this._w = s2 * w2 + t2 * this._w;
      this._x = s2 * x2 + t2 * this._x;
      this._y = s2 * y + t2 * this._y;
      this._z = s2 * z2 + t2 * this._z;
      return this.normalize();
    }
    var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    var ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
    this._w = w2 * ratioA + this._w * ratioB;
    this._x = x2 * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z2 * ratioA + this._z * ratioB;
    this.onChangeCallback();
    return this;
  },
  equals: function(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  },
  fromArray: function(array, offset2) {
    if (offset2 === void 0)
      offset2 = 0;
    this._x = array[offset2];
    this._y = array[offset2 + 1];
    this._z = array[offset2 + 2];
    this._w = array[offset2 + 3];
    this.onChangeCallback();
    return this;
  },
  toArray: function(array, offset2) {
    if (array === void 0)
      array = [];
    if (offset2 === void 0)
      offset2 = 0;
    array[offset2] = this._x;
    array[offset2 + 1] = this._y;
    array[offset2 + 2] = this._z;
    array[offset2 + 3] = this._w;
    return array;
  },
  onChange: function(callback) {
    this.onChangeCallback = callback;
    return this;
  },
  onChangeCallback: function() {
  }
});
function Vector3(x2, y, z2) {
  this.x = x2 || 0;
  this.y = y || 0;
  this.z = z2 || 0;
}
Object.assign(Vector3.prototype, {
  isVector3: true,
  set: function(x2, y, z2) {
    this.x = x2;
    this.y = y;
    this.z = z2;
    return this;
  },
  setScalar: function(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  },
  setX: function(x2) {
    this.x = x2;
    return this;
  },
  setY: function(y) {
    this.y = y;
    return this;
  },
  setZ: function(z2) {
    this.z = z2;
    return this;
  },
  setComponent: function(index2, value) {
    switch (index2) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index2);
    }
    return this;
  },
  getComponent: function(index2) {
    switch (index2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index2);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y, this.z);
  },
  copy: function(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    return this;
  },
  add: function(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    return this;
  },
  addScalar: function(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    return this;
  },
  addVectors: function(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    this.z = a2.z + b2.z;
    return this;
  },
  addScaledVector: function(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    return this;
  },
  sub: function(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    return this;
  },
  subScalar: function(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    return this;
  },
  subVectors: function(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    this.z = a2.z - b2.z;
    return this;
  },
  multiply: function(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
      return this.multiplyVectors(v2, w2);
    }
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    return this;
  },
  multiplyScalar: function(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  },
  multiplyVectors: function(a2, b2) {
    this.x = a2.x * b2.x;
    this.y = a2.y * b2.y;
    this.z = a2.z * b2.z;
    return this;
  },
  applyEuler: function() {
    var quaternion = new Quaternion();
    return function applyEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
      }
      return this.applyQuaternion(quaternion.setFromEuler(euler));
    };
  }(),
  applyAxisAngle: function() {
    var quaternion = new Quaternion();
    return function applyAxisAngle(axis, angle) {
      return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
    };
  }(),
  applyMatrix3: function(m2) {
    var x2 = this.x, y = this.y, z2 = this.z;
    var e2 = m2.elements;
    this.x = e2[0] * x2 + e2[3] * y + e2[6] * z2;
    this.y = e2[1] * x2 + e2[4] * y + e2[7] * z2;
    this.z = e2[2] * x2 + e2[5] * y + e2[8] * z2;
    return this;
  },
  applyMatrix4: function(m2) {
    var x2 = this.x, y = this.y, z2 = this.z;
    var e2 = m2.elements;
    var w2 = 1 / (e2[3] * x2 + e2[7] * y + e2[11] * z2 + e2[15]);
    this.x = (e2[0] * x2 + e2[4] * y + e2[8] * z2 + e2[12]) * w2;
    this.y = (e2[1] * x2 + e2[5] * y + e2[9] * z2 + e2[13]) * w2;
    this.z = (e2[2] * x2 + e2[6] * y + e2[10] * z2 + e2[14]) * w2;
    return this;
  },
  applyQuaternion: function(q) {
    var x2 = this.x, y = this.y, z2 = this.z;
    var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    var ix = qw * x2 + qy * z2 - qz * y;
    var iy = qw * y + qz * x2 - qx * z2;
    var iz = qw * z2 + qx * y - qy * x2;
    var iw = -qx * x2 - qy * y - qz * z2;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  },
  project: function(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  },
  unproject: function(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  },
  transformDirection: function(m2) {
    var x2 = this.x, y = this.y, z2 = this.z;
    var e2 = m2.elements;
    this.x = e2[0] * x2 + e2[4] * y + e2[8] * z2;
    this.y = e2[1] * x2 + e2[5] * y + e2[9] * z2;
    this.z = e2[2] * x2 + e2[6] * y + e2[10] * z2;
    return this.normalize();
  },
  divide: function(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    this.z /= v2.z;
    return this;
  },
  divideScalar: function(scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  min: function(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    return this;
  },
  max: function(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    return this;
  },
  clamp: function(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  },
  clampScalar: function(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  },
  clampLength: function(min, max) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  },
  floor: function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  },
  ceil: function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  },
  round: function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  },
  roundToZero: function() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  },
  negate: function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  },
  dot: function(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z;
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function(length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    return this;
  },
  lerpVectors: function(v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },
  cross: function(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
      return this.crossVectors(v2, w2);
    }
    return this.crossVectors(this, v2);
  },
  crossVectors: function(a2, b2) {
    var ax = a2.x, ay = a2.y, az = a2.z;
    var bx = b2.x, by = b2.y, bz = b2.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  },
  projectOnVector: function(vector) {
    var scalar = vector.dot(this) / vector.lengthSq();
    return this.copy(vector).multiplyScalar(scalar);
  },
  projectOnPlane: function() {
    var v1 = new Vector3();
    return function projectOnPlane(planeNormal) {
      v1.copy(this).projectOnVector(planeNormal);
      return this.sub(v1);
    };
  }(),
  reflect: function() {
    var v1 = new Vector3();
    return function reflect(normal) {
      return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
    };
  }(),
  angleTo: function(v2) {
    var theta = this.dot(v2) / Math.sqrt(this.lengthSq() * v2.lengthSq());
    return Math.acos(_Math.clamp(theta, -1, 1));
  },
  distanceTo: function(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  },
  distanceToSquared: function(v2) {
    var dx = this.x - v2.x, dy = this.y - v2.y, dz = this.z - v2.z;
    return dx * dx + dy * dy + dz * dz;
  },
  manhattanDistanceTo: function(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y) + Math.abs(this.z - v2.z);
  },
  setFromSpherical: function(s2) {
    return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
  },
  setFromSphericalCoords: function(radius, phi, theta) {
    var sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  },
  setFromCylindrical: function(c2) {
    return this.setFromCylindricalCoords(c2.radius, c2.theta, c2.y);
  },
  setFromCylindricalCoords: function(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  },
  setFromMatrixPosition: function(m2) {
    var e2 = m2.elements;
    this.x = e2[12];
    this.y = e2[13];
    this.z = e2[14];
    return this;
  },
  setFromMatrixScale: function(m2) {
    var sx = this.setFromMatrixColumn(m2, 0).length();
    var sy = this.setFromMatrixColumn(m2, 1).length();
    var sz = this.setFromMatrixColumn(m2, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  },
  setFromMatrixColumn: function(m2, index2) {
    return this.fromArray(m2.elements, index2 * 4);
  },
  equals: function(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z;
  },
  fromArray: function(array, offset2) {
    if (offset2 === void 0)
      offset2 = 0;
    this.x = array[offset2];
    this.y = array[offset2 + 1];
    this.z = array[offset2 + 2];
    return this;
  },
  toArray: function(array, offset2) {
    if (array === void 0)
      array = [];
    if (offset2 === void 0)
      offset2 = 0;
    array[offset2] = this.x;
    array[offset2 + 1] = this.y;
    array[offset2 + 2] = this.z;
    return array;
  },
  fromBufferAttribute: function(attribute, index2, offset2) {
    if (offset2 !== void 0) {
      console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index2);
    this.y = attribute.getY(index2);
    this.z = attribute.getZ(index2);
    return this;
  }
});
function Matrix3() {
  this.elements = [
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1
  ];
  if (arguments.length > 0) {
    console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
  }
}
Object.assign(Matrix3.prototype, {
  isMatrix3: true,
  set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    var te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  },
  identity: function() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  },
  clone: function() {
    return new this.constructor().fromArray(this.elements);
  },
  copy: function(m2) {
    var te = this.elements;
    var me = m2.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  },
  setFromMatrix4: function(m2) {
    var me = m2.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  },
  applyToBufferAttribute: function() {
    var v1 = new Vector3();
    return function applyToBufferAttribute(attribute) {
      for (var i2 = 0, l2 = attribute.count; i2 < l2; i2++) {
        v1.x = attribute.getX(i2);
        v1.y = attribute.getY(i2);
        v1.z = attribute.getZ(i2);
        v1.applyMatrix3(this);
        attribute.setXYZ(i2, v1.x, v1.y, v1.z);
      }
      return attribute;
    };
  }(),
  multiply: function(m2) {
    return this.multiplyMatrices(this, m2);
  },
  premultiply: function(m2) {
    return this.multiplyMatrices(m2, this);
  },
  multiplyMatrices: function(a2, b2) {
    var ae = a2.elements;
    var be = b2.elements;
    var te = this.elements;
    var a11 = ae[0], a12 = ae[3], a13 = ae[6];
    var a21 = ae[1], a22 = ae[4], a23 = ae[7];
    var a31 = ae[2], a32 = ae[5], a33 = ae[8];
    var b11 = be[0], b12 = be[3], b13 = be[6];
    var b21 = be[1], b22 = be[4], b23 = be[7];
    var b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  },
  multiplyScalar: function(s2) {
    var te = this.elements;
    te[0] *= s2;
    te[3] *= s2;
    te[6] *= s2;
    te[1] *= s2;
    te[4] *= s2;
    te[7] *= s2;
    te[2] *= s2;
    te[5] *= s2;
    te[8] *= s2;
    return this;
  },
  determinant: function() {
    var te = this.elements;
    var a2 = te[0], b2 = te[1], c2 = te[2], d2 = te[3], e2 = te[4], f2 = te[5], g2 = te[6], h2 = te[7], i2 = te[8];
    return a2 * e2 * i2 - a2 * f2 * h2 - b2 * d2 * i2 + b2 * f2 * g2 + c2 * d2 * h2 - c2 * e2 * g2;
  },
  getInverse: function(matrix, throwOnDegenerate) {
    if (matrix && matrix.isMatrix4) {
      console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
    }
    var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) {
      var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
      if (throwOnDegenerate === true) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }
      return this.identity();
    }
    var detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  },
  transpose: function() {
    var tmp2, m2 = this.elements;
    tmp2 = m2[1];
    m2[1] = m2[3];
    m2[3] = tmp2;
    tmp2 = m2[2];
    m2[2] = m2[6];
    m2[6] = tmp2;
    tmp2 = m2[5];
    m2[5] = m2[7];
    m2[7] = tmp2;
    return this;
  },
  getNormalMatrix: function(matrix4) {
    return this.setFromMatrix4(matrix4).getInverse(this).transpose();
  },
  transposeIntoArray: function(r2) {
    var m2 = this.elements;
    r2[0] = m2[0];
    r2[1] = m2[3];
    r2[2] = m2[6];
    r2[3] = m2[1];
    r2[4] = m2[4];
    r2[5] = m2[7];
    r2[6] = m2[2];
    r2[7] = m2[5];
    r2[8] = m2[8];
    return this;
  },
  setUvTransform: function(tx, ty, sx, sy, rotation, cx, cy) {
    var c2 = Math.cos(rotation);
    var s2 = Math.sin(rotation);
    this.set(sx * c2, sx * s2, -sx * (c2 * cx + s2 * cy) + cx + tx, -sy * s2, sy * c2, -sy * (-s2 * cx + c2 * cy) + cy + ty, 0, 0, 1);
  },
  scale: function(sx, sy) {
    var te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  },
  rotate: function(theta) {
    var c2 = Math.cos(theta);
    var s2 = Math.sin(theta);
    var te = this.elements;
    var a11 = te[0], a12 = te[3], a13 = te[6];
    var a21 = te[1], a22 = te[4], a23 = te[7];
    te[0] = c2 * a11 + s2 * a21;
    te[3] = c2 * a12 + s2 * a22;
    te[6] = c2 * a13 + s2 * a23;
    te[1] = -s2 * a11 + c2 * a21;
    te[4] = -s2 * a12 + c2 * a22;
    te[7] = -s2 * a13 + c2 * a23;
    return this;
  },
  translate: function(tx, ty) {
    var te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  },
  equals: function(matrix) {
    var te = this.elements;
    var me = matrix.elements;
    for (var i2 = 0; i2 < 9; i2++) {
      if (te[i2] !== me[i2])
        return false;
    }
    return true;
  },
  fromArray: function(array, offset2) {
    if (offset2 === void 0)
      offset2 = 0;
    for (var i2 = 0; i2 < 9; i2++) {
      this.elements[i2] = array[i2 + offset2];
    }
    return this;
  },
  toArray: function(array, offset2) {
    if (array === void 0)
      array = [];
    if (offset2 === void 0)
      offset2 = 0;
    var te = this.elements;
    array[offset2] = te[0];
    array[offset2 + 1] = te[1];
    array[offset2 + 2] = te[2];
    array[offset2 + 3] = te[3];
    array[offset2 + 4] = te[4];
    array[offset2 + 5] = te[5];
    array[offset2 + 6] = te[6];
    array[offset2 + 7] = te[7];
    array[offset2 + 8] = te[8];
    return array;
  }
});
var _canvas;
var ImageUtils = {
  getDataURL: function(image) {
    var canvas;
    if (typeof HTMLCanvasElement == "undefined") {
      return image.src;
    } else if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0)
        _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      var context2 = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context2.putImageData(image, 0, 0);
      } else {
        context2.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
};
var textureId = 0;
function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
  Object.defineProperty(this, "id", { value: textureId++ });
  this.uuid = _Math.generateUUID();
  this.name = "";
  this.image = image !== void 0 ? image : Texture.DEFAULT_IMAGE;
  this.mipmaps = [];
  this.mapping = mapping !== void 0 ? mapping : Texture.DEFAULT_MAPPING;
  this.wrapS = wrapS !== void 0 ? wrapS : ClampToEdgeWrapping;
  this.wrapT = wrapT !== void 0 ? wrapT : ClampToEdgeWrapping;
  this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
  this.minFilter = minFilter !== void 0 ? minFilter : LinearMipMapLinearFilter;
  this.anisotropy = anisotropy !== void 0 ? anisotropy : 1;
  this.format = format !== void 0 ? format : RGBAFormat;
  this.type = type !== void 0 ? type : UnsignedByteType;
  this.offset = new Vector2(0, 0);
  this.repeat = new Vector2(1, 1);
  this.center = new Vector2(0, 0);
  this.rotation = 0;
  this.matrixAutoUpdate = true;
  this.matrix = new Matrix3();
  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4;
  this.encoding = encoding !== void 0 ? encoding : LinearEncoding;
  this.version = 0;
  this.onUpdate = null;
}
Texture.DEFAULT_IMAGE = void 0;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Texture,
  isTexture: true,
  updateMatrix: function() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  },
  toJSON: function(meta) {
    var isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    var output = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      var image = this.image;
      if (image.uuid === void 0) {
        image.uuid = _Math.generateUUID();
      }
      if (!isRootObject && meta.images[image.uuid] === void 0) {
        var url;
        if (Array.isArray(image)) {
          url = [];
          for (var i2 = 0, l2 = image.length; i2 < l2; i2++) {
            url.push(ImageUtils.getDataURL(image[i2]));
          }
        } else {
          url = ImageUtils.getDataURL(image);
        }
        meta.images[image.uuid] = {
          uuid: image.uuid,
          url
        };
      }
      output.image = image.uuid;
    }
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  },
  transformUv: function(uv) {
    if (this.mapping !== UVMapping)
      return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
});
Object.defineProperty(Texture.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
function Vector4(x2, y, z2, w2) {
  this.x = x2 || 0;
  this.y = y || 0;
  this.z = z2 || 0;
  this.w = w2 !== void 0 ? w2 : 1;
}
Object.assign(Vector4.prototype, {
  isVector4: true,
  set: function(x2, y, z2, w2) {
    this.x = x2;
    this.y = y;
    this.z = z2;
    this.w = w2;
    return this;
  },
  setScalar: function(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  },
  setX: function(x2) {
    this.x = x2;
    return this;
  },
  setY: function(y) {
    this.y = y;
    return this;
  },
  setZ: function(z2) {
    this.z = z2;
    return this;
  },
  setW: function(w2) {
    this.w = w2;
    return this;
  },
  setComponent: function(index2, value) {
    switch (index2) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index2);
    }
    return this;
  },
  getComponent: function(index2) {
    switch (index2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index2);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  },
  copy: function(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    this.w = v2.w !== void 0 ? v2.w : 1;
    return this;
  },
  add: function(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    this.w += v2.w;
    return this;
  },
  addScalar: function(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    this.w += s2;
    return this;
  },
  addVectors: function(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    this.z = a2.z + b2.z;
    this.w = a2.w + b2.w;
    return this;
  },
  addScaledVector: function(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    this.w += v2.w * s2;
    return this;
  },
  sub: function(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    this.w -= v2.w;
    return this;
  },
  subScalar: function(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    this.w -= s2;
    return this;
  },
  subVectors: function(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    this.z = a2.z - b2.z;
    this.w = a2.w - b2.w;
    return this;
  },
  multiplyScalar: function(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  },
  applyMatrix4: function(m2) {
    var x2 = this.x, y = this.y, z2 = this.z, w2 = this.w;
    var e2 = m2.elements;
    this.x = e2[0] * x2 + e2[4] * y + e2[8] * z2 + e2[12] * w2;
    this.y = e2[1] * x2 + e2[5] * y + e2[9] * z2 + e2[13] * w2;
    this.z = e2[2] * x2 + e2[6] * y + e2[10] * z2 + e2[14] * w2;
    this.w = e2[3] * x2 + e2[7] * y + e2[11] * z2 + e2[15] * w2;
    return this;
  },
  divideScalar: function(scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  setAxisAngleFromQuaternion: function(q) {
    this.w = 2 * Math.acos(q.w);
    var s2 = Math.sqrt(1 - q.w * q.w);
    if (s2 < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s2;
      this.y = q.y / s2;
      this.z = q.z / s2;
    }
    return this;
  },
  setAxisAngleFromRotationMatrix: function(m2) {
    var angle, x2, y, z2, epsilon = 0.01, epsilon2 = 0.1, te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      var xx = (m11 + 1) / 2;
      var yy = (m22 + 1) / 2;
      var zz = (m33 + 1) / 2;
      var xy = (m12 + m21) / 4;
      var xz = (m13 + m31) / 4;
      var yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x2 = 0;
          y = 0.707106781;
          z2 = 0.707106781;
        } else {
          x2 = Math.sqrt(xx);
          y = xy / x2;
          z2 = xz / x2;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x2 = 0.707106781;
          y = 0;
          z2 = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x2 = xy / y;
          z2 = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x2 = 0.707106781;
          y = 0.707106781;
          z2 = 0;
        } else {
          z2 = Math.sqrt(zz);
          x2 = xz / z2;
          y = yz / z2;
        }
      }
      this.set(x2, y, z2, angle);
      return this;
    }
    var s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s2) < 1e-3)
      s2 = 1;
    this.x = (m32 - m23) / s2;
    this.y = (m13 - m31) / s2;
    this.z = (m21 - m12) / s2;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  },
  min: function(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    this.w = Math.min(this.w, v2.w);
    return this;
  },
  max: function(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    this.w = Math.max(this.w, v2.w);
    return this;
  },
  clamp: function(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  },
  clampScalar: function() {
    var min, max;
    return function clampScalar(minVal, maxVal) {
      if (min === void 0) {
        min = new Vector4();
        max = new Vector4();
      }
      min.set(minVal, minVal, minVal, minVal);
      max.set(maxVal, maxVal, maxVal, maxVal);
      return this.clamp(min, max);
    };
  }(),
  clampLength: function(min, max) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  },
  floor: function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  },
  ceil: function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  },
  round: function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  },
  roundToZero: function() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  },
  negate: function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  },
  dot: function(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function(length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    this.w += (v2.w - this.w) * alpha;
    return this;
  },
  lerpVectors: function(v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },
  equals: function(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z && v2.w === this.w;
  },
  fromArray: function(array, offset2) {
    if (offset2 === void 0)
      offset2 = 0;
    this.x = array[offset2];
    this.y = array[offset2 + 1];
    this.z = array[offset2 + 2];
    this.w = array[offset2 + 3];
    return this;
  },
  toArray: function(array, offset2) {
    if (array === void 0)
      array = [];
    if (offset2 === void 0)
      offset2 = 0;
    array[offset2] = this.x;
    array[offset2 + 1] = this.y;
    array[offset2 + 2] = this.z;
    array[offset2 + 3] = this.w;
    return array;
  },
  fromBufferAttribute: function(attribute, index2, offset2) {
    if (offset2 !== void 0) {
      console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index2);
    this.y = attribute.getY(index2);
    this.z = attribute.getZ(index2);
    this.w = attribute.getW(index2);
    return this;
  }
});
function WebGLRenderTarget(width, height, options) {
  this.width = width;
  this.height = height;
  this.scissor = new Vector4(0, 0, width, height);
  this.scissorTest = false;
  this.viewport = new Vector4(0, 0, width, height);
  options = options || {};
  this.texture = new Texture(void 0, void 0, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
  this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
  this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
  this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
  this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : true;
  this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
}
WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: WebGLRenderTarget,
  isWebGLRenderTarget: true,
  setSize: function(width, height) {
    if (this.width !== width || this.height !== height) {
      this.width = width;
      this.height = height;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.width = source.width;
    this.height = source.height;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function WebGLMultisampleRenderTarget(width, height, options) {
  WebGLRenderTarget.call(this, width, height, options);
  this.samples = 4;
}
WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
  constructor: WebGLMultisampleRenderTarget,
  isWebGLMultisampleRenderTarget: true,
  copy: function(source) {
    WebGLRenderTarget.prototype.copy.call(this, source);
    this.samples = source.samples;
    return this;
  }
});
function WebGLRenderTargetCube(width, height, options) {
  WebGLRenderTarget.call(this, width, height, options);
}
WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype);
WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;
function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.image = { data, width, height };
  this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
  this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
  this.generateMipmaps = false;
  this.flipY = false;
  this.unpackAlignment = 1;
}
DataTexture.prototype = Object.create(Texture.prototype);
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = true;
function Box3(min, max) {
  this.min = min !== void 0 ? min : new Vector3(Infinity, Infinity, Infinity);
  this.max = max !== void 0 ? max : new Vector3(-Infinity, -Infinity, -Infinity);
}
Object.assign(Box3.prototype, {
  isBox3: true,
  set: function(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  },
  setFromArray: function(array) {
    var minX = Infinity;
    var minY = Infinity;
    var minZ = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    var maxZ = -Infinity;
    for (var i2 = 0, l2 = array.length; i2 < l2; i2 += 3) {
      var x2 = array[i2];
      var y = array[i2 + 1];
      var z2 = array[i2 + 2];
      if (x2 < minX)
        minX = x2;
      if (y < minY)
        minY = y;
      if (z2 < minZ)
        minZ = z2;
      if (x2 > maxX)
        maxX = x2;
      if (y > maxY)
        maxY = y;
      if (z2 > maxZ)
        maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  },
  setFromBufferAttribute: function(attribute) {
    var minX = Infinity;
    var minY = Infinity;
    var minZ = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    var maxZ = -Infinity;
    for (var i2 = 0, l2 = attribute.count; i2 < l2; i2++) {
      var x2 = attribute.getX(i2);
      var y = attribute.getY(i2);
      var z2 = attribute.getZ(i2);
      if (x2 < minX)
        minX = x2;
      if (y < minY)
        minY = y;
      if (z2 < minZ)
        minZ = z2;
      if (x2 > maxX)
        maxX = x2;
      if (y > maxY)
        maxY = y;
      if (z2 > maxZ)
        maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  },
  setFromPoints: function(points) {
    this.makeEmpty();
    for (var i2 = 0, il = points.length; i2 < il; i2++) {
      this.expandByPoint(points[i2]);
    }
    return this;
  },
  setFromCenterAndSize: function() {
    var v1 = new Vector3();
    return function setFromCenterAndSize(center, size) {
      var halfSize = v1.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    };
  }(),
  setFromObject: function(object) {
    this.makeEmpty();
    return this.expandByObject(object);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  },
  isEmpty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  getCenter: function(target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getCenter() target is now required");
      target = new Vector3();
    }
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function(target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getSize() target is now required");
      target = new Vector3();
    }
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  },
  expandByPoint: function(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  },
  expandByObject: function() {
    var scope, i2, l2;
    var v1 = new Vector3();
    function traverse(node) {
      var geometry2 = node.geometry;
      if (geometry2 !== void 0) {
        if (geometry2.isGeometry) {
          var vertices = geometry2.vertices;
          for (i2 = 0, l2 = vertices.length; i2 < l2; i2++) {
            v1.copy(vertices[i2]);
            v1.applyMatrix4(node.matrixWorld);
            scope.expandByPoint(v1);
          }
        } else if (geometry2.isBufferGeometry) {
          var attribute = geometry2.attributes.position;
          if (attribute !== void 0) {
            for (i2 = 0, l2 = attribute.count; i2 < l2; i2++) {
              v1.fromBufferAttribute(attribute, i2).applyMatrix4(node.matrixWorld);
              scope.expandByPoint(v1);
            }
          }
        }
      }
    }
    return function expandByObject(object) {
      scope = this;
      object.updateMatrixWorld(true);
      object.traverse(traverse);
      return this;
    };
  }(),
  containsPoint: function(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  },
  containsBox: function(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  },
  getParameter: function(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getParameter() target is now required");
      target = new Vector3();
    }
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  },
  intersectsBox: function(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  },
  intersectsSphere: function() {
    var closestPoint = new Vector3();
    return function intersectsSphere(sphere) {
      this.clampPoint(sphere.center, closestPoint);
      return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    };
  }(),
  intersectsPlane: function(plane) {
    var min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  },
  intersectsTriangle: function() {
    var v0 = new Vector3();
    var v1 = new Vector3();
    var v2 = new Vector3();
    var f0 = new Vector3();
    var f1 = new Vector3();
    var f2 = new Vector3();
    var testAxis = new Vector3();
    var center = new Vector3();
    var extents = new Vector3();
    var triangleNormal = new Vector3();
    function satForAxes(axes) {
      var i2, j;
      for (i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {
        testAxis.fromArray(axes, i2);
        var r2 = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);
        var p0 = v0.dot(testAxis);
        var p1 = v1.dot(testAxis);
        var p2 = v2.dot(testAxis);
        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r2) {
          return false;
        }
      }
      return true;
    }
    return function intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      }
      this.getCenter(center);
      extents.subVectors(this.max, center);
      v0.subVectors(triangle.a, center);
      v1.subVectors(triangle.b, center);
      v2.subVectors(triangle.c, center);
      f0.subVectors(v1, v0);
      f1.subVectors(v2, v1);
      f2.subVectors(v0, v2);
      var axes = [
        0,
        -f0.z,
        f0.y,
        0,
        -f1.z,
        f1.y,
        0,
        -f2.z,
        f2.y,
        f0.z,
        0,
        -f0.x,
        f1.z,
        0,
        -f1.x,
        f2.z,
        0,
        -f2.x,
        -f0.y,
        f0.x,
        0,
        -f1.y,
        f1.x,
        0,
        -f2.y,
        f2.x,
        0
      ];
      if (!satForAxes(axes)) {
        return false;
      }
      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (!satForAxes(axes)) {
        return false;
      }
      triangleNormal.crossVectors(f0, f1);
      axes = [triangleNormal.x, triangleNormal.y, triangleNormal.z];
      return satForAxes(axes);
    };
  }(),
  clampPoint: function(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .clampPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function() {
    var v1 = new Vector3();
    return function distanceToPoint(point) {
      var clampedPoint = v1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    };
  }(),
  getBoundingSphere: function() {
    var v1 = new Vector3();
    return function getBoundingSphere(target) {
      if (target === void 0) {
        console.error("THREE.Box3: .getBoundingSphere() target is now required");
      }
      this.getCenter(target.center);
      target.radius = this.getSize(v1).length() * 0.5;
      return target;
    };
  }(),
  intersect: function(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty())
      this.makeEmpty();
    return this;
  },
  union: function(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  applyMatrix4: function() {
    var points = [
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3()
    ];
    return function applyMatrix4(matrix) {
      if (this.isEmpty())
        return this;
      points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
      points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
      points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
      points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
      points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
      points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
      points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
      points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
      this.setFromPoints(points);
      return this;
    };
  }(),
  translate: function(offset2) {
    this.min.add(offset2);
    this.max.add(offset2);
    return this;
  },
  equals: function(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
});
function Sphere(center, radius) {
  this.center = center !== void 0 ? center : new Vector3();
  this.radius = radius !== void 0 ? radius : 0;
}
Object.assign(Sphere.prototype, {
  set: function(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  },
  setFromPoints: function() {
    var box = new Box3();
    return function setFromPoints(points, optionalCenter) {
      var center = this.center;
      if (optionalCenter !== void 0) {
        center.copy(optionalCenter);
      } else {
        box.setFromPoints(points).getCenter(center);
      }
      var maxRadiusSq = 0;
      for (var i2 = 0, il = points.length; i2 < il; i2++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
      }
      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    };
  }(),
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  },
  empty: function() {
    return this.radius <= 0;
  },
  containsPoint: function(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function(point) {
    return point.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function(sphere) {
    var radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  },
  intersectsBox: function(box) {
    return box.intersectsSphere(this);
  },
  intersectsPlane: function(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  },
  clampPoint: function(point, target) {
    var deltaLengthSq = this.center.distanceToSquared(point);
    if (target === void 0) {
      console.warn("THREE.Sphere: .clampPoint() target is now required");
      target = new Vector3();
    }
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  },
  getBoundingBox: function(target) {
    if (target === void 0) {
      console.warn("THREE.Sphere: .getBoundingBox() target is now required");
      target = new Box3();
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  },
  applyMatrix4: function(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  },
  translate: function(offset2) {
    this.center.add(offset2);
    return this;
  },
  equals: function(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
});
function Plane(normal, constant) {
  this.normal = normal !== void 0 ? normal : new Vector3(1, 0, 0);
  this.constant = constant !== void 0 ? constant : 0;
}
Object.assign(Plane.prototype, {
  set: function(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  },
  setComponents: function(x2, y, z2, w2) {
    this.normal.set(x2, y, z2);
    this.constant = w2;
    return this;
  },
  setFromNormalAndCoplanarPoint: function(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  },
  setFromCoplanarPoints: function() {
    var v1 = new Vector3();
    var v2 = new Vector3();
    return function setFromCoplanarPoints(a2, b2, c2) {
      var normal = v1.subVectors(c2, b2).cross(v2.subVectors(a2, b2)).normalize();
      this.setFromNormalAndCoplanarPoint(normal, a2);
      return this;
    };
  }(),
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  },
  normalize: function() {
    var inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  },
  negate: function() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  },
  distanceToPoint: function(point) {
    return this.normal.dot(point) + this.constant;
  },
  distanceToSphere: function(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  },
  projectPoint: function(point, target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .projectPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  },
  intersectLine: function() {
    var v1 = new Vector3();
    return function intersectLine(line, target) {
      if (target === void 0) {
        console.warn("THREE.Plane: .intersectLine() target is now required");
        target = new Vector3();
      }
      var direction = line.delta(v1);
      var denominator = this.normal.dot(direction);
      if (denominator === 0) {
        if (this.distanceToPoint(line.start) === 0) {
          return target.copy(line.start);
        }
        return void 0;
      }
      var t2 = -(line.start.dot(this.normal) + this.constant) / denominator;
      if (t2 < 0 || t2 > 1) {
        return void 0;
      }
      return target.copy(direction).multiplyScalar(t2).add(line.start);
    };
  }(),
  intersectsLine: function(line) {
    var startSign = this.distanceToPoint(line.start);
    var endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  },
  intersectsBox: function(box) {
    return box.intersectsPlane(this);
  },
  intersectsSphere: function(sphere) {
    return sphere.intersectsPlane(this);
  },
  coplanarPoint: function(target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .coplanarPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function() {
    var v1 = new Vector3();
    var m1 = new Matrix3();
    return function applyMatrix4(matrix, optionalNormalMatrix) {
      var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
      var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
      var normal = this.normal.applyMatrix3(normalMatrix).normalize();
      this.constant = -referencePoint.dot(normal);
      return this;
    };
  }(),
  translate: function(offset2) {
    this.constant -= offset2.dot(this.normal);
    return this;
  },
  equals: function(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
});
function Frustum(p0, p1, p2, p3, p4, p5) {
  this.planes = [
    p0 !== void 0 ? p0 : new Plane(),
    p1 !== void 0 ? p1 : new Plane(),
    p2 !== void 0 ? p2 : new Plane(),
    p3 !== void 0 ? p3 : new Plane(),
    p4 !== void 0 ? p4 : new Plane(),
    p5 !== void 0 ? p5 : new Plane()
  ];
}
Object.assign(Frustum.prototype, {
  set: function(p0, p1, p2, p3, p4, p5) {
    var planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(frustum) {
    var planes = this.planes;
    for (var i2 = 0; i2 < 6; i2++) {
      planes[i2].copy(frustum.planes[i2]);
    }
    return this;
  },
  setFromMatrix: function(m2) {
    var planes = this.planes;
    var me = m2.elements;
    var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  },
  intersectsObject: function() {
    var sphere = new Sphere();
    return function intersectsObject(object) {
      var geometry2 = object.geometry;
      if (geometry2.boundingSphere === null)
        geometry2.computeBoundingSphere();
      sphere.copy(geometry2.boundingSphere).applyMatrix4(object.matrixWorld);
      return this.intersectsSphere(sphere);
    };
  }(),
  intersectsSprite: function() {
    var sphere = new Sphere();
    return function intersectsSprite(sprite) {
      sphere.center.set(0, 0, 0);
      sphere.radius = 0.7071067811865476;
      sphere.applyMatrix4(sprite.matrixWorld);
      return this.intersectsSphere(sphere);
    };
  }(),
  intersectsSphere: function(sphere) {
    var planes = this.planes;
    var center = sphere.center;
    var negRadius = -sphere.radius;
    for (var i2 = 0; i2 < 6; i2++) {
      var distance = planes[i2].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  },
  intersectsBox: function() {
    var p2 = new Vector3();
    return function intersectsBox(box) {
      var planes = this.planes;
      for (var i2 = 0; i2 < 6; i2++) {
        var plane = planes[i2];
        p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
        if (plane.distanceToPoint(p2) < 0) {
          return false;
        }
      }
      return true;
    };
  }(),
  containsPoint: function(point) {
    var planes = this.planes;
    for (var i2 = 0; i2 < 6; i2++) {
      if (planes[i2].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
});
function Matrix4() {
  this.elements = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ];
  if (arguments.length > 0) {
    console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
  }
}
Object.assign(Matrix4.prototype, {
  isMatrix4: true,
  set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    var te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  },
  identity: function() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  clone: function() {
    return new Matrix4().fromArray(this.elements);
  },
  copy: function(m2) {
    var te = this.elements;
    var me = m2.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  },
  copyPosition: function(m2) {
    var te = this.elements, me = m2.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  },
  extractBasis: function(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  },
  makeBasis: function(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  },
  extractRotation: function() {
    var v1 = new Vector3();
    return function extractRotation(m2) {
      var te = this.elements;
      var me = m2.elements;
      var scaleX2 = 1 / v1.setFromMatrixColumn(m2, 0).length();
      var scaleY2 = 1 / v1.setFromMatrixColumn(m2, 1).length();
      var scaleZ = 1 / v1.setFromMatrixColumn(m2, 2).length();
      te[0] = me[0] * scaleX2;
      te[1] = me[1] * scaleX2;
      te[2] = me[2] * scaleX2;
      te[3] = 0;
      te[4] = me[4] * scaleY2;
      te[5] = me[5] * scaleY2;
      te[6] = me[6] * scaleY2;
      te[7] = 0;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    };
  }(),
  makeRotationFromEuler: function(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    }
    var te = this.elements;
    var x2 = euler.x, y = euler.y, z2 = euler.z;
    var a2 = Math.cos(x2), b2 = Math.sin(x2);
    var c2 = Math.cos(y), d2 = Math.sin(y);
    var e2 = Math.cos(z2), f2 = Math.sin(z2);
    if (euler.order === "XYZ") {
      var ae = a2 * e2, af = a2 * f2, be = b2 * e2, bf = b2 * f2;
      te[0] = c2 * e2;
      te[4] = -c2 * f2;
      te[8] = d2;
      te[1] = af + be * d2;
      te[5] = ae - bf * d2;
      te[9] = -b2 * c2;
      te[2] = bf - ae * d2;
      te[6] = be + af * d2;
      te[10] = a2 * c2;
    } else if (euler.order === "YXZ") {
      var ce = c2 * e2, cf = c2 * f2, de = d2 * e2, df = d2 * f2;
      te[0] = ce + df * b2;
      te[4] = de * b2 - cf;
      te[8] = a2 * d2;
      te[1] = a2 * f2;
      te[5] = a2 * e2;
      te[9] = -b2;
      te[2] = cf * b2 - de;
      te[6] = df + ce * b2;
      te[10] = a2 * c2;
    } else if (euler.order === "ZXY") {
      var ce = c2 * e2, cf = c2 * f2, de = d2 * e2, df = d2 * f2;
      te[0] = ce - df * b2;
      te[4] = -a2 * f2;
      te[8] = de + cf * b2;
      te[1] = cf + de * b2;
      te[5] = a2 * e2;
      te[9] = df - ce * b2;
      te[2] = -a2 * d2;
      te[6] = b2;
      te[10] = a2 * c2;
    } else if (euler.order === "ZYX") {
      var ae = a2 * e2, af = a2 * f2, be = b2 * e2, bf = b2 * f2;
      te[0] = c2 * e2;
      te[4] = be * d2 - af;
      te[8] = ae * d2 + bf;
      te[1] = c2 * f2;
      te[5] = bf * d2 + ae;
      te[9] = af * d2 - be;
      te[2] = -d2;
      te[6] = b2 * c2;
      te[10] = a2 * c2;
    } else if (euler.order === "YZX") {
      var ac = a2 * c2, ad = a2 * d2, bc = b2 * c2, bd = b2 * d2;
      te[0] = c2 * e2;
      te[4] = bd - ac * f2;
      te[8] = bc * f2 + ad;
      te[1] = f2;
      te[5] = a2 * e2;
      te[9] = -b2 * e2;
      te[2] = -d2 * e2;
      te[6] = ad * f2 + bc;
      te[10] = ac - bd * f2;
    } else if (euler.order === "XZY") {
      var ac = a2 * c2, ad = a2 * d2, bc = b2 * c2, bd = b2 * d2;
      te[0] = c2 * e2;
      te[4] = -f2;
      te[8] = d2 * e2;
      te[1] = ac * f2 + bd;
      te[5] = a2 * e2;
      te[9] = ad * f2 - bc;
      te[2] = bc * f2 - ad;
      te[6] = b2 * e2;
      te[10] = bd * f2 + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  },
  makeRotationFromQuaternion: function() {
    var zero = new Vector3(0, 0, 0);
    var one = new Vector3(1, 1, 1);
    return function makeRotationFromQuaternion(q) {
      return this.compose(zero, q, one);
    };
  }(),
  lookAt: function() {
    var x2 = new Vector3();
    var y = new Vector3();
    var z2 = new Vector3();
    return function lookAt(eye, target, up) {
      var te = this.elements;
      z2.subVectors(eye, target);
      if (z2.lengthSq() === 0) {
        z2.z = 1;
      }
      z2.normalize();
      x2.crossVectors(up, z2);
      if (x2.lengthSq() === 0) {
        if (Math.abs(up.z) === 1) {
          z2.x += 1e-4;
        } else {
          z2.z += 1e-4;
        }
        z2.normalize();
        x2.crossVectors(up, z2);
      }
      x2.normalize();
      y.crossVectors(z2, x2);
      te[0] = x2.x;
      te[4] = y.x;
      te[8] = z2.x;
      te[1] = x2.y;
      te[5] = y.y;
      te[9] = z2.y;
      te[2] = x2.z;
      te[6] = y.z;
      te[10] = z2.z;
      return this;
    };
  }(),
  multiply: function(m2, n2) {
    if (n2 !== void 0) {
      console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
      return this.multiplyMatrices(m2, n2);
    }
    return this.multiplyMatrices(this, m2);
  },
  premultiply: function(m2) {
    return this.multiplyMatrices(m2, this);
  },
  multiplyMatrices: function(a2, b2) {
    var ae = a2.elements;
    var be = b2.elements;
    var te = this.elements;
    var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  },
  multiplyScalar: function(s2) {
    var te = this.elements;
    te[0] *= s2;
    te[4] *= s2;
    te[8] *= s2;
    te[12] *= s2;
    te[1] *= s2;
    te[5] *= s2;
    te[9] *= s2;
    te[13] *= s2;
    te[2] *= s2;
    te[6] *= s2;
    te[10] *= s2;
    te[14] *= s2;
    te[3] *= s2;
    te[7] *= s2;
    te[11] *= s2;
    te[15] *= s2;
    return this;
  },
  applyToBufferAttribute: function() {
    var v1 = new Vector3();
    return function applyToBufferAttribute(attribute) {
      for (var i2 = 0, l2 = attribute.count; i2 < l2; i2++) {
        v1.x = attribute.getX(i2);
        v1.y = attribute.getY(i2);
        v1.z = attribute.getZ(i2);
        v1.applyMatrix4(this);
        attribute.setXYZ(i2, v1.x, v1.y, v1.z);
      }
      return attribute;
    };
  }(),
  determinant: function() {
    var te = this.elements;
    var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  },
  transpose: function() {
    var te = this.elements;
    var tmp2;
    tmp2 = te[1];
    te[1] = te[4];
    te[4] = tmp2;
    tmp2 = te[2];
    te[2] = te[8];
    te[8] = tmp2;
    tmp2 = te[6];
    te[6] = te[9];
    te[9] = tmp2;
    tmp2 = te[3];
    te[3] = te[12];
    te[12] = tmp2;
    tmp2 = te[7];
    te[7] = te[13];
    te[13] = tmp2;
    tmp2 = te[11];
    te[11] = te[14];
    te[14] = tmp2;
    return this;
  },
  setPosition: function(x2, y, z2) {
    var te = this.elements;
    if (x2.isVector3) {
      te[12] = x2.x;
      te[13] = x2.y;
      te[14] = x2.z;
    } else {
      te[12] = x2;
      te[13] = y;
      te[14] = z2;
    }
    return this;
  },
  getInverse: function(m2, throwOnDegenerate) {
    var te = this.elements, me = m2.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) {
      var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
      if (throwOnDegenerate === true) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }
      return this.identity();
    }
    var detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  },
  scale: function(v2) {
    var te = this.elements;
    var x2 = v2.x, y = v2.y, z2 = v2.z;
    te[0] *= x2;
    te[4] *= y;
    te[8] *= z2;
    te[1] *= x2;
    te[5] *= y;
    te[9] *= z2;
    te[2] *= x2;
    te[6] *= y;
    te[10] *= z2;
    te[3] *= x2;
    te[7] *= y;
    te[11] *= z2;
    return this;
  },
  getMaxScaleOnAxis: function() {
    var te = this.elements;
    var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  },
  makeTranslation: function(x2, y, z2) {
    this.set(1, 0, 0, x2, 0, 1, 0, y, 0, 0, 1, z2, 0, 0, 0, 1);
    return this;
  },
  makeRotationX: function(theta) {
    var c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationY: function(theta) {
    var c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(c2, 0, s2, 0, 0, 1, 0, 0, -s2, 0, c2, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationZ: function(theta) {
    var c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationAxis: function(axis, angle) {
    var c2 = Math.cos(angle);
    var s2 = Math.sin(angle);
    var t2 = 1 - c2;
    var x2 = axis.x, y = axis.y, z2 = axis.z;
    var tx = t2 * x2, ty = t2 * y;
    this.set(tx * x2 + c2, tx * y - s2 * z2, tx * z2 + s2 * y, 0, tx * y + s2 * z2, ty * y + c2, ty * z2 - s2 * x2, 0, tx * z2 - s2 * y, ty * z2 + s2 * x2, t2 * z2 * z2 + c2, 0, 0, 0, 0, 1);
    return this;
  },
  makeScale: function(x2, y, z2) {
    this.set(x2, 0, 0, 0, 0, y, 0, 0, 0, 0, z2, 0, 0, 0, 0, 1);
    return this;
  },
  makeShear: function(x2, y, z2) {
    this.set(1, y, z2, 0, x2, 1, z2, 0, x2, y, 1, 0, 0, 0, 0, 1);
    return this;
  },
  compose: function(position, quaternion, scale2) {
    var te = this.elements;
    var x2 = quaternion._x, y = quaternion._y, z2 = quaternion._z, w2 = quaternion._w;
    var x22 = x2 + x2, y2 = y + y, z22 = z2 + z2;
    var xx = x2 * x22, xy = x2 * y2, xz = x2 * z22;
    var yy = y * y2, yz = y * z22, zz = z2 * z22;
    var wx = w2 * x22, wy = w2 * y2, wz = w2 * z22;
    var sx = scale2.x, sy = scale2.y, sz = scale2.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  },
  decompose: function() {
    var vector = new Vector3();
    var matrix = new Matrix4();
    return function decompose(position, quaternion, scale2) {
      var te = this.elements;
      var sx = vector.set(te[0], te[1], te[2]).length();
      var sy = vector.set(te[4], te[5], te[6]).length();
      var sz = vector.set(te[8], te[9], te[10]).length();
      var det = this.determinant();
      if (det < 0)
        sx = -sx;
      position.x = te[12];
      position.y = te[13];
      position.z = te[14];
      matrix.copy(this);
      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;
      matrix.elements[0] *= invSX;
      matrix.elements[1] *= invSX;
      matrix.elements[2] *= invSX;
      matrix.elements[4] *= invSY;
      matrix.elements[5] *= invSY;
      matrix.elements[6] *= invSY;
      matrix.elements[8] *= invSZ;
      matrix.elements[9] *= invSZ;
      matrix.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(matrix);
      scale2.x = sx;
      scale2.y = sy;
      scale2.z = sz;
      return this;
    };
  }(),
  makePerspective: function(left, right, top, bottom, near, far) {
    if (far === void 0) {
      console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    }
    var te = this.elements;
    var x2 = 2 * near / (right - left);
    var y = 2 * near / (top - bottom);
    var a2 = (right + left) / (right - left);
    var b2 = (top + bottom) / (top - bottom);
    var c2 = -(far + near) / (far - near);
    var d2 = -2 * far * near / (far - near);
    te[0] = x2;
    te[4] = 0;
    te[8] = a2;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b2;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c2;
    te[14] = d2;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  },
  makeOrthographic: function(left, right, top, bottom, near, far) {
    var te = this.elements;
    var w2 = 1 / (right - left);
    var h2 = 1 / (top - bottom);
    var p2 = 1 / (far - near);
    var x2 = (right + left) * w2;
    var y = (top + bottom) * h2;
    var z2 = (far + near) * p2;
    te[0] = 2 * w2;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x2;
    te[1] = 0;
    te[5] = 2 * h2;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p2;
    te[14] = -z2;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  },
  equals: function(matrix) {
    var te = this.elements;
    var me = matrix.elements;
    for (var i2 = 0; i2 < 16; i2++) {
      if (te[i2] !== me[i2])
        return false;
    }
    return true;
  },
  fromArray: function(array, offset2) {
    if (offset2 === void 0)
      offset2 = 0;
    for (var i2 = 0; i2 < 16; i2++) {
      this.elements[i2] = array[i2 + offset2];
    }
    return this;
  },
  toArray: function(array, offset2) {
    if (array === void 0)
      array = [];
    if (offset2 === void 0)
      offset2 = 0;
    var te = this.elements;
    array[offset2] = te[0];
    array[offset2 + 1] = te[1];
    array[offset2 + 2] = te[2];
    array[offset2 + 3] = te[3];
    array[offset2 + 4] = te[4];
    array[offset2 + 5] = te[5];
    array[offset2 + 6] = te[6];
    array[offset2 + 7] = te[7];
    array[offset2 + 8] = te[8];
    array[offset2 + 9] = te[9];
    array[offset2 + 10] = te[10];
    array[offset2 + 11] = te[11];
    array[offset2 + 12] = te[12];
    array[offset2 + 13] = te[13];
    array[offset2 + 14] = te[14];
    array[offset2 + 15] = te[15];
    return array;
  }
});
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE  = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS  = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n		varying vec3 vViewPosition;\n	#endif\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n	varying vec3 vViewPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n	vViewPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
var color_vertex = "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif";
var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n	vec3 absDirection = abs(direction);\n	int face = -1;\n	if( absDirection.x > absDirection.z ) {\n		if(absDirection.x > absDirection.y )\n			face = direction.x > 0.0 ? 0 : 3;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	else {\n		if(absDirection.z > absDirection.y )\n			face = direction.z > 0.0 ? 2 : 5;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n	float dxRoughness = dFdx(roughness);\n	float dyRoughness = dFdy(roughness);\n	vec3 dx = dFdx( vec * scale * dxRoughness );\n	vec3 dy = dFdy( vec * scale * dyRoughness );\n	float d = max( dot( dx, dx ), dot( dy, dy ) );\n	d = clamp(d, 1.0, cubeUV_rangeClamp);\n	float mipLevel = 0.5 * log2(d);\n	return vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n	float a = 16.0 * cubeUV_rcpTextureSize;\n	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n	float powScale = exp2_packed.x * exp2_packed.y;\n	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n	bool bRes = mipLevel == 0.0;\n	scale =  bRes && (scale < a) ? a : scale;\n	vec3 r;\n	vec2 offset;\n	int face = getFaceFromDirection(direction);\n	float rcpPowScale = 1.0 / powScale;\n	if( face == 0) {\n		r = vec3(direction.x, -direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 1) {\n		r = vec3(direction.y, direction.x, direction.z);\n		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 2) {\n		r = vec3(direction.z, direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 3) {\n		r = vec3(direction.x, direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	else if( face == 4) {\n		r = vec3(direction.y, direction.x, -direction.z);\n		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	else {\n		r = vec3(direction.z, -direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	r = normalize(r);\n	float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n	vec2 base = offset + vec2( texelOffset );\n	return base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n	float roughnessVal = roughness* cubeUV_maxLods3;\n	float r1 = floor(roughnessVal);\n	float r2 = r1 + 1.0;\n	float t = fract(roughnessVal);\n	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n	float s = mipInfo.y;\n	float level0 = mipInfo.x;\n	float level1 = level0 + 1.0;\n	level1 = level1 > 5.0 ? 5.0 : level1;\n	level0 += min( floor( s + 0.5 ), 5.0 );\n	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n	vec4 result = mix(color10, color20, t);\n	return vec4(result.rgb, 1.0);\n}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = normalMatrix * objectTangent;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = min( floor( D ) / 255.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		reflectVec = normalize( reflectVec );\n		sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n		sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		reflectVec = normalize( reflectVec );\n		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	envColor = envMapTexelToLinear( envColor );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n	uniform float reflectivity;\n	uniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n		varying vec3 vWorldPosition;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	fogDepth = -mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float fogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef TOON\n	uniform sampler2D gradientMap;\n	vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n		float dotNL = dot( normal, lightDirection );\n		vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n		#ifdef USE_GRADIENTMAP\n			return texture2D( gradientMap, coord ).rgb;\n		#else\n			return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n		#endif\n	}\n#endif";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif";
var lights_pars_begin = "uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n		float shadowCameraNear;\n		float shadowCameraFar;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	#ifdef TOON\n		vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#else\n		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n		vec3 irradiance = dotNL * directLight.color;\n	#endif\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n	#ifndef STANDARD\n		float clearCoat;\n		float clearCoatRoughness;\n	#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifndef STANDARD\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	#ifndef STANDARD\n		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifndef STANDARD\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		float dotNL = dotNV;\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	float clearCoatInv = 1.0 - clearCoatDHR;\n	#if defined( ENVMAP_TYPE_CUBE_UV )\n		vec3 singleScattering = vec3( 0.0 );\n		vec3 multiScattering = vec3( 0.0 );\n		vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n		BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n		vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n		reflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n		reflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n		reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n	#else\n		reflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n	#endif\n	#ifndef STANDARD\n		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearCoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n		irradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n	#ifndef STANDARD\n		clearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n		gl_Position.z *= gl_Position.w;\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#ifdef USE_MAP\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif";
var map_particle_pars_fragment = "#ifdef USE_MAP\n	uniform mat3 uvTransform;\n	uniform sampler2D map;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif";
var normal_fragment_begin = "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#endif\n	#endif\n#endif";
var normal_fragment_maps = "#ifdef USE_NORMALMAP\n	#ifdef OBJECTSPACE_NORMALMAP\n		normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		#ifdef FLIP_SIDED\n			normal = - normal;\n		#endif\n		#ifdef DOUBLE_SIDED\n			normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#endif\n		normal = normalize( normalMatrix * normal );\n	#else\n		#ifdef USE_TANGENT\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n			vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n			mapN.xy = normalScale * mapN.xy;\n			normal = normalize( vTBN * mapN );\n		#else\n			normal = perturbNormal2Arb( -vViewPosition, normal );\n		#endif\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	#ifdef OBJECTSPACE_NORMALMAP\n		uniform mat3 normalMatrix;\n	#else\n		vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n			vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n			vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n			vec2 st0 = dFdx( vUv.st );\n			vec2 st1 = dFdy( vUv.st );\n			float scale = sign( st1.t * st0.s - st0.t * st1.s );\n			vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n			vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n			vec3 N = normalize( surf_norm );\n			mat3 tsn = mat3( S, T, N );\n			vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n			mapN.xy *= normalScale;\n			mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n			return normalize( tsn * mapN );\n		}\n	#endif\n#endif";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#if defined( DITHERING )\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#if defined( DITHERING )\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			shadow = (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n	#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";
var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif";
var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif";
var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = mapTexelToLinear( texColor );\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n	#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV;\n	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n	uniform float clearCoat;\n	uniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <fog_fragment>\n}";
var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normalmap_pars_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_frag,
  background_vert,
  cube_frag,
  cube_vert,
  depth_frag,
  depth_vert,
  distanceRGBA_frag,
  distanceRGBA_vert,
  equirect_frag,
  equirect_vert,
  linedashed_frag,
  linedashed_vert,
  meshbasic_frag,
  meshbasic_vert,
  meshlambert_frag,
  meshlambert_vert,
  meshmatcap_frag,
  meshmatcap_vert,
  meshphong_frag,
  meshphong_vert,
  meshphysical_frag,
  meshphysical_vert,
  normal_frag,
  normal_vert,
  points_frag,
  points_vert,
  shadow_frag,
  shadow_vert,
  sprite_frag,
  sprite_vert
};
function cloneUniforms(src) {
  var dst = {};
  for (var u2 in src) {
    dst[u2] = {};
    for (var p2 in src[u2]) {
      var property = src[u2][p2];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) {
        dst[u2][p2] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u2][p2] = property.slice();
      } else {
        dst[u2][p2] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  var merged = {};
  for (var u2 = 0; u2 < uniforms.length; u2++) {
    var tmp2 = cloneUniforms(uniforms[u2]);
    for (var p2 in tmp2) {
      merged[p2] = tmp2[p2];
    }
  }
  return merged;
}
var ColorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
function Color(r2, g2, b2) {
  if (g2 === void 0 && b2 === void 0) {
    return this.set(r2);
  }
  return this.setRGB(r2, g2, b2);
}
Object.assign(Color.prototype, {
  isColor: true,
  r: 1,
  g: 1,
  b: 1,
  set: function(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === "number") {
      this.setHex(value);
    } else if (typeof value === "string") {
      this.setStyle(value);
    }
    return this;
  },
  setScalar: function(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  },
  setHex: function(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  },
  setRGB: function(r2, g2, b2) {
    this.r = r2;
    this.g = g2;
    this.b = b2;
    return this;
  },
  setHSL: function() {
    function hue2rgb(p2, q, t2) {
      if (t2 < 0)
        t2 += 1;
      if (t2 > 1)
        t2 -= 1;
      if (t2 < 1 / 6)
        return p2 + (q - p2) * 6 * t2;
      if (t2 < 1 / 2)
        return q;
      if (t2 < 2 / 3)
        return p2 + (q - p2) * 6 * (2 / 3 - t2);
      return p2;
    }
    return function setHSL(h2, s2, l2) {
      h2 = _Math.euclideanModulo(h2, 1);
      s2 = _Math.clamp(s2, 0, 1);
      l2 = _Math.clamp(l2, 0, 1);
      if (s2 === 0) {
        this.r = this.g = this.b = l2;
      } else {
        var p2 = l2 <= 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
        var q = 2 * l2 - p2;
        this.r = hue2rgb(q, p2, h2 + 1 / 3);
        this.g = hue2rgb(q, p2, h2);
        this.b = hue2rgb(q, p2, h2 - 1 / 3);
      }
      return this;
    };
  }(),
  setStyle: function(style) {
    function handleAlpha(string) {
      if (string === void 0)
        return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    var m2;
    if (m2 = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
      var color;
      var name = m2[1];
      var components = m2[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[5]);
            return this;
          }
          if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[5]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            var h2 = parseFloat(color[1]) / 360;
            var s2 = parseInt(color[2], 10) / 100;
            var l2 = parseInt(color[3], 10) / 100;
            handleAlpha(color[5]);
            return this.setHSL(h2, s2, l2);
          }
          break;
      }
    } else if (m2 = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
      var hex = m2[1];
      var size = hex.length;
      if (size === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }
    if (style && style.length > 0) {
      var hex = ColorKeywords[style];
      if (hex !== void 0) {
        this.setHex(hex);
      } else {
        console.warn("THREE.Color: Unknown color " + style);
      }
    }
    return this;
  },
  clone: function() {
    return new this.constructor(this.r, this.g, this.b);
  },
  copy: function(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  },
  copyGammaToLinear: function(color, gammaFactor) {
    if (gammaFactor === void 0)
      gammaFactor = 2;
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  },
  copyLinearToGamma: function(color, gammaFactor) {
    if (gammaFactor === void 0)
      gammaFactor = 2;
    var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  },
  convertGammaToLinear: function(gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  },
  convertLinearToGamma: function(gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  },
  copySRGBToLinear: function() {
    function SRGBToLinear(c2) {
      return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
    }
    return function copySRGBToLinear(color) {
      this.r = SRGBToLinear(color.r);
      this.g = SRGBToLinear(color.g);
      this.b = SRGBToLinear(color.b);
      return this;
    };
  }(),
  copyLinearToSRGB: function() {
    function LinearToSRGB(c2) {
      return c2 < 31308e-7 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
    }
    return function copyLinearToSRGB(color) {
      this.r = LinearToSRGB(color.r);
      this.g = LinearToSRGB(color.g);
      this.b = LinearToSRGB(color.b);
      return this;
    };
  }(),
  convertSRGBToLinear: function() {
    this.copySRGBToLinear(this);
    return this;
  },
  convertLinearToSRGB: function() {
    this.copyLinearToSRGB(this);
    return this;
  },
  getHex: function() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  },
  getHexString: function() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function(target) {
    if (target === void 0) {
      console.warn("THREE.Color: .getHSL() target is now required");
      target = { h: 0, s: 0, l: 0 };
    }
    var r2 = this.r, g2 = this.g, b2 = this.b;
    var max = Math.max(r2, g2, b2);
    var min = Math.min(r2, g2, b2);
    var hue, saturation;
    var lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      var delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r2:
          hue = (g2 - b2) / delta + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          hue = (b2 - r2) / delta + 2;
          break;
        case b2:
          hue = (r2 - g2) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  },
  getStyle: function() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  },
  offsetHSL: function() {
    var hsl = {};
    return function(h2, s2, l2) {
      this.getHSL(hsl);
      hsl.h += h2;
      hsl.s += s2;
      hsl.l += l2;
      this.setHSL(hsl.h, hsl.s, hsl.l);
      return this;
    };
  }(),
  add: function(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  },
  addColors: function(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  },
  addScalar: function(s2) {
    this.r += s2;
    this.g += s2;
    this.b += s2;
    return this;
  },
  sub: function(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  },
  multiply: function(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  },
  multiplyScalar: function(s2) {
    this.r *= s2;
    this.g *= s2;
    this.b *= s2;
    return this;
  },
  lerp: function(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  },
  lerpHSL: function() {
    var hslA = { h: 0, s: 0, l: 0 };
    var hslB = { h: 0, s: 0, l: 0 };
    return function lerpHSL(color, alpha) {
      this.getHSL(hslA);
      color.getHSL(hslB);
      var h2 = _Math.lerp(hslA.h, hslB.h, alpha);
      var s2 = _Math.lerp(hslA.s, hslB.s, alpha);
      var l2 = _Math.lerp(hslA.l, hslB.l, alpha);
      this.setHSL(h2, s2, l2);
      return this;
    };
  }(),
  equals: function(c2) {
    return c2.r === this.r && c2.g === this.g && c2.b === this.b;
  },
  fromArray: function(array, offset2) {
    if (offset2 === void 0)
      offset2 = 0;
    this.r = array[offset2];
    this.g = array[offset2 + 1];
    this.b = array[offset2 + 2];
    return this;
  },
  toArray: function(array, offset2) {
    if (array === void 0)
      array = [];
    if (offset2 === void 0)
      offset2 = 0;
    array[offset2] = this.r;
    array[offset2 + 1] = this.g;
    array[offset2 + 2] = this.b;
    return array;
  },
  toJSON: function() {
    return this.getHex();
  }
});
var UniformsLib = {
  common: {
    diffuse: { value: new Color(15658734) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new Matrix3() },
    alphaMap: { value: null }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    refractionRatio: { value: 0.98 },
    maxMipLevel: { value: 0 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {},
      shadow: {},
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {},
      shadow: {},
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {},
      shadow: {},
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } }
  },
  points: {
    diffuse: { value: new Color(15658734) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    uvTransform: { value: new Matrix3() }
  },
  sprite: {
    diffuse: { value: new Color(15658734) },
    opacity: { value: 1 },
    center: { value: new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    uvTransform: { value: new Matrix3() }
  }
};
var ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        specular: { value: new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        roughness: { value: 0.5 },
        metalness: { value: 0.5 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Matrix3() },
      t2D: { value: null }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearCoat: { value: 0 },
      clearCoatRoughness: { value: 0 }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLAnimation() {
  var context2 = null;
  var isAnimating = false;
  var animationLoop = null;
  function onAnimationFrame(time, frame) {
    if (isAnimating === false)
      return;
    animationLoop(time, frame);
    context2.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      context2.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context2 = value;
    }
  };
}
function WebGLAttributes(gl) {
  var buffers = new WeakMap();
  function createBuffer(attribute, bufferType) {
    var array = attribute.array;
    var usage = attribute.dynamic ? 35048 : 35044;
    var buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    var type = 5126;
    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Float64Array) {
      console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
    } else if (array instanceof Uint16Array) {
      type = 5123;
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    var array = attribute.array;
    var updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);
    if (attribute.dynamic === false) {
      gl.bufferData(bufferType, array, 35044);
    } else if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else if (updateRange.count === 0) {
      console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.");
    } else {
      gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      updateRange.count = -1;
    }
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove2(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    var data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update3(attribute, bufferType) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    var data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove: remove2,
    update: update3
  };
}
function Face3(a2, b2, c2, normal, color, materialIndex) {
  this.a = a2;
  this.b = b2;
  this.c = c2;
  this.normal = normal && normal.isVector3 ? normal : new Vector3();
  this.vertexNormals = Array.isArray(normal) ? normal : [];
  this.color = color && color.isColor ? color : new Color();
  this.vertexColors = Array.isArray(color) ? color : [];
  this.materialIndex = materialIndex !== void 0 ? materialIndex : 0;
}
Object.assign(Face3.prototype, {
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.a = source.a;
    this.b = source.b;
    this.c = source.c;
    this.normal.copy(source.normal);
    this.color.copy(source.color);
    this.materialIndex = source.materialIndex;
    for (var i2 = 0, il = source.vertexNormals.length; i2 < il; i2++) {
      this.vertexNormals[i2] = source.vertexNormals[i2].clone();
    }
    for (var i2 = 0, il = source.vertexColors.length; i2 < il; i2++) {
      this.vertexColors[i2] = source.vertexColors[i2].clone();
    }
    return this;
  }
});
function Euler(x2, y, z2, order) {
  this._x = x2 || 0;
  this._y = y || 0;
  this._z = z2 || 0;
  this._order = order || Euler.DefaultOrder;
}
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
Euler.DefaultOrder = "XYZ";
Object.defineProperties(Euler.prototype, {
  x: {
    get: function() {
      return this._x;
    },
    set: function(value) {
      this._x = value;
      this.onChangeCallback();
    }
  },
  y: {
    get: function() {
      return this._y;
    },
    set: function(value) {
      this._y = value;
      this.onChangeCallback();
    }
  },
  z: {
    get: function() {
      return this._z;
    },
    set: function(value) {
      this._z = value;
      this.onChangeCallback();
    }
  },
  order: {
    get: function() {
      return this._order;
    },
    set: function(value) {
      this._order = value;
      this.onChangeCallback();
    }
  }
});
Object.assign(Euler.prototype, {
  isEuler: true,
  set: function(x2, y, z2, order) {
    this._x = x2;
    this._y = y;
    this._z = z2;
    this._order = order || this._order;
    this.onChangeCallback();
    return this;
  },
  clone: function() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  },
  copy: function(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this.onChangeCallback();
    return this;
  },
  setFromRotationMatrix: function(m2, order, update3) {
    var clamp = _Math.clamp;
    var te = m2.elements;
    var m11 = te[0], m12 = te[4], m13 = te[8];
    var m21 = te[1], m22 = te[5], m23 = te[9];
    var m31 = te[2], m32 = te[6], m33 = te[10];
    order = order || this._order;
    if (order === "XYZ") {
      this._y = Math.asin(clamp(m13, -1, 1));
      if (Math.abs(m13) < 0.99999) {
        this._x = Math.atan2(-m23, m33);
        this._z = Math.atan2(-m12, m11);
      } else {
        this._x = Math.atan2(m32, m22);
        this._z = 0;
      }
    } else if (order === "YXZ") {
      this._x = Math.asin(-clamp(m23, -1, 1));
      if (Math.abs(m23) < 0.99999) {
        this._y = Math.atan2(m13, m33);
        this._z = Math.atan2(m21, m22);
      } else {
        this._y = Math.atan2(-m31, m11);
        this._z = 0;
      }
    } else if (order === "ZXY") {
      this._x = Math.asin(clamp(m32, -1, 1));
      if (Math.abs(m32) < 0.99999) {
        this._y = Math.atan2(-m31, m33);
        this._z = Math.atan2(-m12, m22);
      } else {
        this._y = 0;
        this._z = Math.atan2(m21, m11);
      }
    } else if (order === "ZYX") {
      this._y = Math.asin(-clamp(m31, -1, 1));
      if (Math.abs(m31) < 0.99999) {
        this._x = Math.atan2(m32, m33);
        this._z = Math.atan2(m21, m11);
      } else {
        this._x = 0;
        this._z = Math.atan2(-m12, m22);
      }
    } else if (order === "YZX") {
      this._z = Math.asin(clamp(m21, -1, 1));
      if (Math.abs(m21) < 0.99999) {
        this._x = Math.atan2(-m23, m22);
        this._y = Math.atan2(-m31, m11);
      } else {
        this._x = 0;
        this._y = Math.atan2(m13, m33);
      }
    } else if (order === "XZY") {
      this._z = Math.asin(-clamp(m12, -1, 1));
      if (Math.abs(m12) < 0.99999) {
        this._x = Math.atan2(m32, m22);
        this._y = Math.atan2(m13, m11);
      } else {
        this._x = Math.atan2(-m23, m33);
        this._y = 0;
      }
    } else {
      console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + order);
    }
    this._order = order;
    if (update3 !== false)
      this.onChangeCallback();
    return this;
  },
  setFromQuaternion: function() {
    var matrix = new Matrix4();
    return function setFromQuaternion(q, order, update3) {
      matrix.makeRotationFromQuaternion(q);
      return this.setFromRotationMatrix(matrix, order, update3);
    };
  }(),
  setFromVector3: function(v2, order) {
    return this.set(v2.x, v2.y, v2.z, order || this._order);
  },
  reorder: function() {
    var q = new Quaternion();
    return function reorder(newOrder) {
      q.setFromEuler(this);
      return this.setFromQuaternion(q, newOrder);
    };
  }(),
  equals: function(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  },
  fromArray: function(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0)
      this._order = array[3];
    this.onChangeCallback();
    return this;
  },
  toArray: function(array, offset2) {
    if (array === void 0)
      array = [];
    if (offset2 === void 0)
      offset2 = 0;
    array[offset2] = this._x;
    array[offset2 + 1] = this._y;
    array[offset2 + 2] = this._z;
    array[offset2 + 3] = this._order;
    return array;
  },
  toVector3: function(optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  },
  onChange: function(callback) {
    this.onChangeCallback = callback;
    return this;
  },
  onChangeCallback: function() {
  }
});
function Layers() {
  this.mask = 1 | 0;
}
Object.assign(Layers.prototype, {
  set: function(channel) {
    this.mask = 1 << channel | 0;
  },
  enable: function(channel) {
    this.mask |= 1 << channel | 0;
  },
  toggle: function(channel) {
    this.mask ^= 1 << channel | 0;
  },
  disable: function(channel) {
    this.mask &= ~(1 << channel | 0);
  },
  test: function(layers) {
    return (this.mask & layers.mask) !== 0;
  }
});
var object3DId = 0;
function Object3D() {
  Object.defineProperty(this, "id", { value: object3DId++ });
  this.uuid = _Math.generateUUID();
  this.name = "";
  this.type = "Object3D";
  this.parent = null;
  this.children = [];
  this.up = Object3D.DefaultUp.clone();
  var position = new Vector3();
  var rotation = new Euler();
  var quaternion = new Quaternion();
  var scale2 = new Vector3(1, 1, 1);
  function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
  }
  function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, void 0, false);
  }
  rotation.onChange(onRotationChange);
  quaternion.onChange(onQuaternionChange);
  Object.defineProperties(this, {
    position: {
      configurable: true,
      enumerable: true,
      value: position
    },
    rotation: {
      configurable: true,
      enumerable: true,
      value: rotation
    },
    quaternion: {
      configurable: true,
      enumerable: true,
      value: quaternion
    },
    scale: {
      configurable: true,
      enumerable: true,
      value: scale2
    },
    modelViewMatrix: {
      value: new Matrix4()
    },
    normalMatrix: {
      value: new Matrix3()
    }
  });
  this.matrix = new Matrix4();
  this.matrixWorld = new Matrix4();
  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;
  this.layers = new Layers();
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.renderOrder = 0;
  this.userData = {};
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Object3D,
  isObject3D: true,
  onBeforeRender: function() {
  },
  onAfterRender: function() {
  },
  applyMatrix: function(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function(q) {
    this.quaternion.premultiply(q);
    return this;
  },
  setRotationFromAxisAngle: function(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function(euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function(m2) {
    this.quaternion.setFromRotationMatrix(m2);
  },
  setRotationFromQuaternion: function(q) {
    this.quaternion.copy(q);
  },
  rotateOnAxis: function() {
    var q1 = new Quaternion();
    return function rotateOnAxis(axis, angle) {
      q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(q1);
      return this;
    };
  }(),
  rotateOnWorldAxis: function() {
    var q1 = new Quaternion();
    return function rotateOnWorldAxis(axis, angle) {
      q1.setFromAxisAngle(axis, angle);
      this.quaternion.premultiply(q1);
      return this;
    };
  }(),
  rotateX: function() {
    var v1 = new Vector3(1, 0, 0);
    return function rotateX(angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  rotateY: function() {
    var v1 = new Vector3(0, 1, 0);
    return function rotateY(angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  rotateZ: function() {
    var v1 = new Vector3(0, 0, 1);
    return function rotateZ(angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  translateOnAxis: function() {
    var v1 = new Vector3();
    return function translateOnAxis(axis, distance) {
      v1.copy(axis).applyQuaternion(this.quaternion);
      this.position.add(v1.multiplyScalar(distance));
      return this;
    };
  }(),
  translateX: function() {
    var v1 = new Vector3(1, 0, 0);
    return function translateX(distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  translateY: function() {
    var v1 = new Vector3(0, 1, 0);
    return function translateY(distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  translateZ: function() {
    var v1 = new Vector3(0, 0, 1);
    return function translateZ(distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  localToWorld: function(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function() {
    var m1 = new Matrix4();
    return function worldToLocal(vector) {
      return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
    };
  }(),
  lookAt: function() {
    var q1 = new Quaternion();
    var m1 = new Matrix4();
    var target = new Vector3();
    var position = new Vector3();
    return function lookAt(x2, y, z2) {
      if (x2.isVector3) {
        target.copy(x2);
      } else {
        target.set(x2, y, z2);
      }
      var parent2 = this.parent;
      this.updateWorldMatrix(true, false);
      position.setFromMatrixPosition(this.matrixWorld);
      if (this.isCamera || this.isLight) {
        m1.lookAt(position, target, this.up);
      } else {
        m1.lookAt(target, position, this.up);
      }
      this.quaternion.setFromRotationMatrix(m1);
      if (parent2) {
        m1.extractRotation(parent2.matrixWorld);
        q1.setFromRotationMatrix(m1);
        this.quaternion.premultiply(q1.inverse());
      }
    };
  }(),
  add: function(object) {
    if (arguments.length > 1) {
      for (var i2 = 0; i2 < arguments.length; i2++) {
        this.add(arguments[i2]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      object.dispatchEvent({ type: "added" });
      this.children.push(object);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  },
  remove: function(object) {
    if (arguments.length > 1) {
      for (var i2 = 0; i2 < arguments.length; i2++) {
        this.remove(arguments[i2]);
      }
      return this;
    }
    var index2 = this.children.indexOf(object);
    if (index2 !== -1) {
      object.parent = null;
      object.dispatchEvent({ type: "removed" });
      this.children.splice(index2, 1);
    }
    return this;
  },
  attach: function() {
    var m2 = new Matrix4();
    return function attach(object) {
      this.updateWorldMatrix(true, false);
      m2.getInverse(this.matrixWorld);
      if (object.parent !== null) {
        object.parent.updateWorldMatrix(true, false);
        m2.multiply(object.parent.matrixWorld);
      }
      object.applyMatrix(m2);
      object.updateWorldMatrix(false, false);
      this.add(object);
      return this;
    };
  }(),
  getObjectById: function(id) {
    return this.getObjectByProperty("id", id);
  },
  getObjectByName: function(name) {
    return this.getObjectByProperty("name", name);
  },
  getObjectByProperty: function(name, value) {
    if (this[name] === value)
      return this;
    for (var i2 = 0, l2 = this.children.length; i2 < l2; i2++) {
      var child = this.children[i2];
      var object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  },
  getWorldPosition: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldPosition() target is now required");
      target = new Vector3();
    }
    this.updateMatrixWorld(true);
    return target.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function() {
    var position = new Vector3();
    var scale2 = new Vector3();
    return function getWorldQuaternion(target) {
      if (target === void 0) {
        console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
        target = new Quaternion();
      }
      this.updateMatrixWorld(true);
      this.matrixWorld.decompose(position, target, scale2);
      return target;
    };
  }(),
  getWorldScale: function() {
    var position = new Vector3();
    var quaternion = new Quaternion();
    return function getWorldScale(target) {
      if (target === void 0) {
        console.warn("THREE.Object3D: .getWorldScale() target is now required");
        target = new Vector3();
      }
      this.updateMatrixWorld(true);
      this.matrixWorld.decompose(position, quaternion, target);
      return target;
    };
  }(),
  getWorldDirection: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldDirection() target is now required");
      target = new Vector3();
    }
    this.updateMatrixWorld(true);
    var e2 = this.matrixWorld.elements;
    return target.set(e2[8], e2[9], e2[10]).normalize();
  },
  raycast: function() {
  },
  traverse: function(callback) {
    callback(this);
    var children2 = this.children;
    for (var i2 = 0, l2 = children2.length; i2 < l2; i2++) {
      children2[i2].traverse(callback);
    }
  },
  traverseVisible: function(callback) {
    if (this.visible === false)
      return;
    callback(this);
    var children2 = this.children;
    for (var i2 = 0, l2 = children2.length; i2 < l2; i2++) {
      children2[i2].traverseVisible(callback);
    }
  },
  traverseAncestors: function(callback) {
    var parent2 = this.parent;
    if (parent2 !== null) {
      callback(parent2);
      parent2.traverseAncestors(callback);
    }
  },
  updateMatrix: function() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    var children2 = this.children;
    for (var i2 = 0, l2 = children2.length; i2 < l2; i2++) {
      children2[i2].updateMatrixWorld(force);
    }
  },
  updateWorldMatrix: function(updateParents, updateChildren) {
    var parent2 = this.parent;
    if (updateParents === true && parent2 !== null) {
      parent2.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      var children2 = this.children;
      for (var i2 = 0, l2 = children2.length; i2 < l2; i2++) {
        children2[i2].updateWorldMatrix(false, true);
      }
    }
  },
  toJSON: function(meta) {
    var isRootObject = meta === void 0 || typeof meta === "string";
    var output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {}
      };
      output.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    var object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "")
      object.name = this.name;
    if (this.castShadow === true)
      object.castShadow = true;
    if (this.receiveShadow === true)
      object.receiveShadow = true;
    if (this.visible === false)
      object.visible = false;
    if (this.frustumCulled === false)
      object.frustumCulled = false;
    if (this.renderOrder !== 0)
      object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== "{}")
      object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false)
      object.matrixAutoUpdate = false;
    if (this.isMesh && this.drawMode !== TrianglesDrawMode)
      object.drawMode = this.drawMode;
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      var parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        var shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (var i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
            var shape = shapes[i2];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        var uuids = [];
        for (var i2 = 0, l2 = this.material.length; i2 < l2; i2++) {
          uuids.push(serialize(meta.materials, this.material[i2]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (var i2 = 0; i2 < this.children.length; i2++) {
        object.children.push(this.children[i2].toJSON(meta).object);
      }
    }
    if (isRootObject) {
      var geometries = extractFromCache(meta.geometries);
      var materials = extractFromCache(meta.materials);
      var textures = extractFromCache(meta.textures);
      var images2 = extractFromCache(meta.images);
      var shapes = extractFromCache(meta.shapes);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images2.length > 0)
        output.images = images2;
      if (shapes.length > 0)
        output.shapes = shapes;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      var values = [];
      for (var key in cache) {
        var data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  },
  clone: function(recursive) {
    return new this.constructor().copy(this, recursive);
  },
  copy: function(source, recursive) {
    if (recursive === void 0)
      recursive = true;
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (var i2 = 0; i2 < source.children.length; i2++) {
        var child = source.children[i2];
        this.add(child.clone());
      }
    }
    return this;
  }
});
var geometryId = 0;
function Geometry() {
  Object.defineProperty(this, "id", { value: geometryId += 2 });
  this.uuid = _Math.generateUUID();
  this.name = "";
  this.type = "Geometry";
  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [[]];
  this.morphTargets = [];
  this.morphNormals = [];
  this.skinWeights = [];
  this.skinIndices = [];
  this.lineDistances = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.elementsNeedUpdate = false;
  this.verticesNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.lineDistancesNeedUpdate = false;
  this.groupsNeedUpdate = false;
}
Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Geometry,
  isGeometry: true,
  applyMatrix: function(matrix) {
    var normalMatrix = new Matrix3().getNormalMatrix(matrix);
    for (var i2 = 0, il = this.vertices.length; i2 < il; i2++) {
      var vertex = this.vertices[i2];
      vertex.applyMatrix4(matrix);
    }
    for (var i2 = 0, il = this.faces.length; i2 < il; i2++) {
      var face = this.faces[i2];
      face.normal.applyMatrix3(normalMatrix).normalize();
      for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
      }
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    this.verticesNeedUpdate = true;
    this.normalsNeedUpdate = true;
    return this;
  },
  rotateX: function() {
    var m1 = new Matrix4();
    return function rotateX(angle) {
      m1.makeRotationX(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateY: function() {
    var m1 = new Matrix4();
    return function rotateY(angle) {
      m1.makeRotationY(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateZ: function() {
    var m1 = new Matrix4();
    return function rotateZ(angle) {
      m1.makeRotationZ(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  translate: function() {
    var m1 = new Matrix4();
    return function translate2(x2, y, z2) {
      m1.makeTranslation(x2, y, z2);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  scale: function() {
    var m1 = new Matrix4();
    return function scale2(x2, y, z2) {
      m1.makeScale(x2, y, z2);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  lookAt: function() {
    var obj = new Object3D();
    return function lookAt(vector) {
      obj.lookAt(vector);
      obj.updateMatrix();
      this.applyMatrix(obj.matrix);
    };
  }(),
  fromBufferGeometry: function(geometry2) {
    var scope = this;
    var indices = geometry2.index !== null ? geometry2.index.array : void 0;
    var attributes = geometry2.attributes;
    var positions = attributes.position.array;
    var normals = attributes.normal !== void 0 ? attributes.normal.array : void 0;
    var colors = attributes.color !== void 0 ? attributes.color.array : void 0;
    var uvs = attributes.uv !== void 0 ? attributes.uv.array : void 0;
    var uvs2 = attributes.uv2 !== void 0 ? attributes.uv2.array : void 0;
    if (uvs2 !== void 0)
      this.faceVertexUvs[1] = [];
    for (var i2 = 0; i2 < positions.length; i2 += 3) {
      scope.vertices.push(new Vector3().fromArray(positions, i2));
      if (colors !== void 0) {
        scope.colors.push(new Color().fromArray(colors, i2));
      }
    }
    function addFace(a2, b2, c2, materialIndex) {
      var vertexColors = colors === void 0 ? [] : [
        scope.colors[a2].clone(),
        scope.colors[b2].clone(),
        scope.colors[c2].clone()
      ];
      var vertexNormals = normals === void 0 ? [] : [
        new Vector3().fromArray(normals, a2 * 3),
        new Vector3().fromArray(normals, b2 * 3),
        new Vector3().fromArray(normals, c2 * 3)
      ];
      var face = new Face3(a2, b2, c2, vertexNormals, vertexColors, materialIndex);
      scope.faces.push(face);
      if (uvs !== void 0) {
        scope.faceVertexUvs[0].push([
          new Vector2().fromArray(uvs, a2 * 2),
          new Vector2().fromArray(uvs, b2 * 2),
          new Vector2().fromArray(uvs, c2 * 2)
        ]);
      }
      if (uvs2 !== void 0) {
        scope.faceVertexUvs[1].push([
          new Vector2().fromArray(uvs2, a2 * 2),
          new Vector2().fromArray(uvs2, b2 * 2),
          new Vector2().fromArray(uvs2, c2 * 2)
        ]);
      }
    }
    var groups = geometry2.groups;
    if (groups.length > 0) {
      for (var i2 = 0; i2 < groups.length; i2++) {
        var group = groups[i2];
        var start = group.start;
        var count2 = group.count;
        for (var j = start, jl = start + count2; j < jl; j += 3) {
          if (indices !== void 0) {
            addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
          } else {
            addFace(j, j + 1, j + 2, group.materialIndex);
          }
        }
      }
    } else {
      if (indices !== void 0) {
        for (var i2 = 0; i2 < indices.length; i2 += 3) {
          addFace(indices[i2], indices[i2 + 1], indices[i2 + 2]);
        }
      } else {
        for (var i2 = 0; i2 < positions.length / 3; i2 += 3) {
          addFace(i2, i2 + 1, i2 + 2);
        }
      }
    }
    this.computeFaceNormals();
    if (geometry2.boundingBox !== null) {
      this.boundingBox = geometry2.boundingBox.clone();
    }
    if (geometry2.boundingSphere !== null) {
      this.boundingSphere = geometry2.boundingSphere.clone();
    }
    return this;
  },
  center: function() {
    var offset2 = new Vector3();
    return function center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(offset2).negate();
      this.translate(offset2.x, offset2.y, offset2.z);
      return this;
    };
  }(),
  normalize: function() {
    this.computeBoundingSphere();
    var center = this.boundingSphere.center;
    var radius = this.boundingSphere.radius;
    var s2 = radius === 0 ? 1 : 1 / radius;
    var matrix = new Matrix4();
    matrix.set(s2, 0, 0, -s2 * center.x, 0, s2, 0, -s2 * center.y, 0, 0, s2, -s2 * center.z, 0, 0, 0, 1);
    this.applyMatrix(matrix);
    return this;
  },
  computeFaceNormals: function() {
    var cb = new Vector3(), ab = new Vector3();
    for (var f2 = 0, fl = this.faces.length; f2 < fl; f2++) {
      var face = this.faces[f2];
      var vA = this.vertices[face.a];
      var vB = this.vertices[face.b];
      var vC = this.vertices[face.c];
      cb.subVectors(vC, vB);
      ab.subVectors(vA, vB);
      cb.cross(ab);
      cb.normalize();
      face.normal.copy(cb);
    }
  },
  computeVertexNormals: function(areaWeighted) {
    if (areaWeighted === void 0)
      areaWeighted = true;
    var v2, vl, f2, fl, face, vertices;
    vertices = new Array(this.vertices.length);
    for (v2 = 0, vl = this.vertices.length; v2 < vl; v2++) {
      vertices[v2] = new Vector3();
    }
    if (areaWeighted) {
      var vA, vB, vC;
      var cb = new Vector3(), ab = new Vector3();
      for (f2 = 0, fl = this.faces.length; f2 < fl; f2++) {
        face = this.faces[f2];
        vA = this.vertices[face.a];
        vB = this.vertices[face.b];
        vC = this.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        vertices[face.a].add(cb);
        vertices[face.b].add(cb);
        vertices[face.c].add(cb);
      }
    } else {
      this.computeFaceNormals();
      for (f2 = 0, fl = this.faces.length; f2 < fl; f2++) {
        face = this.faces[f2];
        vertices[face.a].add(face.normal);
        vertices[face.b].add(face.normal);
        vertices[face.c].add(face.normal);
      }
    }
    for (v2 = 0, vl = this.vertices.length; v2 < vl; v2++) {
      vertices[v2].normalize();
    }
    for (f2 = 0, fl = this.faces.length; f2 < fl; f2++) {
      face = this.faces[f2];
      var vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(vertices[face.a]);
        vertexNormals[1].copy(vertices[face.b]);
        vertexNormals[2].copy(vertices[face.c]);
      } else {
        vertexNormals[0] = vertices[face.a].clone();
        vertexNormals[1] = vertices[face.b].clone();
        vertexNormals[2] = vertices[face.c].clone();
      }
    }
    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  },
  computeFlatVertexNormals: function() {
    var f2, fl, face;
    this.computeFaceNormals();
    for (f2 = 0, fl = this.faces.length; f2 < fl; f2++) {
      face = this.faces[f2];
      var vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(face.normal);
        vertexNormals[1].copy(face.normal);
        vertexNormals[2].copy(face.normal);
      } else {
        vertexNormals[0] = face.normal.clone();
        vertexNormals[1] = face.normal.clone();
        vertexNormals[2] = face.normal.clone();
      }
    }
    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  },
  computeMorphNormals: function() {
    var i2, il, f2, fl, face;
    for (f2 = 0, fl = this.faces.length; f2 < fl; f2++) {
      face = this.faces[f2];
      if (!face.__originalFaceNormal) {
        face.__originalFaceNormal = face.normal.clone();
      } else {
        face.__originalFaceNormal.copy(face.normal);
      }
      if (!face.__originalVertexNormals)
        face.__originalVertexNormals = [];
      for (i2 = 0, il = face.vertexNormals.length; i2 < il; i2++) {
        if (!face.__originalVertexNormals[i2]) {
          face.__originalVertexNormals[i2] = face.vertexNormals[i2].clone();
        } else {
          face.__originalVertexNormals[i2].copy(face.vertexNormals[i2]);
        }
      }
    }
    var tmpGeo = new Geometry();
    tmpGeo.faces = this.faces;
    for (i2 = 0, il = this.morphTargets.length; i2 < il; i2++) {
      if (!this.morphNormals[i2]) {
        this.morphNormals[i2] = {};
        this.morphNormals[i2].faceNormals = [];
        this.morphNormals[i2].vertexNormals = [];
        var dstNormalsFace = this.morphNormals[i2].faceNormals;
        var dstNormalsVertex = this.morphNormals[i2].vertexNormals;
        var faceNormal, vertexNormals;
        for (f2 = 0, fl = this.faces.length; f2 < fl; f2++) {
          faceNormal = new Vector3();
          vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
          dstNormalsFace.push(faceNormal);
          dstNormalsVertex.push(vertexNormals);
        }
      }
      var morphNormals = this.morphNormals[i2];
      tmpGeo.vertices = this.morphTargets[i2].vertices;
      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals();
      var faceNormal, vertexNormals;
      for (f2 = 0, fl = this.faces.length; f2 < fl; f2++) {
        face = this.faces[f2];
        faceNormal = morphNormals.faceNormals[f2];
        vertexNormals = morphNormals.vertexNormals[f2];
        faceNormal.copy(face.normal);
        vertexNormals.a.copy(face.vertexNormals[0]);
        vertexNormals.b.copy(face.vertexNormals[1]);
        vertexNormals.c.copy(face.vertexNormals[2]);
      }
    }
    for (f2 = 0, fl = this.faces.length; f2 < fl; f2++) {
      face = this.faces[f2];
      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;
    }
  },
  computeBoundingBox: function() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function(geometry2, matrix, materialIndexOffset) {
    if (!(geometry2 && geometry2.isGeometry)) {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry2);
      return;
    }
    var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry2.vertices, faces1 = this.faces, faces2 = geometry2.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry2.faceVertexUvs[0], colors1 = this.colors, colors2 = geometry2.colors;
    if (materialIndexOffset === void 0)
      materialIndexOffset = 0;
    if (matrix !== void 0) {
      normalMatrix = new Matrix3().getNormalMatrix(matrix);
    }
    for (var i2 = 0, il = vertices2.length; i2 < il; i2++) {
      var vertex = vertices2[i2];
      var vertexCopy = vertex.clone();
      if (matrix !== void 0)
        vertexCopy.applyMatrix4(matrix);
      vertices1.push(vertexCopy);
    }
    for (var i2 = 0, il = colors2.length; i2 < il; i2++) {
      colors1.push(colors2[i2].clone());
    }
    for (i2 = 0, il = faces2.length; i2 < il; i2++) {
      var face = faces2[i2], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
      faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
      faceCopy.normal.copy(face.normal);
      if (normalMatrix !== void 0) {
        faceCopy.normal.applyMatrix3(normalMatrix).normalize();
      }
      for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
        normal = faceVertexNormals[j].clone();
        if (normalMatrix !== void 0) {
          normal.applyMatrix3(normalMatrix).normalize();
        }
        faceCopy.vertexNormals.push(normal);
      }
      faceCopy.color.copy(face.color);
      for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
        color = faceVertexColors[j];
        faceCopy.vertexColors.push(color.clone());
      }
      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
      faces1.push(faceCopy);
    }
    for (i2 = 0, il = uvs2.length; i2 < il; i2++) {
      var uv = uvs2[i2], uvCopy = [];
      if (uv === void 0) {
        continue;
      }
      for (var j = 0, jl = uv.length; j < jl; j++) {
        uvCopy.push(uv[j].clone());
      }
      uvs1.push(uvCopy);
    }
  },
  mergeMesh: function(mesh) {
    if (!(mesh && mesh.isMesh)) {
      console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
      return;
    }
    if (mesh.matrixAutoUpdate)
      mesh.updateMatrix();
    this.merge(mesh.geometry, mesh.matrix);
  },
  mergeVertices: function() {
    var verticesMap = {};
    var unique = [], changes = [];
    var v2, key;
    var precisionPoints = 4;
    var precision = Math.pow(10, precisionPoints);
    var i2, il, face;
    var indices, j, jl;
    for (i2 = 0, il = this.vertices.length; i2 < il; i2++) {
      v2 = this.vertices[i2];
      key = Math.round(v2.x * precision) + "_" + Math.round(v2.y * precision) + "_" + Math.round(v2.z * precision);
      if (verticesMap[key] === void 0) {
        verticesMap[key] = i2;
        unique.push(this.vertices[i2]);
        changes[i2] = unique.length - 1;
      } else {
        changes[i2] = changes[verticesMap[key]];
      }
    }
    var faceIndicesToRemove = [];
    for (i2 = 0, il = this.faces.length; i2 < il; i2++) {
      face = this.faces[i2];
      face.a = changes[face.a];
      face.b = changes[face.b];
      face.c = changes[face.c];
      indices = [face.a, face.b, face.c];
      for (var n2 = 0; n2 < 3; n2++) {
        if (indices[n2] === indices[(n2 + 1) % 3]) {
          faceIndicesToRemove.push(i2);
          break;
        }
      }
    }
    for (i2 = faceIndicesToRemove.length - 1; i2 >= 0; i2--) {
      var idx = faceIndicesToRemove[i2];
      this.faces.splice(idx, 1);
      for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
        this.faceVertexUvs[j].splice(idx, 1);
      }
    }
    var diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;
  },
  setFromPoints: function(points) {
    this.vertices = [];
    for (var i2 = 0, l2 = points.length; i2 < l2; i2++) {
      var point = points[i2];
      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
    }
    return this;
  },
  sortFacesByMaterialIndex: function() {
    var faces = this.faces;
    var length = faces.length;
    for (var i2 = 0; i2 < length; i2++) {
      faces[i2]._id = i2;
    }
    function materialIndexSort(a2, b2) {
      return a2.materialIndex - b2.materialIndex;
    }
    faces.sort(materialIndexSort);
    var uvs1 = this.faceVertexUvs[0];
    var uvs2 = this.faceVertexUvs[1];
    var newUvs1, newUvs2;
    if (uvs1 && uvs1.length === length)
      newUvs1 = [];
    if (uvs2 && uvs2.length === length)
      newUvs2 = [];
    for (var i2 = 0; i2 < length; i2++) {
      var id = faces[i2]._id;
      if (newUvs1)
        newUvs1.push(uvs1[id]);
      if (newUvs2)
        newUvs2.push(uvs2[id]);
    }
    if (newUvs1)
      this.faceVertexUvs[0] = newUvs1;
    if (newUvs2)
      this.faceVertexUvs[1] = newUvs2;
  },
  toJSON: function() {
    var data = {
      metadata: {
        version: 4.5,
        type: "Geometry",
        generator: "Geometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.parameters !== void 0) {
      var parameters = this.parameters;
      for (var key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    var vertices = [];
    for (var i2 = 0; i2 < this.vertices.length; i2++) {
      var vertex = this.vertices[i2];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
    var faces = [];
    var normals = [];
    var normalsHash = {};
    var colors = [];
    var colorsHash = {};
    var uvs = [];
    var uvsHash = {};
    for (var i2 = 0; i2 < this.faces.length; i2++) {
      var face = this.faces[i2];
      var hasMaterial = true;
      var hasFaceUv = false;
      var hasFaceVertexUv = this.faceVertexUvs[0][i2] !== void 0;
      var hasFaceNormal = face.normal.length() > 0;
      var hasFaceVertexNormal = face.vertexNormals.length > 0;
      var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
      var hasFaceVertexColor = face.vertexColors.length > 0;
      var faceType = 0;
      faceType = setBit(faceType, 0, 0);
      faceType = setBit(faceType, 1, hasMaterial);
      faceType = setBit(faceType, 2, hasFaceUv);
      faceType = setBit(faceType, 3, hasFaceVertexUv);
      faceType = setBit(faceType, 4, hasFaceNormal);
      faceType = setBit(faceType, 5, hasFaceVertexNormal);
      faceType = setBit(faceType, 6, hasFaceColor);
      faceType = setBit(faceType, 7, hasFaceVertexColor);
      faces.push(faceType);
      faces.push(face.a, face.b, face.c);
      faces.push(face.materialIndex);
      if (hasFaceVertexUv) {
        var faceVertexUvs = this.faceVertexUvs[0][i2];
        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
      }
      if (hasFaceNormal) {
        faces.push(getNormalIndex(face.normal));
      }
      if (hasFaceVertexNormal) {
        var vertexNormals = face.vertexNormals;
        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
      }
      if (hasFaceColor) {
        faces.push(getColorIndex(face.color));
      }
      if (hasFaceVertexColor) {
        var vertexColors = face.vertexColors;
        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
      }
    }
    function setBit(value, position, enabled) {
      return enabled ? value | 1 << position : value & ~(1 << position);
    }
    function getNormalIndex(normal) {
      var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
      if (normalsHash[hash] !== void 0) {
        return normalsHash[hash];
      }
      normalsHash[hash] = normals.length / 3;
      normals.push(normal.x, normal.y, normal.z);
      return normalsHash[hash];
    }
    function getColorIndex(color) {
      var hash = color.r.toString() + color.g.toString() + color.b.toString();
      if (colorsHash[hash] !== void 0) {
        return colorsHash[hash];
      }
      colorsHash[hash] = colors.length;
      colors.push(color.getHex());
      return colorsHash[hash];
    }
    function getUvIndex(uv) {
      var hash = uv.x.toString() + uv.y.toString();
      if (uvsHash[hash] !== void 0) {
        return uvsHash[hash];
      }
      uvsHash[hash] = uvs.length / 2;
      uvs.push(uv.x, uv.y);
      return uvsHash[hash];
    }
    data.data = {};
    data.data.vertices = vertices;
    data.data.normals = normals;
    if (colors.length > 0)
      data.data.colors = colors;
    if (uvs.length > 0)
      data.data.uvs = [uvs];
    data.data.faces = faces;
    return data;
  },
  clone: function() {
    return new Geometry().copy(this);
  },
  copy: function(source) {
    var i2, il, j, jl, k2, kl;
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.name = source.name;
    var vertices = source.vertices;
    for (i2 = 0, il = vertices.length; i2 < il; i2++) {
      this.vertices.push(vertices[i2].clone());
    }
    var colors = source.colors;
    for (i2 = 0, il = colors.length; i2 < il; i2++) {
      this.colors.push(colors[i2].clone());
    }
    var faces = source.faces;
    for (i2 = 0, il = faces.length; i2 < il; i2++) {
      this.faces.push(faces[i2].clone());
    }
    for (i2 = 0, il = source.faceVertexUvs.length; i2 < il; i2++) {
      var faceVertexUvs = source.faceVertexUvs[i2];
      if (this.faceVertexUvs[i2] === void 0) {
        this.faceVertexUvs[i2] = [];
      }
      for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {
        var uvs = faceVertexUvs[j], uvsCopy = [];
        for (k2 = 0, kl = uvs.length; k2 < kl; k2++) {
          var uv = uvs[k2];
          uvsCopy.push(uv.clone());
        }
        this.faceVertexUvs[i2].push(uvsCopy);
      }
    }
    var morphTargets = source.morphTargets;
    for (i2 = 0, il = morphTargets.length; i2 < il; i2++) {
      var morphTarget = {};
      morphTarget.name = morphTargets[i2].name;
      if (morphTargets[i2].vertices !== void 0) {
        morphTarget.vertices = [];
        for (j = 0, jl = morphTargets[i2].vertices.length; j < jl; j++) {
          morphTarget.vertices.push(morphTargets[i2].vertices[j].clone());
        }
      }
      if (morphTargets[i2].normals !== void 0) {
        morphTarget.normals = [];
        for (j = 0, jl = morphTargets[i2].normals.length; j < jl; j++) {
          morphTarget.normals.push(morphTargets[i2].normals[j].clone());
        }
      }
      this.morphTargets.push(morphTarget);
    }
    var morphNormals = source.morphNormals;
    for (i2 = 0, il = morphNormals.length; i2 < il; i2++) {
      var morphNormal = {};
      if (morphNormals[i2].vertexNormals !== void 0) {
        morphNormal.vertexNormals = [];
        for (j = 0, jl = morphNormals[i2].vertexNormals.length; j < jl; j++) {
          var srcVertexNormal = morphNormals[i2].vertexNormals[j];
          var destVertexNormal = {};
          destVertexNormal.a = srcVertexNormal.a.clone();
          destVertexNormal.b = srcVertexNormal.b.clone();
          destVertexNormal.c = srcVertexNormal.c.clone();
          morphNormal.vertexNormals.push(destVertexNormal);
        }
      }
      if (morphNormals[i2].faceNormals !== void 0) {
        morphNormal.faceNormals = [];
        for (j = 0, jl = morphNormals[i2].faceNormals.length; j < jl; j++) {
          morphNormal.faceNormals.push(morphNormals[i2].faceNormals[j].clone());
        }
      }
      this.morphNormals.push(morphNormal);
    }
    var skinWeights = source.skinWeights;
    for (i2 = 0, il = skinWeights.length; i2 < il; i2++) {
      this.skinWeights.push(skinWeights[i2].clone());
    }
    var skinIndices = source.skinIndices;
    for (i2 = 0, il = skinIndices.length; i2 < il; i2++) {
      this.skinIndices.push(skinIndices[i2].clone());
    }
    var lineDistances = source.lineDistances;
    for (i2 = 0, il = lineDistances.length; i2 < il; i2++) {
      this.lineDistances.push(lineDistances[i2]);
    }
    var boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    var boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.elementsNeedUpdate = source.elementsNeedUpdate;
    this.verticesNeedUpdate = source.verticesNeedUpdate;
    this.uvsNeedUpdate = source.uvsNeedUpdate;
    this.normalsNeedUpdate = source.normalsNeedUpdate;
    this.colorsNeedUpdate = source.colorsNeedUpdate;
    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
    this.groupsNeedUpdate = source.groupsNeedUpdate;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function BufferAttribute(array, itemSize, normalized) {
  if (Array.isArray(array)) {
    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  }
  this.name = "";
  this.array = array;
  this.itemSize = itemSize;
  this.count = array !== void 0 ? array.length / itemSize : 0;
  this.normalized = normalized === true;
  this.dynamic = false;
  this.updateRange = { offset: 0, count: -1 };
  this.version = 0;
}
Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(BufferAttribute.prototype, {
  isBufferAttribute: true,
  onUploadCallback: function() {
  },
  setArray: function(array) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.count = array !== void 0 ? array.length / this.itemSize : 0;
    this.array = array;
    return this;
  },
  setDynamic: function(value) {
    this.dynamic = value;
    return this;
  },
  copy: function(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.dynamic = source.dynamic;
    return this;
  },
  copyAt: function(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (var i2 = 0, l2 = this.itemSize; i2 < l2; i2++) {
      this.array[index1 + i2] = attribute.array[index2 + i2];
    }
    return this;
  },
  copyArray: function(array) {
    this.array.set(array);
    return this;
  },
  copyColorsArray: function(colors) {
    var array = this.array, offset2 = 0;
    for (var i2 = 0, l2 = colors.length; i2 < l2; i2++) {
      var color = colors[i2];
      if (color === void 0) {
        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2);
        color = new Color();
      }
      array[offset2++] = color.r;
      array[offset2++] = color.g;
      array[offset2++] = color.b;
    }
    return this;
  },
  copyVector2sArray: function(vectors) {
    var array = this.array, offset2 = 0;
    for (var i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
      var vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2);
        vector = new Vector2();
      }
      array[offset2++] = vector.x;
      array[offset2++] = vector.y;
    }
    return this;
  },
  copyVector3sArray: function(vectors) {
    var array = this.array, offset2 = 0;
    for (var i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
      var vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2);
        vector = new Vector3();
      }
      array[offset2++] = vector.x;
      array[offset2++] = vector.y;
      array[offset2++] = vector.z;
    }
    return this;
  },
  copyVector4sArray: function(vectors) {
    var array = this.array, offset2 = 0;
    for (var i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
      var vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2);
        vector = new Vector4();
      }
      array[offset2++] = vector.x;
      array[offset2++] = vector.y;
      array[offset2++] = vector.z;
      array[offset2++] = vector.w;
    }
    return this;
  },
  set: function(value, offset2) {
    if (offset2 === void 0)
      offset2 = 0;
    this.array.set(value, offset2);
    return this;
  },
  getX: function(index2) {
    return this.array[index2 * this.itemSize];
  },
  setX: function(index2, x2) {
    this.array[index2 * this.itemSize] = x2;
    return this;
  },
  getY: function(index2) {
    return this.array[index2 * this.itemSize + 1];
  },
  setY: function(index2, y) {
    this.array[index2 * this.itemSize + 1] = y;
    return this;
  },
  getZ: function(index2) {
    return this.array[index2 * this.itemSize + 2];
  },
  setZ: function(index2, z2) {
    this.array[index2 * this.itemSize + 2] = z2;
    return this;
  },
  getW: function(index2) {
    return this.array[index2 * this.itemSize + 3];
  },
  setW: function(index2, w2) {
    this.array[index2 * this.itemSize + 3] = w2;
    return this;
  },
  setXY: function(index2, x2, y) {
    index2 *= this.itemSize;
    this.array[index2 + 0] = x2;
    this.array[index2 + 1] = y;
    return this;
  },
  setXYZ: function(index2, x2, y, z2) {
    index2 *= this.itemSize;
    this.array[index2 + 0] = x2;
    this.array[index2 + 1] = y;
    this.array[index2 + 2] = z2;
    return this;
  },
  setXYZW: function(index2, x2, y, z2, w2) {
    index2 *= this.itemSize;
    this.array[index2 + 0] = x2;
    this.array[index2 + 1] = y;
    this.array[index2 + 2] = z2;
    this.array[index2 + 3] = w2;
    return this;
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  },
  clone: function() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  },
  toJSON: function() {
    return {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
  }
});
function Int8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}
Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
function Uint8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}
Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}
Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
function Int16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}
Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
function Uint16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
function Int32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}
Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
function Uint32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}
Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
function Float32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}
Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
function Float64BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}
Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
function DirectGeometry() {
  this.vertices = [];
  this.normals = [];
  this.colors = [];
  this.uvs = [];
  this.uvs2 = [];
  this.groups = [];
  this.morphTargets = {};
  this.skinWeights = [];
  this.skinIndices = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.verticesNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.groupsNeedUpdate = false;
}
Object.assign(DirectGeometry.prototype, {
  computeGroups: function(geometry2) {
    var group;
    var groups = [];
    var materialIndex = void 0;
    var faces = geometry2.faces;
    for (var i2 = 0; i2 < faces.length; i2++) {
      var face = faces[i2];
      if (face.materialIndex !== materialIndex) {
        materialIndex = face.materialIndex;
        if (group !== void 0) {
          group.count = i2 * 3 - group.start;
          groups.push(group);
        }
        group = {
          start: i2 * 3,
          materialIndex
        };
      }
    }
    if (group !== void 0) {
      group.count = i2 * 3 - group.start;
      groups.push(group);
    }
    this.groups = groups;
  },
  fromGeometry: function(geometry2) {
    var faces = geometry2.faces;
    var vertices = geometry2.vertices;
    var faceVertexUvs = geometry2.faceVertexUvs;
    var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
    var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
    var morphTargets = geometry2.morphTargets;
    var morphTargetsLength = morphTargets.length;
    var morphTargetsPosition;
    if (morphTargetsLength > 0) {
      morphTargetsPosition = [];
      for (var i2 = 0; i2 < morphTargetsLength; i2++) {
        morphTargetsPosition[i2] = {
          name: morphTargets[i2].name,
          data: []
        };
      }
      this.morphTargets.position = morphTargetsPosition;
    }
    var morphNormals = geometry2.morphNormals;
    var morphNormalsLength = morphNormals.length;
    var morphTargetsNormal;
    if (morphNormalsLength > 0) {
      morphTargetsNormal = [];
      for (var i2 = 0; i2 < morphNormalsLength; i2++) {
        morphTargetsNormal[i2] = {
          name: morphNormals[i2].name,
          data: []
        };
      }
      this.morphTargets.normal = morphTargetsNormal;
    }
    var skinIndices = geometry2.skinIndices;
    var skinWeights = geometry2.skinWeights;
    var hasSkinIndices = skinIndices.length === vertices.length;
    var hasSkinWeights = skinWeights.length === vertices.length;
    if (vertices.length > 0 && faces.length === 0) {
      console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
    }
    for (var i2 = 0; i2 < faces.length; i2++) {
      var face = faces[i2];
      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
      var vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
      } else {
        var normal = face.normal;
        this.normals.push(normal, normal, normal);
      }
      var vertexColors = face.vertexColors;
      if (vertexColors.length === 3) {
        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
      } else {
        var color = face.color;
        this.colors.push(color, color, color);
      }
      if (hasFaceVertexUv === true) {
        var vertexUvs = faceVertexUvs[0][i2];
        if (vertexUvs !== void 0) {
          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i2);
          this.uvs.push(new Vector2(), new Vector2(), new Vector2());
        }
      }
      if (hasFaceVertexUv2 === true) {
        var vertexUvs = faceVertexUvs[1][i2];
        if (vertexUvs !== void 0) {
          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i2);
          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
        }
      }
      for (var j = 0; j < morphTargetsLength; j++) {
        var morphTarget = morphTargets[j].vertices;
        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
      }
      for (var j = 0; j < morphNormalsLength; j++) {
        var morphNormal = morphNormals[j].vertexNormals[i2];
        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
      }
      if (hasSkinIndices) {
        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
      }
      if (hasSkinWeights) {
        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
      }
    }
    this.computeGroups(geometry2);
    this.verticesNeedUpdate = geometry2.verticesNeedUpdate;
    this.normalsNeedUpdate = geometry2.normalsNeedUpdate;
    this.colorsNeedUpdate = geometry2.colorsNeedUpdate;
    this.uvsNeedUpdate = geometry2.uvsNeedUpdate;
    this.groupsNeedUpdate = geometry2.groupsNeedUpdate;
    return this;
  }
});
function arrayMax(array) {
  if (array.length === 0)
    return -Infinity;
  var max = array[0];
  for (var i2 = 1, l2 = array.length; i2 < l2; ++i2) {
    if (array[i2] > max)
      max = array[i2];
  }
  return max;
}
var bufferGeometryId = 1;
function BufferGeometry() {
  Object.defineProperty(this, "id", { value: bufferGeometryId += 2 });
  this.uuid = _Math.generateUUID();
  this.name = "";
  this.type = "BufferGeometry";
  this.index = null;
  this.attributes = {};
  this.morphAttributes = {};
  this.groups = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.drawRange = { start: 0, count: Infinity };
  this.userData = {};
}
BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: BufferGeometry,
  isBufferGeometry: true,
  getIndex: function() {
    return this.index;
  },
  setIndex: function(index2) {
    if (Array.isArray(index2)) {
      this.index = new (arrayMax(index2) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index2, 1);
    } else {
      this.index = index2;
    }
  },
  addAttribute: function(name, attribute) {
    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
      console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
      return this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
    }
    if (name === "index") {
      console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
      this.setIndex(attribute);
      return this;
    }
    this.attributes[name] = attribute;
    return this;
  },
  getAttribute: function(name) {
    return this.attributes[name];
  },
  removeAttribute: function(name) {
    delete this.attributes[name];
    return this;
  },
  addGroup: function(start, count2, materialIndex) {
    this.groups.push({
      start,
      count: count2,
      materialIndex: materialIndex !== void 0 ? materialIndex : 0
    });
  },
  clearGroups: function() {
    this.groups = [];
  },
  setDrawRange: function(start, count2) {
    this.drawRange.start = start;
    this.drawRange.count = count2;
  },
  applyMatrix: function(matrix) {
    var position = this.attributes.position;
    if (position !== void 0) {
      matrix.applyToBufferAttribute(position);
      position.needsUpdate = true;
    }
    var normal = this.attributes.normal;
    if (normal !== void 0) {
      var normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normalMatrix.applyToBufferAttribute(normal);
      normal.needsUpdate = true;
    }
    var tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      var normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normalMatrix.applyToBufferAttribute(tangent);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  },
  rotateX: function() {
    var m1 = new Matrix4();
    return function rotateX(angle) {
      m1.makeRotationX(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateY: function() {
    var m1 = new Matrix4();
    return function rotateY(angle) {
      m1.makeRotationY(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateZ: function() {
    var m1 = new Matrix4();
    return function rotateZ(angle) {
      m1.makeRotationZ(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  translate: function() {
    var m1 = new Matrix4();
    return function translate2(x2, y, z2) {
      m1.makeTranslation(x2, y, z2);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  scale: function() {
    var m1 = new Matrix4();
    return function scale2(x2, y, z2) {
      m1.makeScale(x2, y, z2);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  lookAt: function() {
    var obj = new Object3D();
    return function lookAt(vector) {
      obj.lookAt(vector);
      obj.updateMatrix();
      this.applyMatrix(obj.matrix);
    };
  }(),
  center: function() {
    var offset2 = new Vector3();
    return function center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(offset2).negate();
      this.translate(offset2.x, offset2.y, offset2.z);
      return this;
    };
  }(),
  setFromObject: function(object) {
    var geometry2 = object.geometry;
    if (object.isPoints || object.isLine) {
      var positions = new Float32BufferAttribute(geometry2.vertices.length * 3, 3);
      var colors = new Float32BufferAttribute(geometry2.colors.length * 3, 3);
      this.addAttribute("position", positions.copyVector3sArray(geometry2.vertices));
      this.addAttribute("color", colors.copyColorsArray(geometry2.colors));
      if (geometry2.lineDistances && geometry2.lineDistances.length === geometry2.vertices.length) {
        var lineDistances = new Float32BufferAttribute(geometry2.lineDistances.length, 1);
        this.addAttribute("lineDistance", lineDistances.copyArray(geometry2.lineDistances));
      }
      if (geometry2.boundingSphere !== null) {
        this.boundingSphere = geometry2.boundingSphere.clone();
      }
      if (geometry2.boundingBox !== null) {
        this.boundingBox = geometry2.boundingBox.clone();
      }
    } else if (object.isMesh) {
      if (geometry2 && geometry2.isGeometry) {
        this.fromGeometry(geometry2);
      }
    }
    return this;
  },
  setFromPoints: function(points) {
    var position = [];
    for (var i2 = 0, l2 = points.length; i2 < l2; i2++) {
      var point = points[i2];
      position.push(point.x, point.y, point.z || 0);
    }
    this.addAttribute("position", new Float32BufferAttribute(position, 3));
    return this;
  },
  updateFromObject: function(object) {
    var geometry2 = object.geometry;
    if (object.isMesh) {
      var direct = geometry2.__directGeometry;
      if (geometry2.elementsNeedUpdate === true) {
        direct = void 0;
        geometry2.elementsNeedUpdate = false;
      }
      if (direct === void 0) {
        return this.fromGeometry(geometry2);
      }
      direct.verticesNeedUpdate = geometry2.verticesNeedUpdate;
      direct.normalsNeedUpdate = geometry2.normalsNeedUpdate;
      direct.colorsNeedUpdate = geometry2.colorsNeedUpdate;
      direct.uvsNeedUpdate = geometry2.uvsNeedUpdate;
      direct.groupsNeedUpdate = geometry2.groupsNeedUpdate;
      geometry2.verticesNeedUpdate = false;
      geometry2.normalsNeedUpdate = false;
      geometry2.colorsNeedUpdate = false;
      geometry2.uvsNeedUpdate = false;
      geometry2.groupsNeedUpdate = false;
      geometry2 = direct;
    }
    var attribute;
    if (geometry2.verticesNeedUpdate === true) {
      attribute = this.attributes.position;
      if (attribute !== void 0) {
        attribute.copyVector3sArray(geometry2.vertices);
        attribute.needsUpdate = true;
      }
      geometry2.verticesNeedUpdate = false;
    }
    if (geometry2.normalsNeedUpdate === true) {
      attribute = this.attributes.normal;
      if (attribute !== void 0) {
        attribute.copyVector3sArray(geometry2.normals);
        attribute.needsUpdate = true;
      }
      geometry2.normalsNeedUpdate = false;
    }
    if (geometry2.colorsNeedUpdate === true) {
      attribute = this.attributes.color;
      if (attribute !== void 0) {
        attribute.copyColorsArray(geometry2.colors);
        attribute.needsUpdate = true;
      }
      geometry2.colorsNeedUpdate = false;
    }
    if (geometry2.uvsNeedUpdate) {
      attribute = this.attributes.uv;
      if (attribute !== void 0) {
        attribute.copyVector2sArray(geometry2.uvs);
        attribute.needsUpdate = true;
      }
      geometry2.uvsNeedUpdate = false;
    }
    if (geometry2.lineDistancesNeedUpdate) {
      attribute = this.attributes.lineDistance;
      if (attribute !== void 0) {
        attribute.copyArray(geometry2.lineDistances);
        attribute.needsUpdate = true;
      }
      geometry2.lineDistancesNeedUpdate = false;
    }
    if (geometry2.groupsNeedUpdate) {
      geometry2.computeGroups(object.geometry);
      this.groups = geometry2.groups;
      geometry2.groupsNeedUpdate = false;
    }
    return this;
  },
  fromGeometry: function(geometry2) {
    geometry2.__directGeometry = new DirectGeometry().fromGeometry(geometry2);
    return this.fromDirectGeometry(geometry2.__directGeometry);
  },
  fromDirectGeometry: function(geometry2) {
    var positions = new Float32Array(geometry2.vertices.length * 3);
    this.addAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry2.vertices));
    if (geometry2.normals.length > 0) {
      var normals = new Float32Array(geometry2.normals.length * 3);
      this.addAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry2.normals));
    }
    if (geometry2.colors.length > 0) {
      var colors = new Float32Array(geometry2.colors.length * 3);
      this.addAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry2.colors));
    }
    if (geometry2.uvs.length > 0) {
      var uvs = new Float32Array(geometry2.uvs.length * 2);
      this.addAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry2.uvs));
    }
    if (geometry2.uvs2.length > 0) {
      var uvs2 = new Float32Array(geometry2.uvs2.length * 2);
      this.addAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry2.uvs2));
    }
    this.groups = geometry2.groups;
    for (var name in geometry2.morphTargets) {
      var array = [];
      var morphTargets = geometry2.morphTargets[name];
      for (var i2 = 0, l2 = morphTargets.length; i2 < l2; i2++) {
        var morphTarget = morphTargets[i2];
        var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
        attribute.name = morphTarget.name;
        array.push(attribute.copyVector3sArray(morphTarget.data));
      }
      this.morphAttributes[name] = array;
    }
    if (geometry2.skinIndices.length > 0) {
      var skinIndices = new Float32BufferAttribute(geometry2.skinIndices.length * 4, 4);
      this.addAttribute("skinIndex", skinIndices.copyVector4sArray(geometry2.skinIndices));
    }
    if (geometry2.skinWeights.length > 0) {
      var skinWeights = new Float32BufferAttribute(geometry2.skinWeights.length * 4, 4);
      this.addAttribute("skinWeight", skinWeights.copyVector4sArray(geometry2.skinWeights));
    }
    if (geometry2.boundingSphere !== null) {
      this.boundingSphere = geometry2.boundingSphere.clone();
    }
    if (geometry2.boundingBox !== null) {
      this.boundingBox = geometry2.boundingBox.clone();
    }
    return this;
  },
  computeBoundingBox: function() {
    var box = new Box3();
    return function computeBoundingBox() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      var position = this.attributes.position;
      var morphAttributesPosition = this.morphAttributes.position;
      if (position !== void 0) {
        this.boundingBox.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (var i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
            var morphAttribute = morphAttributesPosition[i2];
            box.setFromBufferAttribute(morphAttribute);
            this.boundingBox.expandByPoint(box.min);
            this.boundingBox.expandByPoint(box.max);
          }
        }
      } else {
        this.boundingBox.makeEmpty();
      }
      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
        console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
    };
  }(),
  computeBoundingSphere: function() {
    var box = new Box3();
    var boxMorphTargets = new Box3();
    var vector = new Vector3();
    return function computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      var position = this.attributes.position;
      var morphAttributesPosition = this.morphAttributes.position;
      if (position) {
        var center = this.boundingSphere.center;
        box.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (var i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
            var morphAttribute = morphAttributesPosition[i2];
            boxMorphTargets.setFromBufferAttribute(morphAttribute);
            box.expandByPoint(boxMorphTargets.min);
            box.expandByPoint(boxMorphTargets.max);
          }
        }
        box.getCenter(center);
        var maxRadiusSq = 0;
        for (var i2 = 0, il = position.count; i2 < il; i2++) {
          vector.fromBufferAttribute(position, i2);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
        }
        if (morphAttributesPosition) {
          for (var i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
            var morphAttribute = morphAttributesPosition[i2];
            for (var j = 0, jl = morphAttribute.count; j < jl; j++) {
              vector.fromBufferAttribute(morphAttribute, j);
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
            }
          }
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    };
  }(),
  computeFaceNormals: function() {
  },
  computeVertexNormals: function() {
    var index2 = this.index;
    var attributes = this.attributes;
    if (attributes.position) {
      var positions = attributes.position.array;
      if (attributes.normal === void 0) {
        this.addAttribute("normal", new BufferAttribute(new Float32Array(positions.length), 3));
      } else {
        var array = attributes.normal.array;
        for (var i2 = 0, il = array.length; i2 < il; i2++) {
          array[i2] = 0;
        }
      }
      var normals = attributes.normal.array;
      var vA, vB, vC;
      var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      var cb = new Vector3(), ab = new Vector3();
      if (index2) {
        var indices = index2.array;
        for (var i2 = 0, il = index2.count; i2 < il; i2 += 3) {
          vA = indices[i2 + 0] * 3;
          vB = indices[i2 + 1] * 3;
          vC = indices[i2 + 2] * 3;
          pA.fromArray(positions, vA);
          pB.fromArray(positions, vB);
          pC.fromArray(positions, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normals[vA] += cb.x;
          normals[vA + 1] += cb.y;
          normals[vA + 2] += cb.z;
          normals[vB] += cb.x;
          normals[vB + 1] += cb.y;
          normals[vB + 2] += cb.z;
          normals[vC] += cb.x;
          normals[vC + 1] += cb.y;
          normals[vC + 2] += cb.z;
        }
      } else {
        for (var i2 = 0, il = positions.length; i2 < il; i2 += 9) {
          pA.fromArray(positions, i2);
          pB.fromArray(positions, i2 + 3);
          pC.fromArray(positions, i2 + 6);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normals[i2] = cb.x;
          normals[i2 + 1] = cb.y;
          normals[i2 + 2] = cb.z;
          normals[i2 + 3] = cb.x;
          normals[i2 + 4] = cb.y;
          normals[i2 + 5] = cb.z;
          normals[i2 + 6] = cb.x;
          normals[i2 + 7] = cb.y;
          normals[i2 + 8] = cb.z;
        }
      }
      this.normalizeNormals();
      attributes.normal.needsUpdate = true;
    }
  },
  merge: function(geometry2, offset2) {
    if (!(geometry2 && geometry2.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry2);
      return;
    }
    if (offset2 === void 0) {
      offset2 = 0;
      console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
    }
    var attributes = this.attributes;
    for (var key in attributes) {
      if (geometry2.attributes[key] === void 0)
        continue;
      var attribute1 = attributes[key];
      var attributeArray1 = attribute1.array;
      var attribute2 = geometry2.attributes[key];
      var attributeArray2 = attribute2.array;
      var attributeOffset = attribute2.itemSize * offset2;
      var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
      for (var i2 = 0, j = attributeOffset; i2 < length; i2++, j++) {
        attributeArray1[j] = attributeArray2[i2];
      }
    }
    return this;
  },
  normalizeNormals: function() {
    var vector = new Vector3();
    return function normalizeNormals() {
      var normals = this.attributes.normal;
      for (var i2 = 0, il = normals.count; i2 < il; i2++) {
        vector.x = normals.getX(i2);
        vector.y = normals.getY(i2);
        vector.z = normals.getZ(i2);
        vector.normalize();
        normals.setXYZ(i2, vector.x, vector.y, vector.z);
      }
    };
  }(),
  toNonIndexed: function() {
    function convertBufferAttribute(attribute2, indices2) {
      var array = attribute2.array;
      var itemSize = attribute2.itemSize;
      var array2 = new array.constructor(indices2.length * itemSize);
      var index2 = 0, index22 = 0;
      for (var i3 = 0, l3 = indices2.length; i3 < l3; i3++) {
        index2 = indices2[i3] * itemSize;
        for (var j = 0; j < itemSize; j++) {
          array2[index22++] = array[index2++];
        }
      }
      return new BufferAttribute(array2, itemSize);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.");
      return this;
    }
    var geometry2 = new BufferGeometry();
    var indices = this.index.array;
    var attributes = this.attributes;
    for (var name in attributes) {
      var attribute = attributes[name];
      var newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.addAttribute(name, newAttribute);
    }
    var morphAttributes = this.morphAttributes;
    for (name in morphAttributes) {
      var morphArray = [];
      var morphAttribute = morphAttributes[name];
      for (var i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
        var attribute = morphAttribute[i2];
        var newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    var groups = this.groups;
    for (var i2 = 0, l2 = groups.length; i2 < l2; i2++) {
      var group = groups[i2];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  },
  toJSON: function() {
    var data = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    if (this.parameters !== void 0) {
      var parameters = this.parameters;
      for (var key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    var index2 = this.index;
    if (index2 !== null) {
      data.data.index = {
        type: index2.array.constructor.name,
        array: Array.prototype.slice.call(index2.array)
      };
    }
    var attributes = this.attributes;
    for (var key in attributes) {
      var attribute = attributes[key];
      var attributeData = attribute.toJSON();
      if (attribute.name !== "")
        attributeData.name = attribute.name;
      data.data.attributes[key] = attributeData;
    }
    var morphAttributes = {};
    var hasMorphAttributes = false;
    for (var key in this.morphAttributes) {
      var attributeArray = this.morphAttributes[key];
      var array = [];
      for (var i2 = 0, il = attributeArray.length; i2 < il; i2++) {
        var attribute = attributeArray[i2];
        var attributeData = attribute.toJSON();
        if (attribute.name !== "")
          attributeData.name = attribute.name;
        array.push(attributeData);
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes)
      data.data.morphAttributes = morphAttributes;
    var groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    var boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  },
  clone: function() {
    return new BufferGeometry().copy(this);
  },
  copy: function(source) {
    var name, i2, l2;
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.name = source.name;
    var index2 = source.index;
    if (index2 !== null) {
      this.setIndex(index2.clone());
    }
    var attributes = source.attributes;
    for (name in attributes) {
      var attribute = attributes[name];
      this.addAttribute(name, attribute.clone());
    }
    var morphAttributes = source.morphAttributes;
    for (name in morphAttributes) {
      var array = [];
      var morphAttribute = morphAttributes[name];
      for (i2 = 0, l2 = morphAttribute.length; i2 < l2; i2++) {
        array.push(morphAttribute[i2].clone());
      }
      this.morphAttributes[name] = array;
    }
    var groups = source.groups;
    for (i2 = 0, l2 = groups.length; i2 < l2; i2++) {
      var group = groups[i2];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    var boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    var boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
  Geometry.call(this);
  this.type = "BoxGeometry";
  this.parameters = {
    width,
    height,
    depth,
    widthSegments,
    heightSegments,
    depthSegments
  };
  this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
  this.mergeVertices();
}
BoxGeometry.prototype = Object.create(Geometry.prototype);
BoxGeometry.prototype.constructor = BoxGeometry;
function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
  BufferGeometry.call(this);
  this.type = "BoxBufferGeometry";
  this.parameters = {
    width,
    height,
    depth,
    widthSegments,
    heightSegments,
    depthSegments
  };
  var scope = this;
  width = width || 1;
  height = height || 1;
  depth = depth || 1;
  widthSegments = Math.floor(widthSegments) || 1;
  heightSegments = Math.floor(heightSegments) || 1;
  depthSegments = Math.floor(depthSegments) || 1;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var numberOfVertices = 0;
  var groupStart = 0;
  buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
  buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
  buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
  buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
  buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
  buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function buildPlane(u2, v2, w2, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
    var segmentWidth = width2 / gridX;
    var segmentHeight = height2 / gridY;
    var widthHalf = width2 / 2;
    var heightHalf = height2 / 2;
    var depthHalf = depth2 / 2;
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var vertexCounter = 0;
    var groupCount = 0;
    var ix, iy;
    var vector = new Vector3();
    for (iy = 0; iy < gridY1; iy++) {
      var y = iy * segmentHeight - heightHalf;
      for (ix = 0; ix < gridX1; ix++) {
        var x2 = ix * segmentWidth - widthHalf;
        vector[u2] = x2 * udir;
        vector[v2] = y * vdir;
        vector[w2] = depthHalf;
        vertices.push(vector.x, vector.y, vector.z);
        vector[u2] = 0;
        vector[v2] = 0;
        vector[w2] = depth2 > 0 ? 1 : -1;
        normals.push(vector.x, vector.y, vector.z);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
        vertexCounter += 1;
      }
    }
    for (iy = 0; iy < gridY; iy++) {
      for (ix = 0; ix < gridX; ix++) {
        var a2 = numberOfVertices + ix + gridX1 * iy;
        var b2 = numberOfVertices + ix + gridX1 * (iy + 1);
        var c2 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
        var d2 = numberOfVertices + (ix + 1) + gridX1 * iy;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
        groupCount += 6;
      }
    }
    scope.addGroup(groupStart, groupCount, materialIndex);
    groupStart += groupCount;
    numberOfVertices += vertexCounter;
  }
}
BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
function PlaneGeometry(width, height, widthSegments, heightSegments) {
  Geometry.call(this);
  this.type = "PlaneGeometry";
  this.parameters = {
    width,
    height,
    widthSegments,
    heightSegments
  };
  this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
  this.mergeVertices();
}
PlaneGeometry.prototype = Object.create(Geometry.prototype);
PlaneGeometry.prototype.constructor = PlaneGeometry;
function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
  BufferGeometry.call(this);
  this.type = "PlaneBufferGeometry";
  this.parameters = {
    width,
    height,
    widthSegments,
    heightSegments
  };
  width = width || 1;
  height = height || 1;
  var width_half = width / 2;
  var height_half = height / 2;
  var gridX = Math.floor(widthSegments) || 1;
  var gridY = Math.floor(heightSegments) || 1;
  var gridX1 = gridX + 1;
  var gridY1 = gridY + 1;
  var segment_width = width / gridX;
  var segment_height = height / gridY;
  var ix, iy;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  for (iy = 0; iy < gridY1; iy++) {
    var y = iy * segment_height - height_half;
    for (ix = 0; ix < gridX1; ix++) {
      var x2 = ix * segment_width - width_half;
      vertices.push(x2, -y, 0);
      normals.push(0, 0, 1);
      uvs.push(ix / gridX);
      uvs.push(1 - iy / gridY);
    }
  }
  for (iy = 0; iy < gridY; iy++) {
    for (ix = 0; ix < gridX; ix++) {
      var a2 = ix + gridX1 * iy;
      var b2 = ix + gridX1 * (iy + 1);
      var c2 = ix + 1 + gridX1 * (iy + 1);
      var d2 = ix + 1 + gridX1 * iy;
      indices.push(a2, b2, d2);
      indices.push(b2, c2, d2);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
var materialId = 0;
function Material() {
  Object.defineProperty(this, "id", { value: materialId++ });
  this.uuid = _Math.generateUUID();
  this.name = "";
  this.type = "Material";
  this.fog = true;
  this.lights = true;
  this.blending = NormalBlending;
  this.side = FrontSide;
  this.flatShading = false;
  this.vertexTangents = false;
  this.vertexColors = NoColors;
  this.opacity = 1;
  this.transparent = false;
  this.blendSrc = SrcAlphaFactor;
  this.blendDst = OneMinusSrcAlphaFactor;
  this.blendEquation = AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;
  this.depthFunc = LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;
  this.clippingPlanes = null;
  this.clipIntersection = false;
  this.clipShadows = false;
  this.shadowSide = null;
  this.colorWrite = true;
  this.precision = null;
  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.dithering = false;
  this.alphaTest = 0;
  this.premultipliedAlpha = false;
  this.visible = true;
  this.userData = {};
  this.needsUpdate = true;
}
Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Material,
  isMaterial: true,
  onBeforeCompile: function() {
  },
  setValues: function(values) {
    if (values === void 0)
      return;
    for (var key in values) {
      var newValue = values[key];
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      }
      if (key === "shading") {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }
      var currentValue = this[key];
      if (currentValue === void 0) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  },
  toJSON: function(meta) {
    var isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }
    var data = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.color && this.color.isColor)
      data.color = this.color.getHex();
    if (this.roughness !== void 0)
      data.roughness = this.roughness;
    if (this.metalness !== void 0)
      data.metalness = this.metalness;
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex();
    if (this.shininess !== void 0)
      data.shininess = this.shininess;
    if (this.clearCoat !== void 0)
      data.clearCoat = this.clearCoat;
    if (this.clearCoatRoughness !== void 0)
      data.clearCoatRoughness = this.clearCoatRoughness;
    if (this.map && this.map.isTexture)
      data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture)
      data.lightMap = this.lightMap.toJSON(meta).uuid;
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      data.reflectivity = this.reflectivity;
      if (this.combine !== void 0)
        data.combine = this.combine;
      if (this.envMapIntensity !== void 0)
        data.envMapIntensity = this.envMapIntensity;
    }
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.size !== void 0)
      data.size = this.size;
    if (this.sizeAttenuation !== void 0)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending)
      data.blending = this.blending;
    if (this.flatShading === true)
      data.flatShading = this.flatShading;
    if (this.side !== FrontSide)
      data.side = this.side;
    if (this.vertexColors !== NoColors)
      data.vertexColors = this.vertexColors;
    if (this.opacity < 1)
      data.opacity = this.opacity;
    if (this.transparent === true)
      data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    if (this.rotation !== 0)
      data.rotation = this.rotation;
    if (this.polygonOffset === true)
      data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== 1)
      data.linewidth = this.linewidth;
    if (this.dashSize !== void 0)
      data.dashSize = this.dashSize;
    if (this.gapSize !== void 0)
      data.gapSize = this.gapSize;
    if (this.scale !== void 0)
      data.scale = this.scale;
    if (this.dithering === true)
      data.dithering = true;
    if (this.alphaTest > 0)
      data.alphaTest = this.alphaTest;
    if (this.premultipliedAlpha === true)
      data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true)
      data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.morphTargets === true)
      data.morphTargets = true;
    if (this.skinning === true)
      data.skinning = true;
    if (this.visible === false)
      data.visible = false;
    if (JSON.stringify(this.userData) !== "{}")
      data.userData = this.userData;
    function extractFromCache(cache) {
      var values = [];
      for (var key in cache) {
        var data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      var textures = extractFromCache(meta.textures);
      var images2 = extractFromCache(meta.images);
      if (textures.length > 0)
        data.textures = textures;
      if (images2.length > 0)
        data.images = images2;
    }
    return data;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.name = source.name;
    this.fog = source.fog;
    this.lights = source.lights;
    this.blending = source.blending;
    this.side = source.side;
    this.flatShading = source.flatShading;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.clipShadows = source.clipShadows;
    this.clipIntersection = source.clipIntersection;
    var srcPlanes = source.clippingPlanes, dstPlanes = null;
    if (srcPlanes !== null) {
      var n2 = srcPlanes.length;
      dstPlanes = new Array(n2);
      for (var i2 = 0; i2 !== n2; ++i2)
        dstPlanes[i2] = srcPlanes[i2].clone();
    }
    this.clippingPlanes = dstPlanes;
    this.shadowSide = source.shadowSide;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
function ShaderMaterial(parameters) {
  Material.call(this);
  this.type = "ShaderMaterial";
  this.defines = {};
  this.uniforms = {};
  this.vertexShader = default_vertex;
  this.fragmentShader = default_fragment;
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.clipping = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.extensions = {
    derivatives: false,
    fragDepth: false,
    drawBuffers: false,
    shaderTextureLOD: false
  };
  this.defaultAttributeValues = {
    "color": [1, 1, 1],
    "uv": [0, 0],
    "uv2": [0, 0]
  };
  this.index0AttributeName = void 0;
  this.uniformsNeedUpdate = false;
  if (parameters !== void 0) {
    if (parameters.attributes !== void 0) {
      console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
    }
    this.setValues(parameters);
  }
}
ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;
ShaderMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;
  this.uniforms = cloneUniforms(source.uniforms);
  this.defines = Object.assign({}, source.defines);
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.lights = source.lights;
  this.clipping = source.clipping;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.extensions = source.extensions;
  return this;
};
ShaderMaterial.prototype.toJSON = function(meta) {
  var data = Material.prototype.toJSON.call(this, meta);
  data.uniforms = {};
  for (var name in this.uniforms) {
    var uniform = this.uniforms[name];
    var value = uniform.value;
    if (value && value.isTexture) {
      data.uniforms[name] = {
        type: "t",
        value: value.toJSON(meta).uuid
      };
    } else if (value && value.isColor) {
      data.uniforms[name] = {
        type: "c",
        value: value.getHex()
      };
    } else if (value && value.isVector2) {
      data.uniforms[name] = {
        type: "v2",
        value: value.toArray()
      };
    } else if (value && value.isVector3) {
      data.uniforms[name] = {
        type: "v3",
        value: value.toArray()
      };
    } else if (value && value.isVector4) {
      data.uniforms[name] = {
        type: "v4",
        value: value.toArray()
      };
    } else if (value && value.isMatrix3) {
      data.uniforms[name] = {
        type: "m3",
        value: value.toArray()
      };
    } else if (value && value.isMatrix4) {
      data.uniforms[name] = {
        type: "m4",
        value: value.toArray()
      };
    } else {
      data.uniforms[name] = {
        value
      };
    }
  }
  if (Object.keys(this.defines).length > 0)
    data.defines = this.defines;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;
  var extensions = {};
  for (var key in this.extensions) {
    if (this.extensions[key] === true)
      extensions[key] = true;
  }
  if (Object.keys(extensions).length > 0)
    data.extensions = extensions;
  return data;
};
function Ray(origin, direction) {
  this.origin = origin !== void 0 ? origin : new Vector3();
  this.direction = direction !== void 0 ? direction : new Vector3();
}
Object.assign(Ray.prototype, {
  set: function(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  },
  at: function(t2, target) {
    if (target === void 0) {
      console.warn("THREE.Ray: .at() target is now required");
      target = new Vector3();
    }
    return target.copy(this.direction).multiplyScalar(t2).add(this.origin);
  },
  lookAt: function(v2) {
    this.direction.copy(v2).sub(this.origin).normalize();
    return this;
  },
  recast: function() {
    var v1 = new Vector3();
    return function recast(t2) {
      this.origin.copy(this.at(t2, v1));
      return this;
    };
  }(),
  closestPointToPoint: function(point, target) {
    if (target === void 0) {
      console.warn("THREE.Ray: .closestPointToPoint() target is now required");
      target = new Vector3();
    }
    target.subVectors(point, this.origin);
    var directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  },
  distanceToPoint: function(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  },
  distanceSqToPoint: function() {
    var v1 = new Vector3();
    return function distanceSqToPoint(point) {
      var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }
      v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      return v1.distanceToSquared(point);
    };
  }(),
  distanceSqToSegment: function() {
    var segCenter = new Vector3();
    var segDir = new Vector3();
    var diff = new Vector3();
    return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      segDir.copy(v1).sub(v0).normalize();
      diff.copy(this.origin).sub(segCenter);
      var segExtent = v0.distanceTo(v1) * 0.5;
      var a01 = -this.direction.dot(segDir);
      var b0 = diff.dot(this.direction);
      var b1 = -diff.dot(segDir);
      var c2 = diff.lengthSq();
      var det = Math.abs(1 - a01 * a01);
      var s0, s1, sqrDist, extDet;
      if (det > 0) {
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;
        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              var invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c2;
            } else {
              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
            }
          } else {
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
          }
        } else {
          if (s1 <= -extDet) {
            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
          } else if (s1 <= extDet) {
            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c2;
          } else {
            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
          }
        }
      } else {
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
      }
      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
      }
      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
      }
      return sqrDist;
    };
  }(),
  intersectSphere: function() {
    var v1 = new Vector3();
    return function intersectSphere(sphere, target) {
      v1.subVectors(sphere.center, this.origin);
      var tca = v1.dot(this.direction);
      var d2 = v1.dot(v1) - tca * tca;
      var radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2)
        return null;
      var thc = Math.sqrt(radius2 - d2);
      var t0 = tca - thc;
      var t1 = tca + thc;
      if (t0 < 0 && t1 < 0)
        return null;
      if (t0 < 0)
        return this.at(t1, target);
      return this.at(t0, target);
    };
  }(),
  intersectsSphere: function(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  },
  distanceToPlane: function(plane) {
    var denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    var t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t2 >= 0 ? t2 : null;
  },
  intersectPlane: function(plane, target) {
    var t2 = this.distanceToPlane(plane);
    if (t2 === null) {
      return null;
    }
    return this.at(t2, target);
  },
  intersectsPlane: function(plane) {
    var distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    var denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  },
  intersectBox: function(box, target) {
    var tmin, tmax, tymin, tymax, tzmin, tzmax;
    var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    var origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || tmin !== tmin)
      tmin = tymin;
    if (tymax < tmax || tmax !== tmax)
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  },
  intersectsBox: function() {
    var v2 = new Vector3();
    return function intersectsBox(box) {
      return this.intersectBox(box, v2) !== null;
    };
  }(),
  intersectTriangle: function() {
    var diff = new Vector3();
    var edge1 = new Vector3();
    var edge2 = new Vector3();
    var normal = new Vector3();
    return function intersectTriangle(a2, b2, c2, backfaceCulling, target) {
      edge1.subVectors(b2, a2);
      edge2.subVectors(c2, a2);
      normal.crossVectors(edge1, edge2);
      var DdN = this.direction.dot(normal);
      var sign;
      if (DdN > 0) {
        if (backfaceCulling)
          return null;
        sign = 1;
      } else if (DdN < 0) {
        sign = -1;
        DdN = -DdN;
      } else {
        return null;
      }
      diff.subVectors(this.origin, a2);
      var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
      if (DdQxE2 < 0) {
        return null;
      }
      var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
      if (DdE1xQ < 0) {
        return null;
      }
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }
      var QdN = -sign * diff.dot(normal);
      if (QdN < 0) {
        return null;
      }
      return this.at(QdN / DdN, target);
    };
  }(),
  applyMatrix4: function(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  },
  equals: function(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
});
function Triangle(a2, b2, c2) {
  this.a = a2 !== void 0 ? a2 : new Vector3();
  this.b = b2 !== void 0 ? b2 : new Vector3();
  this.c = c2 !== void 0 ? c2 : new Vector3();
}
Object.assign(Triangle, {
  getNormal: function() {
    var v0 = new Vector3();
    return function getNormal(a2, b2, c2, target) {
      if (target === void 0) {
        console.warn("THREE.Triangle: .getNormal() target is now required");
        target = new Vector3();
      }
      target.subVectors(c2, b2);
      v0.subVectors(a2, b2);
      target.cross(v0);
      var targetLengthSq = target.lengthSq();
      if (targetLengthSq > 0) {
        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
      }
      return target.set(0, 0, 0);
    };
  }(),
  getBarycoord: function() {
    var v0 = new Vector3();
    var v1 = new Vector3();
    var v2 = new Vector3();
    return function getBarycoord(point, a2, b2, c2, target) {
      v0.subVectors(c2, a2);
      v1.subVectors(b2, a2);
      v2.subVectors(point, a2);
      var dot00 = v0.dot(v0);
      var dot01 = v0.dot(v1);
      var dot02 = v0.dot(v2);
      var dot11 = v1.dot(v1);
      var dot12 = v1.dot(v2);
      var denom = dot00 * dot11 - dot01 * dot01;
      if (target === void 0) {
        console.warn("THREE.Triangle: .getBarycoord() target is now required");
        target = new Vector3();
      }
      if (denom === 0) {
        return target.set(-2, -1, -1);
      }
      var invDenom = 1 / denom;
      var u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
      var v3 = (dot00 * dot12 - dot01 * dot02) * invDenom;
      return target.set(1 - u2 - v3, v3, u2);
    };
  }(),
  containsPoint: function() {
    var v1 = new Vector3();
    return function containsPoint(point, a2, b2, c2) {
      Triangle.getBarycoord(point, a2, b2, c2, v1);
      return v1.x >= 0 && v1.y >= 0 && v1.x + v1.y <= 1;
    };
  }(),
  getUV: function() {
    var barycoord = new Vector3();
    return function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
      this.getBarycoord(point, p1, p2, p3, barycoord);
      target.set(0, 0);
      target.addScaledVector(uv1, barycoord.x);
      target.addScaledVector(uv2, barycoord.y);
      target.addScaledVector(uv3, barycoord.z);
      return target;
    };
  }(),
  isFrontFacing: function() {
    var v0 = new Vector3();
    var v1 = new Vector3();
    return function isFrontFacing(a2, b2, c2, direction) {
      v0.subVectors(c2, b2);
      v1.subVectors(a2, b2);
      return v0.cross(v1).dot(direction) < 0 ? true : false;
    };
  }()
});
Object.assign(Triangle.prototype, {
  set: function(a2, b2, c2) {
    this.a.copy(a2);
    this.b.copy(b2);
    this.c.copy(c2);
    return this;
  },
  setFromPointsAndIndices: function(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  },
  getArea: function() {
    var v0 = new Vector3();
    var v1 = new Vector3();
    return function getArea() {
      v0.subVectors(this.c, this.b);
      v1.subVectors(this.a, this.b);
      return v0.cross(v1).length() * 0.5;
    };
  }(),
  getMidpoint: function(target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getMidpoint() target is now required");
      target = new Vector3();
    }
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  getNormal: function(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  },
  getPlane: function(target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getPlane() target is now required");
      target = new Vector3();
    }
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  },
  getBarycoord: function(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  },
  getUV: function(point, uv1, uv2, uv3, target) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  },
  containsPoint: function(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  },
  isFrontFacing: function(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  },
  intersectsBox: function(box) {
    return box.intersectsTriangle(this);
  },
  closestPointToPoint: function() {
    var vab = new Vector3();
    var vac = new Vector3();
    var vbc = new Vector3();
    var vap = new Vector3();
    var vbp = new Vector3();
    var vcp = new Vector3();
    return function closestPointToPoint(p2, target) {
      if (target === void 0) {
        console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
        target = new Vector3();
      }
      var a2 = this.a, b2 = this.b, c2 = this.c;
      var v2, w2;
      vab.subVectors(b2, a2);
      vac.subVectors(c2, a2);
      vap.subVectors(p2, a2);
      var d1 = vab.dot(vap);
      var d2 = vac.dot(vap);
      if (d1 <= 0 && d2 <= 0) {
        return target.copy(a2);
      }
      vbp.subVectors(p2, b2);
      var d3 = vab.dot(vbp);
      var d4 = vac.dot(vbp);
      if (d3 >= 0 && d4 <= d3) {
        return target.copy(b2);
      }
      var vc = d1 * d4 - d3 * d2;
      if (vc <= 0 && d1 >= 0 && d3 <= 0) {
        v2 = d1 / (d1 - d3);
        return target.copy(a2).addScaledVector(vab, v2);
      }
      vcp.subVectors(p2, c2);
      var d5 = vab.dot(vcp);
      var d6 = vac.dot(vcp);
      if (d6 >= 0 && d5 <= d6) {
        return target.copy(c2);
      }
      var vb = d5 * d2 - d1 * d6;
      if (vb <= 0 && d2 >= 0 && d6 <= 0) {
        w2 = d2 / (d2 - d6);
        return target.copy(a2).addScaledVector(vac, w2);
      }
      var va = d3 * d6 - d5 * d4;
      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
        vbc.subVectors(c2, b2);
        w2 = (d4 - d3) / (d4 - d3 + (d5 - d6));
        return target.copy(b2).addScaledVector(vbc, w2);
      }
      var denom = 1 / (va + vb + vc);
      v2 = vb * denom;
      w2 = vc * denom;
      return target.copy(a2).addScaledVector(vab, v2).addScaledVector(vac, w2);
    };
  }(),
  equals: function(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
});
function MeshBasicMaterial(parameters) {
  Material.call(this);
  this.type = "MeshBasicMaterial";
  this.color = new Color(16777215);
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.lights = false;
  this.setValues(parameters);
}
MeshBasicMaterial.prototype = Object.create(Material.prototype);
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
MeshBasicMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  return this;
};
function Mesh(geometry2, material) {
  Object3D.call(this);
  this.type = "Mesh";
  this.geometry = geometry2 !== void 0 ? geometry2 : new BufferGeometry();
  this.material = material !== void 0 ? material : new MeshBasicMaterial({ color: Math.random() * 16777215 });
  this.drawMode = TrianglesDrawMode;
  this.updateMorphTargets();
}
Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Mesh,
  isMesh: true,
  setDrawMode: function(value) {
    this.drawMode = value;
  },
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.drawMode = source.drawMode;
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    return this;
  },
  updateMorphTargets: function() {
    var geometry2 = this.geometry;
    var m2, ml, name;
    if (geometry2.isBufferGeometry) {
      var morphAttributes = geometry2.morphAttributes;
      var keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        var morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            name = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m2;
          }
        }
      }
    } else {
      var morphTargets = geometry2.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  },
  raycast: function() {
    var inverseMatrix = new Matrix4();
    var ray = new Ray();
    var sphere = new Sphere();
    var vA = new Vector3();
    var vB = new Vector3();
    var vC = new Vector3();
    var tempA = new Vector3();
    var tempB = new Vector3();
    var tempC = new Vector3();
    var morphA = new Vector3();
    var morphB = new Vector3();
    var morphC = new Vector3();
    var uvA = new Vector2();
    var uvB = new Vector2();
    var uvC = new Vector2();
    var intersectionPoint = new Vector3();
    var intersectionPointWorld = new Vector3();
    function checkIntersection(object, material, raycaster, ray2, pA, pB, pC, point) {
      var intersect;
      if (material.side === BackSide) {
        intersect = ray2.intersectTriangle(pC, pB, pA, true, point);
      } else {
        intersect = ray2.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
      }
      if (intersect === null)
        return null;
      intersectionPointWorld.copy(point);
      intersectionPointWorld.applyMatrix4(object.matrixWorld);
      var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
      if (distance < raycaster.near || distance > raycaster.far)
        return null;
      return {
        distance,
        point: intersectionPointWorld.clone(),
        object
      };
    }
    function checkBufferGeometryIntersection(object, material, raycaster, ray2, position, morphPosition, uv, a2, b2, c2) {
      vA.fromBufferAttribute(position, a2);
      vB.fromBufferAttribute(position, b2);
      vC.fromBufferAttribute(position, c2);
      var morphInfluences = object.morphTargetInfluences;
      if (material.morphTargets && morphPosition && morphInfluences) {
        morphA.set(0, 0, 0);
        morphB.set(0, 0, 0);
        morphC.set(0, 0, 0);
        for (var i2 = 0, il = morphPosition.length; i2 < il; i2++) {
          var influence = morphInfluences[i2];
          var morphAttribute = morphPosition[i2];
          if (influence === 0)
            continue;
          tempA.fromBufferAttribute(morphAttribute, a2);
          tempB.fromBufferAttribute(morphAttribute, b2);
          tempC.fromBufferAttribute(morphAttribute, c2);
          morphA.addScaledVector(tempA.sub(vA), influence);
          morphB.addScaledVector(tempB.sub(vB), influence);
          morphC.addScaledVector(tempC.sub(vC), influence);
        }
        vA.add(morphA);
        vB.add(morphB);
        vC.add(morphC);
      }
      var intersection = checkIntersection(object, material, raycaster, ray2, vA, vB, vC, intersectionPoint);
      if (intersection) {
        if (uv) {
          uvA.fromBufferAttribute(uv, a2);
          uvB.fromBufferAttribute(uv, b2);
          uvC.fromBufferAttribute(uv, c2);
          intersection.uv = Triangle.getUV(intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2());
        }
        var face = new Face3(a2, b2, c2);
        Triangle.getNormal(vA, vB, vC, face.normal);
        intersection.face = face;
      }
      return intersection;
    }
    return function raycast(raycaster, intersects2) {
      var geometry2 = this.geometry;
      var material = this.material;
      var matrixWorld = this.matrixWorld;
      if (material === void 0)
        return;
      if (geometry2.boundingSphere === null)
        geometry2.computeBoundingSphere();
      sphere.copy(geometry2.boundingSphere);
      sphere.applyMatrix4(matrixWorld);
      if (raycaster.ray.intersectsSphere(sphere) === false)
        return;
      inverseMatrix.getInverse(matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      if (geometry2.boundingBox !== null) {
        if (ray.intersectsBox(geometry2.boundingBox) === false)
          return;
      }
      var intersection;
      if (geometry2.isBufferGeometry) {
        var a2, b2, c2;
        var index2 = geometry2.index;
        var position = geometry2.attributes.position;
        var morphPosition = geometry2.morphAttributes.position;
        var uv = geometry2.attributes.uv;
        var groups = geometry2.groups;
        var drawRange = geometry2.drawRange;
        var i2, j, il, jl;
        var group, groupMaterial;
        var start, end;
        if (index2 !== null) {
          if (Array.isArray(material)) {
            for (i2 = 0, il = groups.length; i2 < il; i2++) {
              group = groups[i2];
              groupMaterial = material[group.materialIndex];
              start = Math.max(group.start, drawRange.start);
              end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
              for (j = start, jl = end; j < jl; j += 3) {
                a2 = index2.getX(j);
                b2 = index2.getX(j + 1);
                c2 = index2.getX(j + 2);
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, morphPosition, uv, a2, b2, c2);
                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3);
                  intersection.face.materialIndex = group.materialIndex;
                  intersects2.push(intersection);
                }
              }
            }
          } else {
            start = Math.max(0, drawRange.start);
            end = Math.min(index2.count, drawRange.start + drawRange.count);
            for (i2 = start, il = end; i2 < il; i2 += 3) {
              a2 = index2.getX(i2);
              b2 = index2.getX(i2 + 1);
              c2 = index2.getX(i2 + 2);
              intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, morphPosition, uv, a2, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(i2 / 3);
                intersects2.push(intersection);
              }
            }
          }
        } else if (position !== void 0) {
          if (Array.isArray(material)) {
            for (i2 = 0, il = groups.length; i2 < il; i2++) {
              group = groups[i2];
              groupMaterial = material[group.materialIndex];
              start = Math.max(group.start, drawRange.start);
              end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
              for (j = start, jl = end; j < jl; j += 3) {
                a2 = j;
                b2 = j + 1;
                c2 = j + 2;
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, morphPosition, uv, a2, b2, c2);
                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3);
                  intersection.face.materialIndex = group.materialIndex;
                  intersects2.push(intersection);
                }
              }
            }
          } else {
            start = Math.max(0, drawRange.start);
            end = Math.min(position.count, drawRange.start + drawRange.count);
            for (i2 = start, il = end; i2 < il; i2 += 3) {
              a2 = i2;
              b2 = i2 + 1;
              c2 = i2 + 2;
              intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, morphPosition, uv, a2, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(i2 / 3);
                intersects2.push(intersection);
              }
            }
          }
        }
      } else if (geometry2.isGeometry) {
        var fvA, fvB, fvC;
        var isMultiMaterial = Array.isArray(material);
        var vertices = geometry2.vertices;
        var faces = geometry2.faces;
        var uvs;
        var faceVertexUvs = geometry2.faceVertexUvs[0];
        if (faceVertexUvs.length > 0)
          uvs = faceVertexUvs;
        for (var f2 = 0, fl = faces.length; f2 < fl; f2++) {
          var face = faces[f2];
          var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
          if (faceMaterial === void 0)
            continue;
          fvA = vertices[face.a];
          fvB = vertices[face.b];
          fvC = vertices[face.c];
          intersection = checkIntersection(this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
          if (intersection) {
            if (uvs && uvs[f2]) {
              var uvs_f = uvs[f2];
              uvA.copy(uvs_f[0]);
              uvB.copy(uvs_f[1]);
              uvC.copy(uvs_f[2]);
              intersection.uv = Triangle.getUV(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2());
            }
            intersection.face = face;
            intersection.faceIndex = f2;
            intersects2.push(intersection);
          }
        }
      }
    };
  }(),
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function WebGLBackground(renderer, state, objects, premultipliedAlpha) {
  var clearColor = new Color(0);
  var clearAlpha = 0;
  var planeMesh;
  var boxMesh;
  var currentBackground = null;
  var currentBackgroundVersion = 0;
  function render3(renderList2, scene, camera, forceClear) {
    var background = scene.background;
    var vr = renderer.vr;
    var session = vr.getSession && vr.getSession();
    if (session && session.environmentBlendMode === "additive") {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
      currentBackground = null;
      currentBackgroundVersion = 0;
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
      currentBackground = null;
      currentBackgroundVersion = 0;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.isWebGLRenderTargetCube)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
          type: "BackgroundCubeMaterial",
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.removeAttribute("normal");
        boxMesh.geometry.removeAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera2) {
          this.matrixWorld.copyPosition(camera2.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "map", {
          get: function() {
            return this.uniforms.tCube.value;
          }
        });
        objects.update(boxMesh);
      }
      var texture = background.isWebGLRenderTargetCube ? background.texture : background;
      boxMesh.material.uniforms.tCube.value = texture;
      boxMesh.material.uniforms.tFlip.value = background.isWebGLRenderTargetCube ? 1 : -1;
      if (currentBackground !== background || currentBackgroundVersion !== texture.version) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = texture.version;
      }
      renderList2.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({
          type: "BackgroundMaterial",
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.removeAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
      }
      renderList2.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha) {
      clearColor.set(color);
      clearAlpha = alpha !== void 0 ? alpha : 1;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render: render3
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  var mode;
  function setMode(value) {
    mode = value;
  }
  function render3(start, count2) {
    gl.drawArrays(mode, start, count2);
    info.update(count2, mode);
  }
  function renderInstances(geometry2, start, count2) {
    var extension;
    if (capabilities.isWebGL2) {
      extension = gl;
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[capabilities.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](mode, start, count2, geometry2.maxInstancedCount);
    info.update(count2, mode, geometry2.maxInstancedCount);
  }
  this.setMode = setMode;
  this.render = render3;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
  var maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    var extension = extensions.get("EXT_texture_filter_anisotropic");
    if (extension !== null) {
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  var isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext;
  var precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  var maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  var maxTextures = gl.getParameter(34930);
  var maxVertexTextures = gl.getParameter(35660);
  var maxTextureSize = gl.getParameter(3379);
  var maxCubemapSize = gl.getParameter(34076);
  var maxAttributes = gl.getParameter(34921);
  var maxVertexUniforms = gl.getParameter(36347);
  var maxVaryings = gl.getParameter(36348);
  var maxFragmentUniforms = gl.getParameter(36349);
  var vertexTextures = maxVertexTextures > 0;
  var floatFragmentTextures = isWebGL2 || !!extensions.get("OES_texture_float");
  var floatVertexTextures = vertexTextures && floatFragmentTextures;
  var maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping() {
  var scope = this, globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false, plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera) {
    var enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(planes, clipIntersection, clipShadows, camera, cache, fromCache) {
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4, dstArray = cache.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
      for (var i2 = 0; i2 !== lGlobal; ++i2) {
        dstArray[i2] = globalState[i2];
      }
      cache.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    var nPlanes = planes !== null ? planes.length : 0, dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (var i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
          plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    return dstArray;
  }
}
function WebGLExtensions(gl) {
  var extensions = {};
  return {
    get: function(name) {
      if (extensions[name] !== void 0) {
        return extensions[name];
      }
      var extension;
      switch (name) {
        case "WEBGL_depth_texture":
          extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          extension = gl.getExtension(name);
      }
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      extensions[name] = extension;
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info) {
  var geometries = {};
  var wireframeAttributes = {};
  function onGeometryDispose(event) {
    var geometry2 = event.target;
    var buffergeometry = geometries[geometry2.id];
    if (buffergeometry.index !== null) {
      attributes.remove(buffergeometry.index);
    }
    for (var name in buffergeometry.attributes) {
      attributes.remove(buffergeometry.attributes[name]);
    }
    geometry2.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry2.id];
    var attribute = wireframeAttributes[buffergeometry.id];
    if (attribute) {
      attributes.remove(attribute);
      delete wireframeAttributes[buffergeometry.id];
    }
    info.memory.geometries--;
  }
  function get(object, geometry2) {
    var buffergeometry = geometries[geometry2.id];
    if (buffergeometry)
      return buffergeometry;
    geometry2.addEventListener("dispose", onGeometryDispose);
    if (geometry2.isBufferGeometry) {
      buffergeometry = geometry2;
    } else if (geometry2.isGeometry) {
      if (geometry2._bufferGeometry === void 0) {
        geometry2._bufferGeometry = new BufferGeometry().setFromObject(object);
      }
      buffergeometry = geometry2._bufferGeometry;
    }
    geometries[geometry2.id] = buffergeometry;
    info.memory.geometries++;
    return buffergeometry;
  }
  function update3(geometry2) {
    var index2 = geometry2.index;
    var geometryAttributes = geometry2.attributes;
    if (index2 !== null) {
      attributes.update(index2, 34963);
    }
    for (var name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    }
    var morphAttributes = geometry2.morphAttributes;
    for (var name in morphAttributes) {
      var array = morphAttributes[name];
      for (var i2 = 0, l2 = array.length; i2 < l2; i2++) {
        attributes.update(array[i2], 34962);
      }
    }
  }
  function getWireframeAttribute(geometry2) {
    var attribute = wireframeAttributes[geometry2.id];
    if (attribute)
      return attribute;
    var indices = [];
    var geometryIndex = geometry2.index;
    var geometryAttributes = geometry2.attributes;
    if (geometryIndex !== null) {
      var array = geometryIndex.array;
      for (var i2 = 0, l2 = array.length; i2 < l2; i2 += 3) {
        var a2 = array[i2 + 0];
        var b2 = array[i2 + 1];
        var c2 = array[i2 + 2];
        indices.push(a2, b2, b2, c2, c2, a2);
      }
    } else {
      var array = geometryAttributes.position.array;
      for (var i2 = 0, l2 = array.length / 3 - 1; i2 < l2; i2 += 3) {
        var a2 = i2 + 0;
        var b2 = i2 + 1;
        var c2 = i2 + 2;
        indices.push(a2, b2, b2, c2, c2, a2);
      }
    }
    attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attributes.update(attribute, 34963);
    wireframeAttributes[geometry2.id] = attribute;
    return attribute;
  }
  return {
    get,
    update: update3,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  var mode;
  function setMode(value) {
    mode = value;
  }
  var type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render3(start, count2) {
    gl.drawElements(mode, count2, type, start * bytesPerElement);
    info.update(count2, mode);
  }
  function renderInstances(geometry2, start, count2) {
    var extension;
    if (capabilities.isWebGL2) {
      extension = gl;
    } else {
      var extension = extensions.get("ANGLE_instanced_arrays");
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[capabilities.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](mode, count2, type, start * bytesPerElement, geometry2.maxInstancedCount);
    info.update(count2, mode, geometry2.maxInstancedCount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render3;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  var memory = {
    geometries: 0,
    textures: 0
  };
  var render3 = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update3(count2, mode, instanceCount) {
    instanceCount = instanceCount || 1;
    render3.calls++;
    switch (mode) {
      case 4:
        render3.triangles += instanceCount * (count2 / 3);
        break;
      case 5:
      case 6:
        render3.triangles += instanceCount * (count2 - 2);
        break;
      case 1:
        render3.lines += instanceCount * (count2 / 2);
        break;
      case 3:
        render3.lines += instanceCount * (count2 - 1);
        break;
      case 2:
        render3.lines += instanceCount * count2;
        break;
      case 0:
        render3.points += instanceCount * count2;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset2() {
    render3.frame++;
    render3.calls = 0;
    render3.triangles = 0;
    render3.points = 0;
    render3.lines = 0;
  }
  return {
    memory,
    render: render3,
    programs: null,
    autoReset: true,
    reset: reset2,
    update: update3
  };
}
function absNumericalSort(a2, b2) {
  return Math.abs(b2[1]) - Math.abs(a2[1]);
}
function WebGLMorphtargets(gl) {
  var influencesList = {};
  var morphInfluences = new Float32Array(8);
  function update3(object, geometry2, material, program) {
    var objectInfluences = object.morphTargetInfluences;
    var length = objectInfluences.length;
    var influences = influencesList[geometry2.id];
    if (influences === void 0) {
      influences = [];
      for (var i2 = 0; i2 < length; i2++) {
        influences[i2] = [i2, 0];
      }
      influencesList[geometry2.id] = influences;
    }
    var morphTargets = material.morphTargets && geometry2.morphAttributes.position;
    var morphNormals = material.morphNormals && geometry2.morphAttributes.normal;
    for (var i2 = 0; i2 < length; i2++) {
      var influence = influences[i2];
      if (influence[1] !== 0) {
        if (morphTargets)
          geometry2.removeAttribute("morphTarget" + i2);
        if (morphNormals)
          geometry2.removeAttribute("morphNormal" + i2);
      }
    }
    for (var i2 = 0; i2 < length; i2++) {
      var influence = influences[i2];
      influence[0] = i2;
      influence[1] = objectInfluences[i2];
    }
    influences.sort(absNumericalSort);
    for (var i2 = 0; i2 < 8; i2++) {
      var influence = influences[i2];
      if (influence) {
        var index2 = influence[0];
        var value = influence[1];
        if (value) {
          if (morphTargets)
            geometry2.addAttribute("morphTarget" + i2, morphTargets[index2]);
          if (morphNormals)
            geometry2.addAttribute("morphNormal" + i2, morphNormals[index2]);
          morphInfluences[i2] = value;
          continue;
        }
      }
      morphInfluences[i2] = 0;
    }
    program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
  }
  return {
    update: update3
  };
}
function WebGLObjects(geometries, info) {
  var updateList = {};
  function update3(object) {
    var frame = info.render.frame;
    var geometry2 = object.geometry;
    var buffergeometry = geometries.get(object, geometry2);
    if (updateList[buffergeometry.id] !== frame) {
      if (geometry2.isGeometry) {
        buffergeometry.updateFromObject(object);
      }
      geometries.update(buffergeometry);
      updateList[buffergeometry.id] = frame;
    }
    return buffergeometry;
  }
  function dispose() {
    updateList = {};
  }
  return {
    update: update3,
    dispose
  };
}
function CubeTexture(images2, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
  images2 = images2 !== void 0 ? images2 : [];
  mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
  format = format !== void 0 ? format : RGBFormat;
  Texture.call(this, images2, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.flipY = false;
}
CubeTexture.prototype = Object.create(Texture.prototype);
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;
Object.defineProperty(CubeTexture.prototype, "images", {
  get: function() {
    return this.image;
  },
  set: function(value) {
    this.image = value;
  }
});
function DataTexture2DArray(data, width, height, depth) {
  Texture.call(this, null);
  this.image = { data, width, height, depth };
  this.magFilter = NearestFilter;
  this.minFilter = NearestFilter;
  this.wrapR = ClampToEdgeWrapping;
  this.generateMipmaps = false;
  this.flipY = false;
}
DataTexture2DArray.prototype = Object.create(Texture.prototype);
DataTexture2DArray.prototype.constructor = DataTexture2DArray;
DataTexture2DArray.prototype.isDataTexture2DArray = true;
function DataTexture3D(data, width, height, depth) {
  Texture.call(this, null);
  this.image = { data, width, height, depth };
  this.magFilter = NearestFilter;
  this.minFilter = NearestFilter;
  this.wrapR = ClampToEdgeWrapping;
  this.generateMipmaps = false;
  this.flipY = false;
}
DataTexture3D.prototype = Object.create(Texture.prototype);
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;
var emptyTexture = new Texture();
var emptyTexture2dArray = new DataTexture2DArray();
var emptyTexture3d = new DataTexture3D();
var emptyCubeTexture = new CubeTexture();
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  var firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  var n2 = nBlocks * blockSize, r2 = arrayCacheF32[n2];
  if (r2 === void 0) {
    r2 = new Float32Array(n2);
    arrayCacheF32[n2] = r2;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r2, 0);
    for (var i2 = 1, offset2 = 0; i2 !== nBlocks; ++i2) {
      offset2 += blockSize;
      array[i2].toArray(r2, offset2);
    }
  }
  return r2;
}
function arraysEqual(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  for (var i2 = 0, l2 = a2.length; i2 < l2; i2++) {
    if (a2[i2] !== b2[i2])
      return false;
  }
  return true;
}
function copyArray(a2, b2) {
  for (var i2 = 0, l2 = b2.length; i2 < l2; i2++) {
    a2[i2] = b2[i2];
  }
}
function allocTexUnits(textures, n2) {
  var r2 = arrayCacheI32[n2];
  if (r2 === void 0) {
    r2 = new Int32Array(n2);
    arrayCacheI32[n2] = r2;
  }
  for (var i2 = 0; i2 !== n2; ++i2)
    r2[i2] = textures.allocateTextureUnit();
  return r2;
}
function setValueV1f(gl, v2) {
  var cache = this.cache;
  if (cache[0] === v2)
    return;
  gl.uniform1f(this.addr, v2);
  cache[0] = v2;
}
function setValueV2f(gl, v2) {
  var cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y) {
      gl.uniform2f(this.addr, v2.x, v2.y);
      cache[0] = v2.x;
      cache[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache, v2))
      return;
    gl.uniform2fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV3f(gl, v2) {
  var cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
      gl.uniform3f(this.addr, v2.x, v2.y, v2.z);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
    }
  } else if (v2.r !== void 0) {
    if (cache[0] !== v2.r || cache[1] !== v2.g || cache[2] !== v2.b) {
      gl.uniform3f(this.addr, v2.r, v2.g, v2.b);
      cache[0] = v2.r;
      cache[1] = v2.g;
      cache[2] = v2.b;
    }
  } else {
    if (arraysEqual(cache, v2))
      return;
    gl.uniform3fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV4f(gl, v2) {
  var cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
      gl.uniform4f(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
      cache[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache, v2))
      return;
    gl.uniform4fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueM2(gl, v2) {
  var cache = this.cache;
  var elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2))
      return;
    gl.uniformMatrix2fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v2) {
  var cache = this.cache;
  var elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2))
      return;
    gl.uniformMatrix3fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v2) {
  var cache = this.cache;
  var elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2))
      return;
    gl.uniformMatrix4fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueT1(gl, v2, textures) {
  var cache = this.cache;
  var unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTexture2D(v2 || emptyTexture, unit);
}
function setValueT2DArray1(gl, v2, textures) {
  var cache = this.cache;
  var unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v2 || emptyTexture2dArray, unit);
}
function setValueT3D1(gl, v2, textures) {
  var cache = this.cache;
  var unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v2 || emptyTexture3d, unit);
}
function setValueT6(gl, v2, textures) {
  var cache = this.cache;
  var unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTextureCube(v2 || emptyCubeTexture, unit);
}
function setValueV1i(gl, v2) {
  var cache = this.cache;
  if (cache[0] === v2)
    return;
  gl.uniform1i(this.addr, v2);
  cache[0] = v2;
}
function setValueV2i(gl, v2) {
  var cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl.uniform2iv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV3i(gl, v2) {
  var cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl.uniform3iv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV4i(gl, v2) {
  var cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl.uniform4iv(this.addr, v2);
  copyArray(cache, v2);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 35678:
    case 36198:
      return setValueT1;
    case 35679:
      return setValueT3D1;
    case 35680:
      return setValueT6;
    case 36289:
      return setValueT2DArray1;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
  }
}
function setValueV1fArray(gl, v2) {
  gl.uniform1fv(this.addr, v2);
}
function setValueV1iArray(gl, v2) {
  gl.uniform1iv(this.addr, v2);
}
function setValueV2iArray(gl, v2) {
  gl.uniform2iv(this.addr, v2);
}
function setValueV3iArray(gl, v2) {
  gl.uniform3iv(this.addr, v2);
}
function setValueV4iArray(gl, v2) {
  gl.uniform4iv(this.addr, v2);
}
function setValueV2fArray(gl, v2) {
  var data = flatten(v2, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v2) {
  var data = flatten(v2, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v2) {
  var data = flatten(v2, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v2) {
  var data = flatten(v2, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v2) {
  var data = flatten(v2, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v2) {
  var data = flatten(v2, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueT1Array(gl, v2, textures) {
  var n2 = v2.length;
  var units = allocTexUnits(textures, n2);
  gl.uniform1iv(this.addr, units);
  for (var i2 = 0; i2 !== n2; ++i2) {
    textures.safeSetTexture2D(v2[i2] || emptyTexture, units[i2]);
  }
}
function setValueT6Array(gl, v2, textures) {
  var n2 = v2.length;
  var units = allocTexUnits(textures, n2);
  gl.uniform1iv(this.addr, units);
  for (var i2 = 0; i2 !== n2; ++i2) {
    textures.safeSetTextureCube(v2[i2] || emptyCubeTexture, units[i2]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 35678:
      return setValueT1Array;
    case 35680:
      return setValueT6Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
  }
}
function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
PureArrayUniform.prototype.updateCache = function(data) {
  var cache = this.cache;
  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }
  copyArray(cache, data);
};
function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}
StructuredUniform.prototype.setValue = function(gl, value, textures) {
  var seq = this.seq;
  for (var i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    var u2 = seq[i2];
    u2.setValue(gl, value[u2.id], textures);
  }
};
var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  var path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id = match[1], idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex)
      id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      var map = container.map, next3 = map[id];
      if (next3 === void 0) {
        next3 = new StructuredUniform(id);
        addUniform(container, next3);
      }
      container = next3;
    }
  }
}
function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  var n2 = gl.getProgramParameter(program, 35718);
  for (var i2 = 0; i2 < n2; ++i2) {
    var info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
  var u2 = this.map[name];
  if (u2 !== void 0)
    u2.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl, object, name) {
  var v2 = object[name];
  if (v2 !== void 0)
    this.setValue(gl, name, v2);
};
WebGLUniforms.upload = function(gl, seq, values, textures) {
  for (var i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    var u2 = seq[i2], v2 = values[u2.id];
    if (v2.needsUpdate !== false) {
      u2.setValue(gl, v2.value, textures);
    }
  }
};
WebGLUniforms.seqWithValue = function(seq, values) {
  var r2 = [];
  for (var i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    var u2 = seq[i2];
    if (u2.id in values)
      r2.push(u2);
  }
  return r2;
};
function addLineNumbers(string) {
  var lines = string.split("\n");
  for (var i2 = 0; i2 < lines.length; i2++) {
    lines[i2] = i2 + 1 + ": " + lines[i2];
  }
  return lines.join("\n");
}
function WebGLShader(gl, type, string, debug) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  if (debug === true) {
    if (gl.getShaderParameter(shader, 35713) === false) {
      console.error("THREE.WebGLShader: Shader couldn't compile.");
    }
    if (gl.getShaderInfoLog(shader) !== "") {
      console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", type === 35633 ? "vertex" : "fragment", gl.getShaderInfoLog(shader), addLineNumbers(string));
    }
  }
  return shader;
}
var programIdCount = 0;
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    default:
      throw new Error("unsupported encoding: " + encoding);
  }
}
function getTexelDecodingFunction(functionName, encoding) {
  var components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
}
function getTexelEncodingFunction(functionName, encoding) {
  var components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  var toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case Uncharted2ToneMapping:
      toneMappingName = "Uncharted2";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    default:
      throw new Error("unsupported toneMapping: " + toneMapping);
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(extensions, parameters, rendererExtensions) {
  extensions = extensions || {};
  var chunks = [
    extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap && !parameters.objectSpaceNormalMap || parameters.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "",
    (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "",
    extensions.drawBuffers && rendererExtensions.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "",
    (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  var chunks = [];
  for (var name in defines) {
    var value = defines[name];
    if (value === false)
      continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  var attributes = {};
  var n2 = gl.getProgramParameter(program, 35721);
  for (var i2 = 0; i2 < n2; i2++) {
    var info = gl.getActiveAttrib(program, i2);
    var name = info.name;
    attributes[name] = gl.getAttribLocation(program, name);
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
function parseIncludes(string) {
  var pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function replace(match, include) {
    var replace2 = ShaderChunk[include];
    if (replace2 === void 0) {
      throw new Error("Can not resolve #include <" + include + ">");
    }
    return parseIncludes(replace2);
  }
  return string.replace(pattern, replace);
}
function unrollLoops(string) {
  var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
  function replace(match, start, end, snippet) {
    var unroll = "";
    for (var i2 = parseInt(start); i2 < parseInt(end); i2++) {
      unroll += snippet.replace(/\[ i \]/g, "[ " + i2 + " ]");
    }
    return unroll;
  }
  return string.replace(pattern, replace);
}
function WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities, textures) {
  var gl = renderer.context;
  var defines = material.defines;
  var vertexShader = shader.vertexShader;
  var fragmentShader = shader.fragmentShader;
  var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  }
  var envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  var envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  var envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
  if (parameters.envMap) {
    switch (material.envMap.mapping) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
      case EquirectangularReflectionMapping:
      case EquirectangularRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_EQUIREC";
        break;
      case SphericalReflectionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_SPHERE";
        break;
    }
    switch (material.envMap.mapping) {
      case CubeRefractionMapping:
      case EquirectangularRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
    switch (material.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
  var customExtensions = capabilities.isWebGL2 ? "" : generateExtensions(material.extensions, parameters, extensions);
  var customDefines = generateDefines(defines);
  var program = gl.createProgram();
  var prefixVertex, prefixFragment;
  if (material.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      "precision " + parameters.precision + " float;",
      "precision " + parameters.precision + " int;",
      "#define SHADER_NAME " + shader.name,
      customDefines,
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#ifdef USE_COLOR",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_MORPHTARGETS",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      "precision " + parameters.precision + " float;",
      "precision " + parameters.precision + " int;",
      "#define SHADER_NAME " + shader.name,
      customDefines,
      parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
      parameters.envMap && (capabilities.isWebGL2 || extensions.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? ShaderChunk["encodings_pars_fragment"] : "",
      parameters.mapEncoding ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
      parameters.matcapEncoding ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
      parameters.envMapEncoding ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
      parameters.emissiveMapEncoding ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
      parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : "",
      parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = parseIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = parseIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (capabilities.isWebGL2 && !material.isRawShaderMaterial) {
    var isGLSL3ShaderMaterial = false;
    var versionRegex = /^\s*#version\s+300\s+es\s*\n/;
    if (material.isShaderMaterial && vertexShader.match(versionRegex) !== null && fragmentShader.match(versionRegex) !== null) {
      isGLSL3ShaderMaterial = true;
      vertexShader = vertexShader.replace(versionRegex, "");
      fragmentShader = fragmentShader.replace(versionRegex, "");
    }
    prefixVertex = [
      "#version 300 es\n",
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#version 300 es\n",
      "#define varying in",
      isGLSL3ShaderMaterial ? "" : "out highp vec4 pc_fragColor;",
      isGLSL3ShaderMaterial ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  var vertexGlsl = prefixVertex + vertexShader;
  var fragmentGlsl = prefixFragment + fragmentShader;
  var glVertexShader = WebGLShader(gl, 35633, vertexGlsl, renderer.debug.checkShaderErrors);
  var glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl, renderer.debug.checkShaderErrors);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (material.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, material.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  if (renderer.debug.checkShaderErrors) {
    var programLog = gl.getProgramInfoLog(program).trim();
    var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    var runnable = true;
    var haveDiagnostics = true;
    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "35715", gl.getProgramParameter(program, 35715), "gl.getProgramInfoLog", programLog, vertexLog, fragmentLog);
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        material,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  var cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program, textures);
    }
    return cachedUniforms;
  };
  var cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    gl.deleteProgram(program);
    this.program = void 0;
  };
  Object.defineProperties(this, {
    uniforms: {
      get: function() {
        console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");
        return this.getUniforms();
      }
    },
    attributes: {
      get: function() {
        console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");
        return this.getAttributes();
      }
    }
  });
  this.name = shader.name;
  this.id = programIdCount++;
  this.code = code;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
function WebGLPrograms(renderer, extensions, capabilities, textures) {
  var programs = [];
  var shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "phong",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  var parameterNames = [
    "precision",
    "supportsVertexTextures",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "lightMap",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "vertexTangents",
    "fog",
    "useFog",
    "fogExp",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "maxMorphTargets",
    "maxMorphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering"
  ];
  function allocateBones(object) {
    var skeleton = object.skeleton;
    var bones = skeleton.bones;
    if (capabilities.floatVertexTextures) {
      return 1024;
    } else {
      var nVertexUniforms = capabilities.maxVertexUniforms;
      var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      var maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  function getTextureEncodingFromMap(map, gammaOverrideLinear) {
    var encoding;
    if (!map) {
      encoding = LinearEncoding;
    } else if (map.isTexture) {
      encoding = map.encoding;
    } else if (map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    }
    if (encoding === LinearEncoding && gammaOverrideLinear) {
      encoding = GammaEncoding;
    }
    return encoding;
  }
  this.getParameters = function(material, lights, shadows, fog, nClipPlanes, nClipIntersection, object) {
    var shaderID = shaderIDs[material.type];
    var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
    var precision = capabilities.precision;
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    var currentRenderTarget = renderer.getRenderTarget();
    var parameters = {
      shaderID,
      precision,
      supportsVertexTextures: capabilities.vertexTextures,
      outputEncoding: getTextureEncodingFromMap(!currentRenderTarget ? null : currentRenderTarget.texture, renderer.gammaOutput),
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap, renderer.gammaInput),
      envMap: !!material.envMap,
      envMapMode: material.envMap && material.envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
      envMapCubeUV: !!material.envMap && (material.envMap.mapping === CubeUVReflectionMapping || material.envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      combine: material.combine,
      vertexTangents: material.normalMap && material.vertexTangents,
      vertexColors: material.vertexColors,
      fog: !!fog,
      useFog: material.fog,
      fogExp: fog && fog.isFogExp2,
      flatShading: material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
      skinning: material.skinning && maxBones > 0,
      maxBones,
      useVertexTexture: capabilities.floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: renderer.maxMorphTargets,
      maxMorphNormals: renderer.maxMorphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numClippingPlanes: nClipPlanes,
      numClipIntersection: nClipIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: renderer.toneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false
    };
    return parameters;
  };
  this.getProgramCode = function(material, parameters) {
    var array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(material.fragmentShader);
      array.push(material.vertexShader);
    }
    if (material.defines !== void 0) {
      for (var name in material.defines) {
        array.push(name);
        array.push(material.defines[name]);
      }
    }
    for (var i2 = 0; i2 < parameterNames.length; i2++) {
      array.push(parameters[parameterNames[i2]]);
    }
    array.push(material.onBeforeCompile.toString());
    array.push(renderer.gammaOutput);
    array.push(renderer.gammaFactor);
    return array.join();
  };
  this.acquireProgram = function(material, shader, parameters, code) {
    var program;
    for (var p2 = 0, pl = programs.length; p2 < pl; p2++) {
      var programInfo = programs[p2];
      if (programInfo.code === code) {
        program = programInfo;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities, textures);
      programs.push(program);
    }
    return program;
  };
  this.releaseProgram = function(program) {
    if (--program.usedTimes === 0) {
      var i2 = programs.indexOf(program);
      programs[i2] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  };
  this.programs = programs;
}
function WebGLProperties() {
  var properties = new WeakMap();
  function get(object) {
    var map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove2(object) {
    properties.delete(object);
  }
  function update3(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = new WeakMap();
  }
  return {
    get,
    remove: remove2,
    update: update3,
    dispose
  };
}
function painterSortStable(a2, b2) {
  if (a2.groupOrder !== b2.groupOrder) {
    return a2.groupOrder - b2.groupOrder;
  } else if (a2.renderOrder !== b2.renderOrder) {
    return a2.renderOrder - b2.renderOrder;
  } else if (a2.program !== b2.program) {
    return a2.program.id - b2.program.id;
  } else if (a2.material.id !== b2.material.id) {
    return a2.material.id - b2.material.id;
  } else if (a2.z !== b2.z) {
    return a2.z - b2.z;
  } else {
    return a2.id - b2.id;
  }
}
function reversePainterSortStable(a2, b2) {
  if (a2.groupOrder !== b2.groupOrder) {
    return a2.groupOrder - b2.groupOrder;
  } else if (a2.renderOrder !== b2.renderOrder) {
    return a2.renderOrder - b2.renderOrder;
  } else if (a2.z !== b2.z) {
    return b2.z - a2.z;
  } else {
    return a2.id - b2.id;
  }
}
function WebGLRenderList() {
  var renderItems = [];
  var renderItemsIndex = 0;
  var opaque = [];
  var transparent = [];
  var defaultProgram = { id: -1 };
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry2, material, groupOrder, z2, group) {
    var renderItem = renderItems[renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry: geometry2,
        material,
        program: material.program || defaultProgram,
        groupOrder,
        renderOrder: object.renderOrder,
        z: z2,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry2;
      renderItem.material = material;
      renderItem.program = material.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z2;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry2, material, groupOrder, z2, group) {
    var renderItem = getNextRenderItem(object, geometry2, material, groupOrder, z2, group);
    (material.transparent === true ? transparent : opaque).push(renderItem);
  }
  function unshift(object, geometry2, material, groupOrder, z2, group) {
    var renderItem = getNextRenderItem(object, geometry2, material, groupOrder, z2, group);
    (material.transparent === true ? transparent : opaque).unshift(renderItem);
  }
  function sort() {
    if (opaque.length > 1)
      opaque.sort(painterSortStable);
    if (transparent.length > 1)
      transparent.sort(reversePainterSortStable);
  }
  return {
    opaque,
    transparent,
    init,
    push,
    unshift,
    sort
  };
}
function WebGLRenderLists() {
  var lists = {};
  function onSceneDispose(event) {
    var scene = event.target;
    scene.removeEventListener("dispose", onSceneDispose);
    delete lists[scene.id];
  }
  function get(scene, camera) {
    var cameras = lists[scene.id];
    var list;
    if (cameras === void 0) {
      list = new WebGLRenderList();
      lists[scene.id] = {};
      lists[scene.id][camera.id] = list;
      scene.addEventListener("dispose", onSceneDispose);
    } else {
      list = cameras[camera.id];
      if (list === void 0) {
        list = new WebGLRenderList();
        cameras[camera.id] = list;
      }
    }
    return list;
  }
  function dispose() {
    lists = {};
  }
  return {
    get,
    dispose
  };
}
function UniformsCache() {
  var lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      var uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color(),
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0,
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
var count = 0;
function WebGLLights() {
  var cache = new UniformsCache();
  var state = {
    id: count++,
    hash: {
      stateID: -1,
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      shadowsLength: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    point: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (var i2 = 0; i2 < 9; i2++)
    state.probe.push(new Vector3());
  var vector3 = new Vector3();
  var matrix4 = new Matrix4();
  var matrix42 = new Matrix4();
  function setup(lights, shadows, camera) {
    var r2 = 0, g2 = 0, b2 = 0;
    for (var i3 = 0; i3 < 9; i3++)
      state.probe[i3].set(0, 0, 0);
    var directionalLength = 0;
    var pointLength = 0;
    var spotLength = 0;
    var rectAreaLength = 0;
    var hemiLength = 0;
    var viewMatrix = camera.matrixWorldInverse;
    for (var i3 = 0, l2 = lights.length; i3 < l2; i3++) {
      var light = lights[i3];
      var color = light.color;
      var intensity = light.intensity;
      var distance = light.distance;
      var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r2 += color.r * intensity;
        g2 += color.g * intensity;
        b2 += color.b * intensity;
      } else if (light.isLightProbe) {
        for (var j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
      } else if (light.isDirectionalLight) {
        var uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.shadow = light.castShadow;
        if (light.castShadow) {
          var shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
        }
        state.directionalShadowMap[directionalLength] = shadowMap;
        state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        var uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        uniforms.shadow = light.castShadow;
        if (light.castShadow) {
          var shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
        }
        state.spotShadowMap[spotLength] = shadowMap;
        state.spotShadowMatrix[spotLength] = light.shadow.matrix;
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        var uniforms = cache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        var uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        uniforms.shadow = light.castShadow;
        if (light.castShadow) {
          var shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
          uniforms.shadowCameraNear = shadow.camera.near;
          uniforms.shadowCameraFar = shadow.camera.far;
        }
        state.pointShadowMap[pointLength] = shadowMap;
        state.pointShadowMatrix[pointLength] = light.shadow.matrix;
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        var uniforms = cache.get(light);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    state.ambient[0] = r2;
    state.ambient[1] = g2;
    state.ambient[2] = b2;
    state.directional.length = directionalLength;
    state.spot.length = spotLength;
    state.rectArea.length = rectAreaLength;
    state.point.length = pointLength;
    state.hemi.length = hemiLength;
    state.hash.stateID = state.id;
    state.hash.directionalLength = directionalLength;
    state.hash.pointLength = pointLength;
    state.hash.spotLength = spotLength;
    state.hash.rectAreaLength = rectAreaLength;
    state.hash.hemiLength = hemiLength;
    state.hash.shadowsLength = shadows.length;
  }
  return {
    setup,
    state
  };
}
function WebGLRenderState() {
  var lights = new WebGLLights();
  var lightsArray = [];
  var shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights(camera) {
    lights.setup(lightsArray, shadowsArray, camera);
  }
  var state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init,
    state,
    setupLights,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates() {
  var renderStates = {};
  function onSceneDispose(event) {
    var scene = event.target;
    scene.removeEventListener("dispose", onSceneDispose);
    delete renderStates[scene.id];
  }
  function get(scene, camera) {
    var renderState;
    if (renderStates[scene.id] === void 0) {
      renderState = new WebGLRenderState();
      renderStates[scene.id] = {};
      renderStates[scene.id][camera.id] = renderState;
      scene.addEventListener("dispose", onSceneDispose);
    } else {
      if (renderStates[scene.id][camera.id] === void 0) {
        renderState = new WebGLRenderState();
        renderStates[scene.id][camera.id] = renderState;
      } else {
        renderState = renderStates[scene.id][camera.id];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = {};
  }
  return {
    get,
    dispose
  };
}
function MeshDepthMaterial(parameters) {
  Material.call(this);
  this.type = "MeshDepthMaterial";
  this.depthPacking = BasicDepthPacking;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.setValues(parameters);
}
MeshDepthMaterial.prototype = Object.create(Material.prototype);
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
MeshDepthMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.depthPacking = source.depthPacking;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  return this;
};
function MeshDistanceMaterial(parameters) {
  Material.call(this);
  this.type = "MeshDistanceMaterial";
  this.referencePosition = new Vector3();
  this.nearDistance = 1;
  this.farDistance = 1e3;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.fog = false;
  this.lights = false;
  this.setValues(parameters);
}
MeshDistanceMaterial.prototype = Object.create(Material.prototype);
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
MeshDistanceMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.referencePosition.copy(source.referencePosition);
  this.nearDistance = source.nearDistance;
  this.farDistance = source.farDistance;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  return this;
};
function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
  var _frustum = new Frustum(), _projScreenMatrix = new Matrix4(), _shadowMapSize = new Vector2(), _maxShadowMapSize = new Vector2(maxTextureSize, maxTextureSize), _lookTarget = new Vector3(), _lightPositionWorld = new Vector3(), _MorphingFlag = 1, _SkinningFlag = 2, _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1, _depthMaterials = new Array(_NumberOfMaterialVariants), _distanceMaterials = new Array(_NumberOfMaterialVariants), _materialCache = {};
  var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
  var cubeDirections = [
    new Vector3(1, 0, 0),
    new Vector3(-1, 0, 0),
    new Vector3(0, 0, 1),
    new Vector3(0, 0, -1),
    new Vector3(0, 1, 0),
    new Vector3(0, -1, 0)
  ];
  var cubeUps = [
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 0, 1),
    new Vector3(0, 0, -1)
  ];
  var cube2DViewPorts = [
    new Vector4(),
    new Vector4(),
    new Vector4(),
    new Vector4(),
    new Vector4(),
    new Vector4()
  ];
  for (var i2 = 0; i2 !== _NumberOfMaterialVariants; ++i2) {
    var useMorphing = (i2 & _MorphingFlag) !== 0;
    var useSkinning = (i2 & _SkinningFlag) !== 0;
    var depthMaterial = new MeshDepthMaterial({
      depthPacking: RGBADepthPacking,
      morphTargets: useMorphing,
      skinning: useSkinning
    });
    _depthMaterials[i2] = depthMaterial;
    var distanceMaterial = new MeshDistanceMaterial({
      morphTargets: useMorphing,
      skinning: useSkinning
    });
    _distanceMaterials[i2] = distanceMaterial;
  }
  var scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    var currentRenderTarget = _renderer.getRenderTarget();
    var activeCubeFace = _renderer.getActiveCubeFace();
    var activeMipMapLevel = _renderer.getActiveMipMapLevel();
    var _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    var faceCount;
    for (var i3 = 0, il = lights.length; i3 < il; i3++) {
      var light = lights[i3];
      var shadow = light.shadow;
      var isPointLight = light && light.isPointLight;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      var shadowCamera = shadow.camera;
      _shadowMapSize.copy(shadow.mapSize);
      _shadowMapSize.min(_maxShadowMapSize);
      if (isPointLight) {
        var vpWidth = _shadowMapSize.x;
        var vpHeight = _shadowMapSize.y;
        cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
        cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
        cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
        cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
        cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
        cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
        _shadowMapSize.x *= 4;
        _shadowMapSize.y *= 2;
      }
      if (shadow.map === null) {
        var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadowCamera.updateProjectionMatrix();
      }
      if (shadow.isSpotLightShadow) {
        shadow.update(light);
      }
      var shadowMap = shadow.map;
      var shadowMatrix = shadow.matrix;
      _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
      shadowCamera.position.copy(_lightPositionWorld);
      if (isPointLight) {
        faceCount = 6;
        shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
      } else {
        faceCount = 1;
        _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt(_lookTarget);
        shadowCamera.updateMatrixWorld();
        shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
      }
      _renderer.setRenderTarget(shadowMap);
      _renderer.clear();
      for (var face = 0; face < faceCount; face++) {
        if (isPointLight) {
          _lookTarget.copy(shadowCamera.position);
          _lookTarget.add(cubeDirections[face]);
          shadowCamera.up.copy(cubeUps[face]);
          shadowCamera.lookAt(_lookTarget);
          shadowCamera.updateMatrixWorld();
          var vpDimensions = cube2DViewPorts[face];
          _state.viewport(vpDimensions);
        }
        _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        _frustum.setFromMatrix(_projScreenMatrix);
        renderObject(scene, camera, shadowCamera, isPointLight);
      }
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipMapLevel);
  };
  function getDepthMaterial(object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar) {
    var geometry2 = object.geometry;
    var result = null;
    var materialVariants = _depthMaterials;
    var customMaterial = object.customDepthMaterial;
    if (isPointLight) {
      materialVariants = _distanceMaterials;
      customMaterial = object.customDistanceMaterial;
    }
    if (!customMaterial) {
      var useMorphing2 = false;
      if (material.morphTargets) {
        if (geometry2 && geometry2.isBufferGeometry) {
          useMorphing2 = geometry2.morphAttributes && geometry2.morphAttributes.position && geometry2.morphAttributes.position.length > 0;
        } else if (geometry2 && geometry2.isGeometry) {
          useMorphing2 = geometry2.morphTargets && geometry2.morphTargets.length > 0;
        }
      }
      if (object.isSkinnedMesh && material.skinning === false) {
        console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
      }
      var useSkinning2 = object.isSkinnedMesh && material.skinning;
      var variantIndex = 0;
      if (useMorphing2)
        variantIndex |= _MorphingFlag;
      if (useSkinning2)
        variantIndex |= _SkinningFlag;
      result = materialVariants[variantIndex];
    } else {
      result = customMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      var keyA = result.uuid, keyB = material.uuid;
      var materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      var cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    result.side = material.shadowSide != null ? material.shadowSide : shadowSide[material.side];
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (isPointLight && result.isMeshDistanceMaterial) {
      result.referencePosition.copy(lightPositionWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, isPointLight) {
    if (object.visible === false)
      return;
    var visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if (object.castShadow && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        var geometry2 = _objects.update(object);
        var material = object.material;
        if (Array.isArray(material)) {
          var groups = geometry2.groups;
          for (var k2 = 0, kl = groups.length; k2 < kl; k2++) {
            var group = groups[k2];
            var groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              var depthMaterial2 = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
              _renderer.renderBufferDirect(shadowCamera, null, geometry2, depthMaterial2, object, group);
            }
          }
        } else if (material.visible) {
          var depthMaterial2 = getDepthMaterial(object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
          _renderer.renderBufferDirect(shadowCamera, null, geometry2, depthMaterial2, object, null);
        }
      }
    }
    var children2 = object.children;
    for (var i3 = 0, l2 = children2.length; i3 < l2; i3++) {
      renderObject(children2[i3], camera, shadowCamera, isPointLight);
    }
  }
}
function WebGLState(gl, extensions, utils, capabilities) {
  function ColorBuffer() {
    var locked = false;
    var color = new Vector4();
    var currentColorMask = null;
    var currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r2, g2, b2, a2, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r2 *= a2;
          g2 *= a2;
          b2 *= a2;
        }
        color.set(r2, g2, b2, a2);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r2, g2, b2, a2);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    var locked = false;
    var currentDepthMask = null;
    var currentDepthFunc = null;
    var currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;
              case AlwaysDepth:
                gl.depthFunc(519);
                break;
              case LessDepth:
                gl.depthFunc(513);
                break;
              case LessEqualDepth:
                gl.depthFunc(515);
                break;
              case EqualDepth:
                gl.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;
              case GreaterDepth:
                gl.depthFunc(516);
                break;
              case NotEqualDepth:
                gl.depthFunc(517);
                break;
              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    var locked = false;
    var currentStencilMask = null;
    var currentStencilFunc = null;
    var currentStencilRef = null;
    var currentStencilFuncMask = null;
    var currentStencilFail = null;
    var currentStencilZFail = null;
    var currentStencilZPass = null;
    var currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (stencilTest) {
          enable(2960);
        } else {
          disable(2960);
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  var colorBuffer = new ColorBuffer();
  var depthBuffer = new DepthBuffer();
  var stencilBuffer = new StencilBuffer();
  var maxVertexAttributes = gl.getParameter(34921);
  var newAttributes = new Uint8Array(maxVertexAttributes);
  var enabledAttributes = new Uint8Array(maxVertexAttributes);
  var attributeDivisors = new Uint8Array(maxVertexAttributes);
  var enabledCapabilities = {};
  var compressedTextureFormats = null;
  var currentProgram = null;
  var currentBlendingEnabled = null;
  var currentBlending = null;
  var currentBlendEquation = null;
  var currentBlendSrc = null;
  var currentBlendDst = null;
  var currentBlendEquationAlpha = null;
  var currentBlendSrcAlpha = null;
  var currentBlendDstAlpha = null;
  var currentPremultipledAlpha = false;
  var currentFlipSided = null;
  var currentCullFace = null;
  var currentLineWidth = null;
  var currentPolygonOffsetFactor = null;
  var currentPolygonOffsetUnits = null;
  var maxTextures = gl.getParameter(35661);
  var lineWidthAvailable = false;
  var version2 = 0;
  var glVersion = gl.getParameter(7938);
  if (glVersion.indexOf("WebGL") !== -1) {
    version2 = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
    lineWidthAvailable = version2 >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version2 = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
    lineWidthAvailable = version2 >= 2;
  }
  var currentTextureSlot = null;
  var currentBoundTextures = {};
  var currentScissor = new Vector4();
  var currentViewport = new Vector4();
  function createTexture(type, target, count2) {
    var data = new Uint8Array(4);
    var texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);
    for (var i2 = 0; i2 < count2; i2++) {
      gl.texImage2D(target + i2, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }
    return texture;
  }
  var emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending);
  function initAttributes() {
    for (var i2 = 0, l2 = newAttributes.length; i2 < l2; i2++) {
      newAttributes[i2] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      var extension = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
      extension[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    for (var i2 = 0, l2 = enabledAttributes.length; i2 !== l2; ++i2) {
      if (enabledAttributes[i2] !== newAttributes[i2]) {
        gl.disableVertexAttribArray(i2);
        enabledAttributes[i2] = 0;
      }
    }
  }
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function getCompressedTextureFormats() {
    if (compressedTextureFormats === null) {
      compressedTextureFormats = [];
      if (extensions.get("WEBGL_compressed_texture_pvrtc") || extensions.get("WEBGL_compressed_texture_s3tc") || extensions.get("WEBGL_compressed_texture_etc1") || extensions.get("WEBGL_compressed_texture_astc")) {
        var formats = gl.getParameter(34467);
        for (var i2 = 0; i2 < formats.length; i2++) {
          compressedTextureFormats.push(formats[i2]);
        }
      }
    }
    return compressedTextureFormats;
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled) {
        disable(3042);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (!currentBlendingEnabled) {
      enable(3042);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 0, 769, 771);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              gl.blendFunc(0, 769);
              break;
            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(utils.convert(blendEquation), utils.convert(blendEquationAlpha));
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(utils.convert(blendSrc), utils.convert(blendDst), utils.convert(blendSrcAlpha), utils.convert(blendDstAlpha));
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    var flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = 33984 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    var boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function reset2() {
    for (var i2 = 0; i2 < enabledAttributes.length; i2++) {
      if (enabledAttributes[i2] === 1) {
        gl.disableVertexAttribArray(i2);
        enabledAttributes[i2] = 0;
      }
    }
    enabledCapabilities = {};
    compressedTextureFormats = null;
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentProgram = null;
    currentBlending = null;
    currentFlipSided = null;
    currentCullFace = null;
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    initAttributes,
    enableAttribute,
    enableAttributeAndDivisor,
    disableUnusedAttributes,
    enable,
    disable,
    getCompressedTextureFormats,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    scissor,
    viewport,
    reset: reset2
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  var _videoTextures = {};
  var _canvas2;
  var useOffscreenCanvas = typeof OffscreenCanvas !== "undefined";
  function createCanvas(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    var scale2 = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale2 = maxSize / Math.max(image.width, image.height);
    }
    if (scale2 < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        var floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor;
        var width = floor(scale2 * image.width);
        var height = floor(scale2 * image.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas(width, height);
        var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        var context2 = canvas.getContext("2d");
        context2.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo(image) {
    return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (capabilities.isWebGL2)
      return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target, texture, width, height) {
    _gl.generateMipmap(target);
    var textureProperties = properties.get(texture);
    textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
  }
  function getInternalFormat(glFormat, glType) {
    if (!capabilities.isWebGL2)
      return glFormat;
    var internalFormat = glFormat;
    if (glFormat === 6403) {
      if (glType === 5126)
        internalFormat = 33326;
      if (glType === 5131)
        internalFormat = 33325;
      if (glType === 5121)
        internalFormat = 33321;
    }
    if (glFormat === 6407) {
      if (glType === 5126)
        internalFormat = 34837;
      if (glType === 5131)
        internalFormat = 34843;
      if (glType === 5121)
        internalFormat = 32849;
    }
    if (glFormat === 6408) {
      if (glType === 5126)
        internalFormat = 34836;
      if (glType === 5131)
        internalFormat = 34842;
      if (glType === 5121)
        internalFormat = 32856;
    }
    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get("EXT_color_buffer_float");
    } else if (internalFormat === 34843 || internalFormat === 34837) {
      console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.");
    }
    return internalFormat;
  }
  function filterFallback(f2) {
    if (f2 === NearestFilter || f2 === NearestMipMapNearestFilter || f2 === NearestMipMapLinearFilter) {
      return 9728;
    }
    return 9729;
  }
  function onTextureDispose(event) {
    var texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      delete _videoTextures[texture.id];
    }
    info.memory.textures--;
  }
  function onRenderTargetDispose(event) {
    var renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    info.memory.textures--;
  }
  function deallocateTexture(texture) {
    var textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0)
      return;
    _gl.deleteTexture(textureProperties.__webglTexture);
    properties.remove(texture);
  }
  function deallocateRenderTarget(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(renderTarget.texture);
    if (!renderTarget)
      return;
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLRenderTargetCube) {
      for (var i2 = 0; i2 < 6; i2++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
    }
    properties.remove(renderTarget.texture);
    properties.remove(renderTarget);
  }
  var textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    var textureUnit = textureUnits;
    if (textureUnit >= capabilities.maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function setTexture2D(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.isVideoTexture)
      updateVideoTexture(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      var image = texture.image;
      if (image === void 0) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }
  function setTexture2DArray(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }
  function setTexture3D(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.image.length === 6) {
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        initTexture(textureProperties, texture);
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);
        _gl.pixelStorei(37440, texture.flipY);
        var isCompressed = texture && texture.isCompressedTexture;
        var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
        var cubeImage = [];
        for (var i2 = 0; i2 < 6; i2++) {
          if (!isCompressed && !isDataTexture) {
            cubeImage[i2] = resizeImage(texture.image[i2], false, true, capabilities.maxCubemapSize);
          } else {
            cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
          }
        }
        var image = cubeImage[0], supportsMips = isPowerOfTwo(image) || capabilities.isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(glFormat, glType);
        setTextureParameters(34067, texture, supportsMips);
        for (var i2 = 0; i2 < 6; i2++) {
          if (!isCompressed) {
            if (isDataTexture) {
              state.texImage2D(34069 + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
            } else {
              state.texImage2D(34069 + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
            }
          } else {
            var mipmap, mipmaps = cubeImage[i2].mipmaps;
            for (var j = 0, jl = mipmaps.length; j < jl; j++) {
              mipmap = mipmaps[j];
              if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                  state.compressedTexImage2D(34069 + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                }
              } else {
                state.texImage2D(34069 + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
        if (!isCompressed) {
          textureProperties.__maxMipLevel = 0;
        } else {
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(34067, texture, image.width, image.height);
        }
        textureProperties.__version = texture.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      } else {
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);
      }
    }
  }
  function setTextureCubeDynamic(texture, slot) {
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, properties.get(texture).__webglTexture);
  }
  function setTextureParameters(textureType, texture, supportsMips) {
    var extension;
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, utils.convert(texture.wrapS));
      _gl.texParameteri(textureType, 10243, utils.convert(texture.wrapT));
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, utils.convert(texture.wrapR));
      }
      _gl.texParameteri(textureType, 10240, utils.convert(texture.magFilter));
      _gl.texParameteri(textureType, 10241, utils.convert(texture.minFilter));
    } else {
      _gl.texParameteri(textureType, 10242, 33071);
      _gl.texParameteri(textureType, 10243, 33071);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    extension = extensions.get("EXT_texture_filter_anisotropic");
    if (extension) {
      if (texture.type === FloatType && extensions.get("OES_texture_float_linear") === null)
        return;
      if (texture.type === HalfFloatType && (capabilities.isWebGL2 || extensions.get("OES_texture_half_float_linear")) === null)
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }
  function uploadTexture(textureProperties, texture, slot) {
    var textureType = 3553;
    if (texture.isDataTexture2DArray)
      textureType = 35866;
    if (texture.isDataTexture3D)
      textureType = 32879;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
    var image = resizeImage(texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize);
    var supportsMips = isPowerOfTwo(image) || capabilities.isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(glFormat, glType);
    setTextureParameters(textureType, texture, supportsMips);
    var mipmap, mipmaps = texture.mipmaps;
    if (texture.isDepthTexture) {
      glInternalFormat = 6402;
      if (texture.type === FloatType) {
        if (!capabilities.isWebGL2)
          throw new Error("Float Depth Texture only supported in WebGL2.0");
        glInternalFormat = 36012;
      } else if (capabilities.isWebGL2) {
        glInternalFormat = 33189;
      }
      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
          texture.type = UnsignedShortType;
          glType = utils.convert(texture.type);
        }
      }
      if (texture.format === DepthStencilFormat) {
        glInternalFormat = 34041;
        if (texture.type !== UnsignedInt248Type) {
          console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
          texture.type = UnsignedInt248Type;
          glType = utils.convert(texture.type);
        }
      }
      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      if (mipmaps.length > 0 && supportsMips) {
        for (var i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          mipmap = mipmaps[i2];
          state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (var i2 = 0, il = mipmaps.length; i2 < il; i2++) {
        mipmap = mipmaps[i2];
        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
            state.compressedTexImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
          }
        } else {
          state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      if (mipmaps.length > 0 && supportsMips) {
        for (var i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          mipmap = mipmaps[i2];
          state.texImage2D(3553, i2, glInternalFormat, glFormat, glType, mipmap);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
        textureProperties.__maxMipLevel = 0;
      }
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(3553, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    var glFormat = utils.convert(renderTarget.texture.format);
    var glType = utils.convert(renderTarget.texture.type);
    var glInternalFormat = getInternalFormat(glFormat, glType);
    state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
    _gl.bindFramebuffer(36160, framebuffer);
    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
    _gl.bindFramebuffer(36160, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      if (isMultisample) {
        var samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, 33189, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 33189, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        var samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, 34041, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      var glFormat = utils.convert(renderTarget.texture.format);
      var glType = utils.convert(renderTarget.texture.type);
      var glInternalFormat = getInternalFormat(glFormat, glType);
      if (isMultisample) {
        var samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(36161, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    _gl.bindFramebuffer(36160, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var isCube = renderTarget.isWebGLRenderTargetCube === true;
    if (renderTarget.depthTexture) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (var i2 = 0; i2 < 6; i2++) {
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i2]);
          renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget);
        }
      } else {
        _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
      }
    }
    _gl.bindFramebuffer(36160, null);
  }
  function setupRenderTarget(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(renderTarget.texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    info.memory.textures++;
    var isCube = renderTarget.isWebGLRenderTargetCube === true;
    var isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    var supportsMips = isPowerOfTwo(renderTarget) || capabilities.isWebGL2;
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (var i2 = 0; i2 < 6; i2++) {
        renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultisample) {
        if (capabilities.isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
          var glFormat = utils.convert(renderTarget.texture.format);
          var glType = utils.convert(renderTarget.texture.type);
          var glInternalFormat = getInternalFormat(glFormat, glType);
          var samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
          _gl.bindRenderbuffer(36161, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          _gl.bindFramebuffer(36160, null);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, renderTarget.texture, supportsMips);
      for (var i2 = 0; i2 < 6; i2++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, 36064, 34069 + i2);
      }
      if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
        generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(34067, null);
    } else {
      state.bindTexture(3553, textureProperties.__webglTexture);
      setTextureParameters(3553, renderTarget.texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);
      if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
        generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(3553, null);
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    var texture = renderTarget.texture;
    var supportsMips = isPowerOfTwo(renderTarget) || capabilities.isWebGL2;
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      var target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553;
      var webglTexture = properties.get(texture).__webglTexture;
      state.bindTexture(target, webglTexture);
      generateMipmap(target, texture, renderTarget.width, renderTarget.height);
      state.bindTexture(target, null);
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (capabilities.isWebGL2) {
        var renderTargetProperties = properties.get(renderTarget);
        _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
        _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
        var width = renderTarget.width;
        var height = renderTarget.height;
        var mask = 16384;
        if (renderTarget.depthBuffer)
          mask |= 256;
        if (renderTarget.stencilBuffer)
          mask |= 1024;
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
      } else {
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(capabilities.maxSamples, renderTarget.samples) : 0;
  }
  function updateVideoTexture(texture) {
    var id = texture.id;
    var frame = info.render.frame;
    if (_videoTextures[id] !== frame) {
      _videoTextures[id] = frame;
      texture.update();
    }
  }
  var warnedTexture2D = false;
  var warnedTextureCube = false;
  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
        warnedTexture2D = true;
      }
      texture = texture.texture;
    }
    setTexture2D(texture, slot);
  }
  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLRenderTargetCube) {
      if (warnedTextureCube === false) {
        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
        warnedTextureCube = true;
      }
      texture = texture.texture;
    }
    if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
      setTextureCube(texture, slot);
    } else {
      setTextureCubeDynamic(texture, slot);
    }
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setTextureCubeDynamic = setTextureCubeDynamic;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}
function WebGLUtils(gl, extensions, capabilities) {
  function convert(p2) {
    var extension;
    if (p2 === RepeatWrapping)
      return 10497;
    if (p2 === ClampToEdgeWrapping)
      return 33071;
    if (p2 === MirroredRepeatWrapping)
      return 33648;
    if (p2 === NearestFilter)
      return 9728;
    if (p2 === NearestMipMapNearestFilter)
      return 9984;
    if (p2 === NearestMipMapLinearFilter)
      return 9986;
    if (p2 === LinearFilter)
      return 9729;
    if (p2 === LinearMipMapNearestFilter)
      return 9985;
    if (p2 === LinearMipMapLinearFilter)
      return 9987;
    if (p2 === UnsignedByteType)
      return 5121;
    if (p2 === UnsignedShort4444Type)
      return 32819;
    if (p2 === UnsignedShort5551Type)
      return 32820;
    if (p2 === UnsignedShort565Type)
      return 33635;
    if (p2 === ByteType)
      return 5120;
    if (p2 === ShortType)
      return 5122;
    if (p2 === UnsignedShortType)
      return 5123;
    if (p2 === IntType)
      return 5124;
    if (p2 === UnsignedIntType)
      return 5125;
    if (p2 === FloatType)
      return 5126;
    if (p2 === HalfFloatType) {
      if (capabilities.isWebGL2)
        return 5131;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null)
        return extension.HALF_FLOAT_OES;
    }
    if (p2 === AlphaFormat)
      return 6406;
    if (p2 === RGBFormat)
      return 6407;
    if (p2 === RGBAFormat)
      return 6408;
    if (p2 === LuminanceFormat)
      return 6409;
    if (p2 === LuminanceAlphaFormat)
      return 6410;
    if (p2 === DepthFormat)
      return 6402;
    if (p2 === DepthStencilFormat)
      return 34041;
    if (p2 === RedFormat)
      return 6403;
    if (p2 === AddEquation)
      return 32774;
    if (p2 === SubtractEquation)
      return 32778;
    if (p2 === ReverseSubtractEquation)
      return 32779;
    if (p2 === ZeroFactor)
      return 0;
    if (p2 === OneFactor)
      return 1;
    if (p2 === SrcColorFactor)
      return 768;
    if (p2 === OneMinusSrcColorFactor)
      return 769;
    if (p2 === SrcAlphaFactor)
      return 770;
    if (p2 === OneMinusSrcAlphaFactor)
      return 771;
    if (p2 === DstAlphaFactor)
      return 772;
    if (p2 === OneMinusDstAlphaFactor)
      return 773;
    if (p2 === DstColorFactor)
      return 774;
    if (p2 === OneMinusDstColorFactor)
      return 775;
    if (p2 === SrcAlphaSaturateFactor)
      return 776;
    if (p2 === RGB_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT3_Format || p2 === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get("WEBGL_compressed_texture_s3tc");
      if (extension !== null) {
        if (p2 === RGB_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p2 === RGBA_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p2 === RGBA_S3TC_DXT3_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p2 === RGBA_S3TC_DXT5_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
    }
    if (p2 === RGB_PVRTC_4BPPV1_Format || p2 === RGB_PVRTC_2BPPV1_Format || p2 === RGBA_PVRTC_4BPPV1_Format || p2 === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p2 === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p2 === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p2 === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p2 === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }
    }
    if (p2 === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null)
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
    }
    if (p2 === RGBA_ASTC_4x4_Format || p2 === RGBA_ASTC_5x4_Format || p2 === RGBA_ASTC_5x5_Format || p2 === RGBA_ASTC_6x5_Format || p2 === RGBA_ASTC_6x6_Format || p2 === RGBA_ASTC_8x5_Format || p2 === RGBA_ASTC_8x6_Format || p2 === RGBA_ASTC_8x8_Format || p2 === RGBA_ASTC_10x5_Format || p2 === RGBA_ASTC_10x6_Format || p2 === RGBA_ASTC_10x8_Format || p2 === RGBA_ASTC_10x10_Format || p2 === RGBA_ASTC_12x10_Format || p2 === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        return p2;
      }
    }
    if (p2 === MinEquation || p2 === MaxEquation) {
      if (capabilities.isWebGL2) {
        if (p2 === MinEquation)
          return 32775;
        if (p2 === MaxEquation)
          return 32776;
      }
      extension = extensions.get("EXT_blend_minmax");
      if (extension !== null) {
        if (p2 === MinEquation)
          return extension.MIN_EXT;
        if (p2 === MaxEquation)
          return extension.MAX_EXT;
      }
    }
    if (p2 === UnsignedInt248Type) {
      if (capabilities.isWebGL2)
        return 34042;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null)
        return extension.UNSIGNED_INT_24_8_WEBGL;
    }
    return 0;
  }
  return { convert };
}
function Group() {
  Object3D.call(this);
  this.type = "Group";
}
Group.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Group,
  isGroup: true
});
function Camera() {
  Object3D.call(this);
  this.type = "Camera";
  this.matrixWorldInverse = new Matrix4();
  this.projectionMatrix = new Matrix4();
  this.projectionMatrixInverse = new Matrix4();
}
Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Camera,
  isCamera: true,
  copy: function(source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  },
  getWorldDirection: function(target) {
    if (target === void 0) {
      console.warn("THREE.Camera: .getWorldDirection() target is now required");
      target = new Vector3();
    }
    this.updateMatrixWorld(true);
    var e2 = this.matrixWorld.elements;
    return target.set(-e2[8], -e2[9], -e2[10]).normalize();
  },
  updateMatrixWorld: function(force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function PerspectiveCamera(fov2, aspect2, near, far) {
  Camera.call(this);
  this.type = "PerspectiveCamera";
  this.fov = fov2 !== void 0 ? fov2 : 50;
  this.zoom = 1;
  this.near = near !== void 0 ? near : 0.1;
  this.far = far !== void 0 ? far : 2e3;
  this.focus = 10;
  this.aspect = aspect2 !== void 0 ? aspect2 : 1;
  this.view = null;
  this.filmGauge = 35;
  this.filmOffset = 0;
  this.updateProjectionMatrix();
}
PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: PerspectiveCamera,
  isPerspectiveCamera: true,
  copy: function(source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  },
  setFocalLength: function(focalLength) {
    var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  },
  getFocalLength: function() {
    var vExtentSlope = Math.tan(_Math.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  },
  getEffectiveFOV: function() {
    return _Math.RAD2DEG * 2 * Math.atan(Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom);
  },
  getFilmWidth: function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  setViewOffset: function(fullWidth, fullHeight, x2, y, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x2;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    var near = this.near, top = near * Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -0.5 * width, view2 = this.view;
    if (this.view !== null && this.view.enabled) {
      var fullWidth = view2.fullWidth, fullHeight = view2.fullHeight;
      left += view2.offsetX * width / fullWidth;
      top -= view2.offsetY * height / fullHeight;
      width *= view2.width / fullWidth;
      height *= view2.height / fullHeight;
    }
    var skew = this.filmOffset;
    if (skew !== 0)
      left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function(meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
});
function ArrayCamera(array) {
  PerspectiveCamera.call(this);
  this.cameras = array || [];
}
ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
  constructor: ArrayCamera,
  isArrayCamera: true
});
var cameraLPos = new Vector3();
var cameraRPos = new Vector3();
function setProjectionFromUnion(camera, cameraL, cameraR) {
  cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
  cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
  var ipd = cameraLPos.distanceTo(cameraRPos);
  var projL = cameraL.projectionMatrix.elements;
  var projR = cameraR.projectionMatrix.elements;
  var near = projL[14] / (projL[10] - 1);
  var far = projL[14] / (projL[10] + 1);
  var topFov = (projL[9] + 1) / projL[5];
  var bottomFov = (projL[9] - 1) / projL[5];
  var leftFov = (projL[8] - 1) / projL[0];
  var rightFov = (projR[8] + 1) / projR[0];
  var left = near * leftFov;
  var right = near * rightFov;
  var zOffset = ipd / (-leftFov + rightFov);
  var xOffset = zOffset * -leftFov;
  cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
  camera.translateX(xOffset);
  camera.translateZ(zOffset);
  camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
  camera.matrixWorldInverse.getInverse(camera.matrixWorld);
  var near2 = near + zOffset;
  var far2 = far + zOffset;
  var left2 = left - xOffset;
  var right2 = right + (ipd - xOffset);
  var top2 = topFov * far / far2 * near2;
  var bottom2 = bottomFov * far / far2 * near2;
  camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
}
function WebVRManager(renderer) {
  var renderWidth, renderHeight;
  var scope = this;
  var device = null;
  var frameData = null;
  var poseTarget = null;
  var controllers = [];
  var standingMatrix = new Matrix4();
  var standingMatrixInverse = new Matrix4();
  var framebufferScaleFactor = 1;
  var referenceSpaceType = "local-floor";
  if (typeof window !== "undefined" && "VRFrameData" in window) {
    frameData = new window.VRFrameData();
    window.addEventListener("vrdisplaypresentchange", onVRDisplayPresentChange, false);
  }
  var matrixWorldInverse = new Matrix4();
  var tempQuaternion = new Quaternion();
  var tempPosition = new Vector3();
  var cameraL = new PerspectiveCamera();
  cameraL.viewport = new Vector4();
  cameraL.layers.enable(1);
  var cameraR = new PerspectiveCamera();
  cameraR.viewport = new Vector4();
  cameraR.layers.enable(2);
  var cameraVR = new ArrayCamera([cameraL, cameraR]);
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2);
  function isPresenting() {
    return device !== null && device.isPresenting === true;
  }
  var currentSize = new Vector2(), currentPixelRatio;
  function onVRDisplayPresentChange() {
    if (isPresenting()) {
      var eyeParameters = device.getEyeParameters("left");
      renderWidth = 2 * eyeParameters.renderWidth * framebufferScaleFactor;
      renderHeight = eyeParameters.renderHeight * framebufferScaleFactor;
      currentPixelRatio = renderer.getPixelRatio();
      renderer.getSize(currentSize);
      renderer.setDrawingBufferSize(renderWidth, renderHeight, 1);
      cameraL.viewport.set(0, 0, renderWidth / 2, renderHeight);
      cameraR.viewport.set(renderWidth / 2, 0, renderWidth / 2, renderHeight);
      animation.start();
    } else {
      if (scope.enabled) {
        renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio);
      }
      animation.stop();
    }
  }
  var triggers = [];
  function findGamepad(id) {
    var gamepads = navigator.getGamepads && navigator.getGamepads();
    for (var i2 = 0, j = 0, l2 = gamepads.length; i2 < l2; i2++) {
      var gamepad = gamepads[i2];
      if (gamepad && (gamepad.id === "Daydream Controller" || gamepad.id === "Gear VR Controller" || gamepad.id === "Oculus Go Controller" || gamepad.id === "OpenVR Gamepad" || gamepad.id.startsWith("Oculus Touch") || gamepad.id.startsWith("Spatial Controller"))) {
        if (j === id)
          return gamepad;
        j++;
      }
    }
  }
  function updateControllers() {
    for (var i2 = 0; i2 < controllers.length; i2++) {
      var controller = controllers[i2];
      var gamepad = findGamepad(i2);
      if (gamepad !== void 0 && gamepad.pose !== void 0) {
        if (gamepad.pose === null)
          return;
        var pose = gamepad.pose;
        if (pose.hasPosition === false)
          controller.position.set(0.2, -0.6, -0.05);
        if (pose.position !== null)
          controller.position.fromArray(pose.position);
        if (pose.orientation !== null)
          controller.quaternion.fromArray(pose.orientation);
        controller.matrix.compose(controller.position, controller.quaternion, controller.scale);
        controller.matrix.premultiply(standingMatrix);
        controller.matrix.decompose(controller.position, controller.quaternion, controller.scale);
        controller.matrixWorldNeedsUpdate = true;
        controller.visible = true;
        var buttonId = gamepad.id === "Daydream Controller" ? 0 : 1;
        if (triggers[i2] === void 0)
          triggers[i2] = false;
        if (triggers[i2] !== gamepad.buttons[buttonId].pressed) {
          triggers[i2] = gamepad.buttons[buttonId].pressed;
          if (triggers[i2] === true) {
            controller.dispatchEvent({ type: "selectstart" });
          } else {
            controller.dispatchEvent({ type: "selectend" });
            controller.dispatchEvent({ type: "select" });
          }
        }
      } else {
        controller.visible = false;
      }
    }
  }
  function updateViewportFromBounds(viewport, bounds) {
    if (bounds !== null && bounds.length === 4) {
      viewport.set(bounds[0] * renderWidth, bounds[1] * renderHeight, bounds[2] * renderWidth, bounds[3] * renderHeight);
    }
  }
  this.enabled = false;
  this.getController = function(id) {
    var controller = controllers[id];
    if (controller === void 0) {
      controller = new Group();
      controller.matrixAutoUpdate = false;
      controller.visible = false;
      controllers[id] = controller;
    }
    return controller;
  };
  this.getDevice = function() {
    return device;
  };
  this.setDevice = function(value) {
    if (value !== void 0)
      device = value;
    animation.setContext(value);
  };
  this.setFramebufferScaleFactor = function(value) {
    framebufferScaleFactor = value;
  };
  this.setReferenceSpaceType = function(value) {
    referenceSpaceType = value;
  };
  this.setPoseTarget = function(object) {
    if (object !== void 0)
      poseTarget = object;
  };
  this.getCamera = function(camera) {
    var userHeight = referenceSpaceType === "local-floor" ? 1.6 : 0;
    if (isPresenting() === false) {
      camera.position.set(0, userHeight, 0);
      camera.rotation.set(0, 0, 0);
      return camera;
    }
    device.depthNear = camera.near;
    device.depthFar = camera.far;
    device.getFrameData(frameData);
    if (referenceSpaceType === "local-floor") {
      var stageParameters = device.stageParameters;
      if (stageParameters) {
        standingMatrix.fromArray(stageParameters.sittingToStandingTransform);
      } else {
        standingMatrix.makeTranslation(0, userHeight, 0);
      }
    }
    var pose = frameData.pose;
    var poseObject = poseTarget !== null ? poseTarget : camera;
    poseObject.matrix.copy(standingMatrix);
    poseObject.matrix.decompose(poseObject.position, poseObject.quaternion, poseObject.scale);
    if (pose.orientation !== null) {
      tempQuaternion.fromArray(pose.orientation);
      poseObject.quaternion.multiply(tempQuaternion);
    }
    if (pose.position !== null) {
      tempQuaternion.setFromRotationMatrix(standingMatrix);
      tempPosition.fromArray(pose.position);
      tempPosition.applyQuaternion(tempQuaternion);
      poseObject.position.add(tempPosition);
    }
    poseObject.updateMatrixWorld();
    cameraL.near = camera.near;
    cameraR.near = camera.near;
    cameraL.far = camera.far;
    cameraR.far = camera.far;
    cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix);
    cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix);
    standingMatrixInverse.getInverse(standingMatrix);
    if (referenceSpaceType === "local-floor") {
      cameraL.matrixWorldInverse.multiply(standingMatrixInverse);
      cameraR.matrixWorldInverse.multiply(standingMatrixInverse);
    }
    var parent2 = poseObject.parent;
    if (parent2 !== null) {
      matrixWorldInverse.getInverse(parent2.matrixWorld);
      cameraL.matrixWorldInverse.multiply(matrixWorldInverse);
      cameraR.matrixWorldInverse.multiply(matrixWorldInverse);
    }
    cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);
    cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);
    cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix);
    cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix);
    setProjectionFromUnion(cameraVR, cameraL, cameraR);
    var layers = device.getLayers();
    if (layers.length) {
      var layer = layers[0];
      updateViewportFromBounds(cameraL.viewport, layer.leftBounds);
      updateViewportFromBounds(cameraR.viewport, layer.rightBounds);
    }
    updateControllers();
    return cameraVR;
  };
  this.getStandingMatrix = function() {
    return standingMatrix;
  };
  this.isPresenting = isPresenting;
  var animation = new WebGLAnimation();
  this.setAnimationLoop = function(callback) {
    animation.setAnimationLoop(callback);
    if (isPresenting())
      animation.start();
  };
  this.submitFrame = function() {
    if (isPresenting())
      device.submitFrame();
  };
  this.dispose = function() {
    if (typeof window !== "undefined") {
      window.removeEventListener("vrdisplaypresentchange", onVRDisplayPresentChange);
    }
  };
  this.setFrameOfReferenceType = function() {
    console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.");
  };
}
function WebXRManager(renderer) {
  var gl = renderer.context;
  var session = null;
  var referenceSpace = null;
  var referenceSpaceType = "local-floor";
  var pose = null;
  var controllers = [];
  var inputSources = [];
  function isPresenting() {
    return session !== null && referenceSpace !== null;
  }
  var cameraL = new PerspectiveCamera();
  cameraL.layers.enable(1);
  cameraL.viewport = new Vector4();
  var cameraR = new PerspectiveCamera();
  cameraR.layers.enable(2);
  cameraR.viewport = new Vector4();
  var cameraVR = new ArrayCamera([cameraL, cameraR]);
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2);
  this.enabled = false;
  this.getController = function(id) {
    var controller = controllers[id];
    if (controller === void 0) {
      controller = new Group();
      controller.matrixAutoUpdate = false;
      controller.visible = false;
      controllers[id] = controller;
    }
    return controller;
  };
  function onSessionEvent(event) {
    for (var i2 = 0; i2 < controllers.length; i2++) {
      if (inputSources[i2] === event.inputSource) {
        controllers[i2].dispatchEvent({ type: event.type });
      }
    }
  }
  function onSessionEnd() {
    renderer.setFramebuffer(null);
    renderer.setRenderTarget(renderer.getRenderTarget());
    animation.stop();
  }
  function onRequestReferenceSpace(value) {
    referenceSpace = value;
    animation.setContext(session);
    animation.start();
  }
  this.setFramebufferScaleFactor = function(value) {
  };
  this.setReferenceSpaceType = function(value) {
    referenceSpaceType = value;
  };
  this.getSession = function() {
    return session;
  };
  this.setSession = function(value) {
    session = value;
    if (session !== null) {
      session.addEventListener("select", onSessionEvent);
      session.addEventListener("selectstart", onSessionEvent);
      session.addEventListener("selectend", onSessionEvent);
      session.addEventListener("end", onSessionEnd);
      session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });
      session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace);
      inputSources = session.inputSources;
      session.addEventListener("inputsourceschange", function() {
        inputSources = session.inputSources;
        console.log(inputSources);
        for (var i2 = 0; i2 < controllers.length; i2++) {
          var controller = controllers[i2];
          controller.userData.inputSource = inputSources[i2];
        }
      });
    }
  };
  function updateCamera(camera, parent2) {
    if (parent2 === null) {
      camera.matrixWorld.copy(camera.matrix);
    } else {
      camera.matrixWorld.multiplyMatrices(parent2.matrixWorld, camera.matrix);
    }
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
  }
  this.getCamera = function(camera) {
    if (isPresenting()) {
      var parent2 = camera.parent;
      var cameras = cameraVR.cameras;
      updateCamera(cameraVR, parent2);
      for (var i2 = 0; i2 < cameras.length; i2++) {
        updateCamera(cameras[i2], parent2);
      }
      camera.matrixWorld.copy(cameraVR.matrixWorld);
      var children2 = camera.children;
      for (var i2 = 0, l2 = children2.length; i2 < l2; i2++) {
        children2[i2].updateMatrixWorld(true);
      }
      setProjectionFromUnion(cameraVR, cameraL, cameraR);
      return cameraVR;
    }
    return camera;
  };
  this.isPresenting = isPresenting;
  var onAnimationFrameCallback = null;
  function onAnimationFrame(time, frame) {
    pose = frame.getViewerPose(referenceSpace);
    if (pose !== null) {
      var views = pose.views;
      var baseLayer = session.renderState.baseLayer;
      renderer.setFramebuffer(baseLayer.framebuffer);
      for (var i2 = 0; i2 < views.length; i2++) {
        var view2 = views[i2];
        var viewport = baseLayer.getViewport(view2);
        var viewMatrix = view2.transform.inverse.matrix;
        var camera = cameraVR.cameras[i2];
        camera.matrix.fromArray(viewMatrix).getInverse(camera.matrix);
        camera.projectionMatrix.fromArray(view2.projectionMatrix);
        camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
        if (i2 === 0) {
          cameraVR.matrix.copy(camera.matrix);
        }
      }
    }
    for (var i2 = 0; i2 < controllers.length; i2++) {
      var controller = controllers[i2];
      var inputSource = inputSources[i2];
      if (inputSource) {
        var inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose !== null) {
          controller.matrix.fromArray(inputPose.transform.matrix);
          controller.matrix.decompose(controller.position, controller.rotation, controller.scale);
          controller.visible = true;
          continue;
        }
      }
      controller.visible = false;
    }
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time);
  }
  var animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
  };
  this.dispose = function() {
  };
  this.getStandingMatrix = function() {
    console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed.");
    return new Matrix4();
  };
  this.getDevice = function() {
    console.warn("THREE.WebXRManager: getDevice() has been deprecated.");
  };
  this.setDevice = function() {
    console.warn("THREE.WebXRManager: setDevice() has been deprecated.");
  };
  this.setFrameOfReferenceType = function() {
    console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.");
  };
  this.submitFrame = function() {
  };
}
function WebGLRenderer(parameters) {
  console.log("THREE.WebGLRenderer", REVISION$1);
  parameters = parameters || {};
  var _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), _context = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
  var currentRenderList = null;
  var currentRenderState = null;
  this.domElement = _canvas2;
  this.context = null;
  this.debug = {
    checkShaderErrors: true
  };
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.gammaFactor = 2;
  this.gammaInput = false;
  this.gammaOutput = false;
  this.physicallyCorrectLights = false;
  this.toneMapping = LinearToneMapping;
  this.toneMappingExposure = 1;
  this.toneMappingWhitePoint = 1;
  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;
  var _this = this, _isContextLost = false, _framebuffer = null, _currentActiveCubeFace = 0, _currentActiveMipmapLevel = 0, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryProgram = {
    geometry: null,
    program: null,
    wireframe: false
  }, _currentCamera = null, _currentArrayCamera = null, _currentViewport = new Vector4(), _currentScissor = new Vector4(), _currentScissorTest = null, _width = _canvas2.width, _height = _canvas2.height, _pixelRatio = 1, _viewport = new Vector4(0, 0, _width, _height), _scissor = new Vector4(0, 0, _width, _height), _scissorTest = false, _frustum = new Frustum(), _clipping = new WebGLClipping(), _clippingEnabled = false, _localClippingEnabled = false, _projScreenMatrix = new Matrix4(), _vector3 = new Vector3();
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  var _gl;
  try {
    var contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat,
      xrCompatible: true
    };
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    _gl = _context || _canvas2.getContext("webgl", contextAttributes) || _canvas2.getContext("experimental-webgl", contextAttributes);
    if (_gl === null) {
      if (_canvas2.getContext("webgl") !== null) {
        throw new Error("Error creating WebGL context with your selected attributes.");
      } else {
        throw new Error("Error creating WebGL context.");
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
      };
    }
  } catch (error) {
    console.error("THREE.WebGLRenderer: " + error.message);
    throw error;
  }
  var extensions, capabilities, state, info;
  var properties, textures, attributes, geometries, objects;
  var programCache, renderLists, renderStates;
  var background, morphtargets, bufferRenderer, indexedBufferRenderer;
  var utils;
  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    if (!capabilities.isWebGL2) {
      extensions.get("WEBGL_depth_texture");
      extensions.get("OES_texture_float");
      extensions.get("OES_texture_half_float");
      extensions.get("OES_texture_half_float_linear");
      extensions.get("OES_standard_derivatives");
      extensions.get("OES_element_index_uint");
      extensions.get("ANGLE_instanced_arrays");
    }
    extensions.get("OES_texture_float_linear");
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, utils, capabilities);
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    attributes = new WebGLAttributes(_gl);
    geometries = new WebGLGeometries(_gl, attributes, info);
    objects = new WebGLObjects(geometries, info);
    morphtargets = new WebGLMorphtargets(_gl);
    programCache = new WebGLPrograms(_this, extensions, capabilities, textures);
    renderLists = new WebGLRenderLists();
    renderStates = new WebGLRenderStates();
    background = new WebGLBackground(_this, state, objects, _premultipliedAlpha);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.context = _gl;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();
  var vr = typeof navigator !== "undefined" && "xr" in navigator && "supportsSession" in navigator.xr ? new WebXRManager(_this) : new WebVRManager(_this);
  this.vr = vr;
  var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
  this.shadowMap = shadowMap;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    var extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.loseContext();
  };
  this.forceContextRestore = function() {
    var extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0)
      return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument");
      target = new Vector2();
    }
    return target.set(_width, _height);
  };
  this.setSize = function(width, height, updateStyle) {
    if (vr.isPresenting()) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width;
    _height = height;
    _canvas2.width = width * _pixelRatio;
    _canvas2.height = height * _pixelRatio;
    if (updateStyle !== false) {
      _canvas2.style.width = width + "px";
      _canvas2.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument");
      target = new Vector2();
    }
    return target.set(_width * _pixelRatio, _height * _pixelRatio);
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas2.width = width * pixelRatio;
    _canvas2.height = height * pixelRatio;
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument");
      target = new Vector4();
    }
    return target.copy(_currentViewport);
  };
  this.getViewport = function(target) {
    return target.copy(_viewport);
  };
  this.setViewport = function(x2, y, width, height) {
    if (x2.isVector4) {
      _viewport.set(x2.x, x2.y, x2.z, x2.w);
    } else {
      _viewport.set(x2, y, width, height);
    }
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
  };
  this.getScissor = function(target) {
    return target.copy(_scissor);
  };
  this.setScissor = function(x2, y, width, height) {
    if (x2.isVector4) {
      _scissor.set(x2.x, x2.y, x2.z, x2.w);
    } else {
      _scissor.set(x2, y, width, height);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
  };
  this.getScissorTest = function() {
    return _scissorTest;
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.getClearColor = function() {
    return background.getClearColor();
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color, depth, stencil) {
    var bits = 0;
    if (color === void 0 || color)
      bits |= 16384;
    if (depth === void 0 || depth)
      bits |= 256;
    if (stencil === void 0 || stencil)
      bits |= 1024;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    objects.dispose();
    vr.dispose();
    animation.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    initGLContext();
  }
  function onMaterialDispose(event) {
    var material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReference(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReference(material) {
    var programInfo = properties.get(material).program;
    material.program = void 0;
    if (programInfo !== void 0) {
      programCache.releaseProgram(programInfo);
    }
  }
  function renderObjectImmediate(object, program) {
    object.render(function(object2) {
      _this.renderBufferImmediate(object2, program);
    });
  }
  this.renderBufferImmediate = function(object, program) {
    state.initAttributes();
    var buffers = properties.get(object);
    if (object.hasPositions && !buffers.position)
      buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal)
      buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv)
      buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color)
      buffers.color = _gl.createBuffer();
    var programAttributes = program.getAttributes();
    if (object.hasPositions) {
      _gl.bindBuffer(34962, buffers.position);
      _gl.bufferData(34962, object.positionArray, 35048);
      state.enableAttribute(programAttributes.position);
      _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
    }
    if (object.hasNormals) {
      _gl.bindBuffer(34962, buffers.normal);
      _gl.bufferData(34962, object.normalArray, 35048);
      state.enableAttribute(programAttributes.normal);
      _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
    }
    if (object.hasUvs) {
      _gl.bindBuffer(34962, buffers.uv);
      _gl.bufferData(34962, object.uvArray, 35048);
      state.enableAttribute(programAttributes.uv);
      _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
    }
    if (object.hasColors) {
      _gl.bindBuffer(34962, buffers.color);
      _gl.bufferData(34962, object.colorArray, 35048);
      state.enableAttribute(programAttributes.color);
      _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
    }
    state.disableUnusedAttributes();
    _gl.drawArrays(4, 0, object.count);
    object.count = 0;
  };
  this.renderBufferDirect = function(camera, fog, geometry2, material, object, group) {
    var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    state.setMaterial(material, frontFaceCW);
    var program = setProgram(camera, fog, material, object);
    var updateBuffers = false;
    if (_currentGeometryProgram.geometry !== geometry2.id || _currentGeometryProgram.program !== program.id || _currentGeometryProgram.wireframe !== (material.wireframe === true)) {
      _currentGeometryProgram.geometry = geometry2.id;
      _currentGeometryProgram.program = program.id;
      _currentGeometryProgram.wireframe = material.wireframe === true;
      updateBuffers = true;
    }
    if (object.morphTargetInfluences) {
      morphtargets.update(object, geometry2, material, program);
      updateBuffers = true;
    }
    var index2 = geometry2.index;
    var position = geometry2.attributes.position;
    var rangeFactor = 1;
    if (material.wireframe === true) {
      index2 = geometries.getWireframeAttribute(geometry2);
      rangeFactor = 2;
    }
    var attribute;
    var renderer = bufferRenderer;
    if (index2 !== null) {
      attribute = attributes.get(index2);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }
    if (updateBuffers) {
      setupVertexAttributes(material, program, geometry2);
      if (index2 !== null) {
        _gl.bindBuffer(34963, attribute.buffer);
      }
    }
    var dataCount = Infinity;
    if (index2 !== null) {
      dataCount = index2.count;
    } else if (position !== void 0) {
      dataCount = position.count;
    }
    var rangeStart = geometry2.drawRange.start * rangeFactor;
    var rangeCount = geometry2.drawRange.count * rangeFactor;
    var groupStart = group !== null ? group.start * rangeFactor : 0;
    var groupCount = group !== null ? group.count * rangeFactor : Infinity;
    var drawStart = Math.max(rangeStart, groupStart);
    var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    var drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0)
      return;
    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        switch (object.drawMode) {
          case TrianglesDrawMode:
            renderer.setMode(4);
            break;
          case TriangleStripDrawMode:
            renderer.setMode(5);
            break;
          case TriangleFanDrawMode:
            renderer.setMode(6);
            break;
        }
      }
    } else if (object.isLine) {
      var lineWidth = material.linewidth;
      if (lineWidth === void 0)
        lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }
    if (geometry2 && geometry2.isInstancedBufferGeometry) {
      if (geometry2.maxInstancedCount > 0) {
        renderer.renderInstances(geometry2, drawStart, drawCount);
      }
    } else {
      renderer.render(drawStart, drawCount);
    }
  };
  function setupVertexAttributes(material, program, geometry2) {
    if (geometry2 && geometry2.isInstancedBufferGeometry && !capabilities.isWebGL2) {
      if (extensions.get("ANGLE_instanced_arrays") === null) {
        console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    state.initAttributes();
    var geometryAttributes = geometry2.attributes;
    var programAttributes = program.getAttributes();
    var materialDefaultAttributeValues = material.defaultAttributeValues;
    for (var name in programAttributes) {
      var programAttribute = programAttributes[name];
      if (programAttribute >= 0) {
        var geometryAttribute = geometryAttributes[name];
        if (geometryAttribute !== void 0) {
          var normalized = geometryAttribute.normalized;
          var size = geometryAttribute.itemSize;
          var attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          var buffer = attribute.buffer;
          var type = attribute.type;
          var bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            var data = geometryAttribute.data;
            var stride = data.stride;
            var offset2 = geometryAttribute.offset;
            if (data && data.isInstancedInterleavedBuffer) {
              state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
              if (geometry2.maxInstancedCount === void 0) {
                geometry2.maxInstancedCount = data.meshPerAttribute * data.count;
              }
            } else {
              state.enableAttribute(programAttribute);
            }
            _gl.bindBuffer(34962, buffer);
            _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset2 * bytesPerElement);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
              if (geometry2.maxInstancedCount === void 0) {
                geometry2.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              state.enableAttribute(programAttribute);
            }
            _gl.bindBuffer(34962, buffer);
            _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          var value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                _gl.vertexAttrib2fv(programAttribute, value);
                break;
              case 3:
                _gl.vertexAttrib3fv(programAttribute, value);
                break;
              case 4:
                _gl.vertexAttrib4fv(programAttribute, value);
                break;
              default:
                _gl.vertexAttrib1fv(programAttribute, value);
            }
          }
        }
      }
    }
    state.disableUnusedAttributes();
  }
  this.compile = function(scene, camera) {
    currentRenderState = renderStates.get(scene, camera);
    currentRenderState.init();
    scene.traverse(function(object) {
      if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights(camera);
    scene.traverse(function(object) {
      if (object.material) {
        if (Array.isArray(object.material)) {
          for (var i2 = 0; i2 < object.material.length; i2++) {
            initMaterial(object.material[i2], scene.fog, object);
          }
        } else {
          initMaterial(object.material, scene.fog, object);
        }
      }
    });
  };
  var onAnimationFrameCallback = null;
  function onAnimationFrame(time) {
    if (vr.isPresenting())
      return;
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time);
  }
  var animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== "undefined")
    animation.setContext(window);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    vr.setAnimationLoop(callback);
    animation.start();
  };
  this.render = function(scene, camera) {
    var renderTarget, forceClear;
    if (arguments[2] !== void 0) {
      console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
      renderTarget = arguments[2];
    }
    if (arguments[3] !== void 0) {
      console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
      forceClear = arguments[3];
    }
    if (!(camera && camera.isCamera)) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost)
      return;
    _currentGeometryProgram.geometry = null;
    _currentGeometryProgram.program = null;
    _currentGeometryProgram.wireframe = false;
    _currentMaterialId = -1;
    _currentCamera = null;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    if (vr.enabled) {
      camera = vr.getCamera(camera);
    }
    currentRenderState = renderStates.get(scene, camera);
    currentRenderState.init();
    scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromMatrix(_projScreenMatrix);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, camera);
    currentRenderList.init();
    projectObject(scene, camera, 0, _this.sortObjects);
    if (_this.sortObjects === true) {
      currentRenderList.sort();
    }
    if (_clippingEnabled)
      _clipping.beginShadows();
    var shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    currentRenderState.setupLights(camera);
    if (_clippingEnabled)
      _clipping.endShadows();
    if (this.info.autoReset)
      this.info.reset();
    if (renderTarget !== void 0) {
      this.setRenderTarget(renderTarget);
    }
    background.render(currentRenderList, scene, camera, forceClear);
    var opaqueObjects = currentRenderList.opaque;
    var transparentObjects = currentRenderList.transparent;
    if (scene.overrideMaterial) {
      var overrideMaterial = scene.overrideMaterial;
      if (opaqueObjects.length)
        renderObjects(opaqueObjects, scene, camera, overrideMaterial);
      if (transparentObjects.length)
        renderObjects(transparentObjects, scene, camera, overrideMaterial);
    } else {
      if (opaqueObjects.length)
        renderObjects(opaqueObjects, scene, camera);
      if (transparentObjects.length)
        renderObjects(transparentObjects, scene, camera);
    }
    scene.onAfterRender(_this, scene, camera);
    if (_currentRenderTarget !== null) {
      textures.updateRenderTargetMipmap(_currentRenderTarget);
      textures.updateMultisampleRenderTarget(_currentRenderTarget);
    }
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
    if (vr.enabled) {
      vr.submitFrame();
    }
    currentRenderList = null;
    currentRenderState = null;
  };
  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false)
      return;
    var visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          var geometry2 = objects.update(object);
          var material = object.material;
          if (material.visible) {
            currentRenderList.push(object, geometry2, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
        }
        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          object.skeleton.update();
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          var geometry2 = objects.update(object);
          var material = object.material;
          if (Array.isArray(material)) {
            var groups = geometry2.groups;
            for (var i2 = 0, l2 = groups.length; i2 < l2; i2++) {
              var group = groups[i2];
              var groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry2, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry2, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    var children2 = object.children;
    for (var i2 = 0, l2 = children2.length; i2 < l2; i2++) {
      projectObject(children2[i2], camera, groupOrder, sortObjects);
    }
  }
  function renderObjects(renderList2, scene, camera, overrideMaterial) {
    for (var i2 = 0, l2 = renderList2.length; i2 < l2; i2++) {
      var renderItem = renderList2[i2];
      var object = renderItem.object;
      var geometry2 = renderItem.geometry;
      var material = overrideMaterial === void 0 ? renderItem.material : overrideMaterial;
      var group = renderItem.group;
      if (camera.isArrayCamera) {
        _currentArrayCamera = camera;
        var cameras = camera.cameras;
        for (var j = 0, jl = cameras.length; j < jl; j++) {
          var camera2 = cameras[j];
          if (object.layers.test(camera2.layers)) {
            state.viewport(_currentViewport.copy(camera2.viewport));
            currentRenderState.setupLights(camera2);
            renderObject(object, scene, camera2, geometry2, material, group);
          }
        }
      } else {
        _currentArrayCamera = null;
        renderObject(object, scene, camera, geometry2, material, group);
      }
    }
  }
  function renderObject(object, scene, camera, geometry2, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry2, material, group);
    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    if (object.isImmediateRenderObject) {
      state.setMaterial(material);
      var program = setProgram(camera, scene.fog, material, object);
      _currentGeometryProgram.geometry = null;
      _currentGeometryProgram.program = null;
      _currentGeometryProgram.wireframe = false;
      renderObjectImmediate(object, program);
    } else {
      _this.renderBufferDirect(camera, scene.fog, geometry2, material, object, group);
    }
    object.onAfterRender(_this, scene, camera, geometry2, material, group);
    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
  }
  function initMaterial(material, fog, object) {
    var materialProperties = properties.get(material);
    var lights = currentRenderState.state.lights;
    var shadowsArray = currentRenderState.state.shadowsArray;
    var lightsHash = materialProperties.lightsHash;
    var lightsStateHash = lights.state.hash;
    var parameters2 = programCache.getParameters(material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object);
    var code = programCache.getProgramCode(material, parameters2);
    var program = materialProperties.program;
    var programChange = true;
    if (program === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
    } else if (program.code !== code) {
      releaseMaterialProgramReference(material);
    } else if (lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength) {
      lightsHash.stateID = lightsStateHash.stateID;
      lightsHash.directionalLength = lightsStateHash.directionalLength;
      lightsHash.pointLength = lightsStateHash.pointLength;
      lightsHash.spotLength = lightsStateHash.spotLength;
      lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
      lightsHash.hemiLength = lightsStateHash.hemiLength;
      lightsHash.shadowsLength = lightsStateHash.shadowsLength;
      programChange = false;
    } else if (parameters2.shaderID !== void 0) {
      return;
    } else {
      programChange = false;
    }
    if (programChange) {
      if (parameters2.shaderID) {
        var shader = ShaderLib[parameters2.shaderID];
        materialProperties.shader = {
          name: material.type,
          uniforms: cloneUniforms(shader.uniforms),
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader
        };
      } else {
        materialProperties.shader = {
          name: material.type,
          uniforms: material.uniforms,
          vertexShader: material.vertexShader,
          fragmentShader: material.fragmentShader
        };
      }
      material.onBeforeCompile(materialProperties.shader, _this);
      code = programCache.getProgramCode(material, parameters2);
      program = programCache.acquireProgram(material, materialProperties.shader, parameters2, code);
      materialProperties.program = program;
      material.program = program;
    }
    var programAttributes = program.getAttributes();
    if (material.morphTargets) {
      material.numSupportedMorphTargets = 0;
      for (var i2 = 0; i2 < _this.maxMorphTargets; i2++) {
        if (programAttributes["morphTarget" + i2] >= 0) {
          material.numSupportedMorphTargets++;
        }
      }
    }
    if (material.morphNormals) {
      material.numSupportedMorphNormals = 0;
      for (var i2 = 0; i2 < _this.maxMorphNormals; i2++) {
        if (programAttributes["morphNormal" + i2] >= 0) {
          material.numSupportedMorphNormals++;
        }
      }
    }
    var uniforms = materialProperties.shader.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      materialProperties.numClippingPlanes = _clipping.numPlanes;
      materialProperties.numIntersection = _clipping.numIntersection;
      uniforms.clippingPlanes = _clipping.uniform;
    }
    materialProperties.fog = fog;
    if (lightsHash === void 0) {
      materialProperties.lightsHash = lightsHash = {};
    }
    lightsHash.stateID = lightsStateHash.stateID;
    lightsHash.directionalLength = lightsStateHash.directionalLength;
    lightsHash.pointLength = lightsStateHash.pointLength;
    lightsHash.spotLength = lightsStateHash.spotLength;
    lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
    lightsHash.hemiLength = lightsStateHash.hemiLength;
    lightsHash.shadowsLength = lightsStateHash.shadowsLength;
    if (material.lights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.pointLights.value = lights.state.point;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.uniformsList = uniformsList;
  }
  function setProgram(camera, fog, material, object) {
    textures.resetTextureUnits();
    var materialProperties = properties.get(material);
    var lights = currentRenderState.state.lights;
    var lightsHash = materialProperties.lightsHash;
    var lightsStateHash = lights.state.hash;
    if (_clippingEnabled) {
      if (_localClippingEnabled || camera !== _currentCamera) {
        var useCache = camera === _currentCamera && material.id === _currentMaterialId;
        _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
      }
    }
    if (material.needsUpdate === false) {
      if (materialProperties.program === void 0) {
        material.needsUpdate = true;
      } else if (material.fog && materialProperties.fog !== fog) {
        material.needsUpdate = true;
      } else if (material.lights && (lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength)) {
        material.needsUpdate = true;
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
        material.needsUpdate = true;
      }
    }
    if (material.needsUpdate) {
      initMaterial(material, fog, object);
      material.needsUpdate = false;
    }
    var refreshProgram = false;
    var refreshMaterial = false;
    var refreshLights = false;
    var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.shader.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
      }
      if (_currentCamera !== camera) {
        _currentCamera = camera;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
        var uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
      }
    }
    if (material.skinning) {
      p_uniforms.setOptional(_gl, object, "bindMatrix");
      p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
      var skeleton = object.skeleton;
      if (skeleton) {
        var bones = skeleton.bones;
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === void 0) {
            var size = Math.sqrt(bones.length * 4);
            size = _Math.ceilPowerOfTwo(size);
            size = Math.max(size, 4);
            var boneMatrices = new Float32Array(size * size * 4);
            boneMatrices.set(skeleton.boneMatrices);
            var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
            boneTexture.needsUpdate = true;
            skeleton.boneMatrices = boneMatrices;
            skeleton.boneTexture = boneTexture;
            skeleton.boneTextureSize = size;
          }
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      p_uniforms.setValue(_gl, "toneMappingWhitePoint", _this.toneMappingWhitePoint);
      if (material.lights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog) {
        refreshUniformsFog(m_uniforms, fog);
      }
      if (material.isMeshBasicMaterial) {
        refreshUniformsCommon(m_uniforms, material);
      } else if (material.isMeshLambertMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsLambert(m_uniforms, material);
      } else if (material.isMeshPhongMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        if (material.isMeshToonMaterial) {
          refreshUniformsToon(m_uniforms, material);
        } else {
          refreshUniformsPhong(m_uniforms, material);
        }
      } else if (material.isMeshStandardMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        if (material.isMeshPhysicalMaterial) {
          refreshUniformsPhysical(m_uniforms, material);
        } else {
          refreshUniformsStandard(m_uniforms, material);
        }
      } else if (material.isMeshMatcapMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsMatcap(m_uniforms, material);
      } else if (material.isMeshDepthMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsDepth(m_uniforms, material);
      } else if (material.isMeshDistanceMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsDistance(m_uniforms, material);
      } else if (material.isMeshNormalMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsNormal(m_uniforms, material);
      } else if (material.isLineBasicMaterial) {
        refreshUniformsLine(m_uniforms, material);
        if (material.isLineDashedMaterial) {
          refreshUniformsDash(m_uniforms, material);
        }
      } else if (material.isPointsMaterial) {
        refreshUniformsPoints(m_uniforms, material);
      } else if (material.isSpriteMaterial) {
        refreshUniformsSprites(m_uniforms, material);
      } else if (material.isShadowMaterial) {
        m_uniforms.color.value.copy(material.color);
        m_uniforms.opacity.value = material.opacity;
      }
      if (m_uniforms.ltc_1 !== void 0)
        m_uniforms.ltc_1.value = UniformsLib.LTC_1;
      if (m_uniforms.ltc_2 !== void 0)
        m_uniforms.ltc_2.value = UniformsLib.LTC_2;
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
    return program;
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    if (material.envMap) {
      uniforms.envMap.value = material.envMap;
      uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;
      uniforms.maxMipLevel.value = properties.get(material.envMap).__maxMipLevel;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    var uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * _pixelRatio;
    uniforms.scale.value = _height * 0.5;
    uniforms.map.value = material.map;
    if (material.map !== null) {
      if (material.map.matrixAutoUpdate === true) {
        material.map.updateMatrix();
      }
      uniforms.uvTransform.value.copy(material.map.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    uniforms.map.value = material.map;
    if (material.map !== null) {
      if (material.map.matrixAutoUpdate === true) {
        material.map.updateMatrix();
      }
      uniforms.uvTransform.value.copy(material.map.matrix);
    }
  }
  function refreshUniformsFog(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsToon(uniforms, material) {
    refreshUniformsPhong(uniforms, material);
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material) {
    refreshUniformsStandard(uniforms, material);
    uniforms.reflectivity.value = material.reflectivity;
    uniforms.clearCoat.value = material.clearCoat;
    uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  this.setFramebuffer = function(value) {
    if (_framebuffer !== value)
      _gl.bindFramebuffer(36160, value);
    _framebuffer = value;
  };
  this.getActiveCubeFace = function() {
    return _currentActiveCubeFace;
  };
  this.getActiveMipMapLevel = function() {
    return _currentActiveMipmapLevel;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTarget = function(renderTarget, activeCubeFace, activeMipMapLevel) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipMapLevel;
    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
      textures.setupRenderTarget(renderTarget);
    }
    var framebuffer = _framebuffer;
    var isCube = false;
    if (renderTarget) {
      var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLRenderTargetCube) {
        framebuffer = __webglFramebuffer[activeCubeFace || 0];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
      _currentScissorTest = _scissorTest;
    }
    if (_currentFramebuffer !== framebuffer) {
      _gl.bindFramebuffer(36160, framebuffer);
      _currentFramebuffer = framebuffer;
    }
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      var textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(36160, 36064, 34069 + (activeCubeFace || 0), textureProperties.__webglTexture, activeMipMapLevel || 0);
    }
  };
  this.readRenderTargetPixels = function(renderTarget, x2, y, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    var framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLRenderTargetCube && activeCubeFaceIndex !== void 0) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      var restore = false;
      if (framebuffer !== _currentFramebuffer) {
        _gl.bindFramebuffer(36160, framebuffer);
        restore = true;
      }
      try {
        var texture = renderTarget.texture;
        var textureFormat = texture.format;
        var textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get("OES_texture_float") || extensions.get("WEBGL_color_buffer_float"))) && !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get("EXT_color_buffer_float") : extensions.get("EXT_color_buffer_half_float")))) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (_gl.checkFramebufferStatus(36160) === 36053) {
          if (x2 >= 0 && x2 <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
            _gl.readPixels(x2, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } else {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        }
      } finally {
        if (restore) {
          _gl.bindFramebuffer(36160, _currentFramebuffer);
        }
      }
    }
  };
  this.copyFramebufferToTexture = function(position, texture, level) {
    var width = texture.image.width;
    var height = texture.image.height;
    var glFormat = utils.convert(texture.format);
    textures.setTexture2D(texture, 0);
    _gl.copyTexImage2D(3553, level || 0, glFormat, position.x, position.y, width, height, 0);
  };
  this.copyTextureToTexture = function(position, srcTexture, dstTexture, level) {
    var width = srcTexture.image.width;
    var height = srcTexture.image.height;
    var glFormat = utils.convert(dstTexture.format);
    var glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      _gl.texSubImage2D(3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image);
    }
  };
}
function FogExp2(color, density) {
  this.name = "";
  this.color = new Color(color);
  this.density = density !== void 0 ? density : 25e-5;
}
Object.assign(FogExp2.prototype, {
  isFogExp2: true,
  clone: function() {
    return new FogExp2(this.color, this.density);
  },
  toJSON: function() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
});
function Fog(color, near, far) {
  this.name = "";
  this.color = new Color(color);
  this.near = near !== void 0 ? near : 1;
  this.far = far !== void 0 ? far : 1e3;
}
Object.assign(Fog.prototype, {
  isFog: true,
  clone: function() {
    return new Fog(this.color, this.near, this.far);
  },
  toJSON: function() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
});
function Scene() {
  Object3D.call(this);
  this.type = "Scene";
  this.background = null;
  this.fog = null;
  this.overrideMaterial = null;
  this.autoUpdate = true;
}
Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Scene,
  isScene: true,
  copy: function(source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    if (source.background !== null)
      this.background = source.background.clone();
    if (source.fog !== null)
      this.fog = source.fog.clone();
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  },
  toJSON: function(meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    if (this.background !== null)
      data.object.background = this.background.toJSON(meta);
    if (this.fog !== null)
      data.object.fog = this.fog.toJSON();
    return data;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function InterleavedBuffer(array, stride) {
  this.array = array;
  this.stride = stride;
  this.count = array !== void 0 ? array.length / stride : 0;
  this.dynamic = false;
  this.updateRange = { offset: 0, count: -1 };
  this.version = 0;
}
Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(InterleavedBuffer.prototype, {
  isInterleavedBuffer: true,
  onUploadCallback: function() {
  },
  setArray: function(array) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.count = array !== void 0 ? array.length / this.stride : 0;
    this.array = array;
    return this;
  },
  setDynamic: function(value) {
    this.dynamic = value;
    return this;
  },
  copy: function(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.dynamic = source.dynamic;
    return this;
  },
  copyAt: function(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (var i2 = 0, l2 = this.stride; i2 < l2; i2++) {
      this.array[index1 + i2] = attribute.array[index2 + i2];
    }
    return this;
  },
  set: function(value, offset2) {
    if (offset2 === void 0)
      offset2 = 0;
    this.array.set(value, offset2);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  }
});
function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset2, normalized) {
  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset2;
  this.normalized = normalized === true;
}
Object.defineProperties(InterleavedBufferAttribute.prototype, {
  count: {
    get: function() {
      return this.data.count;
    }
  },
  array: {
    get: function() {
      return this.data.array;
    }
  }
});
Object.assign(InterleavedBufferAttribute.prototype, {
  isInterleavedBufferAttribute: true,
  setX: function(index2, x2) {
    this.data.array[index2 * this.data.stride + this.offset] = x2;
    return this;
  },
  setY: function(index2, y) {
    this.data.array[index2 * this.data.stride + this.offset + 1] = y;
    return this;
  },
  setZ: function(index2, z2) {
    this.data.array[index2 * this.data.stride + this.offset + 2] = z2;
    return this;
  },
  setW: function(index2, w2) {
    this.data.array[index2 * this.data.stride + this.offset + 3] = w2;
    return this;
  },
  getX: function(index2) {
    return this.data.array[index2 * this.data.stride + this.offset];
  },
  getY: function(index2) {
    return this.data.array[index2 * this.data.stride + this.offset + 1];
  },
  getZ: function(index2) {
    return this.data.array[index2 * this.data.stride + this.offset + 2];
  },
  getW: function(index2) {
    return this.data.array[index2 * this.data.stride + this.offset + 3];
  },
  setXY: function(index2, x2, y) {
    index2 = index2 * this.data.stride + this.offset;
    this.data.array[index2 + 0] = x2;
    this.data.array[index2 + 1] = y;
    return this;
  },
  setXYZ: function(index2, x2, y, z2) {
    index2 = index2 * this.data.stride + this.offset;
    this.data.array[index2 + 0] = x2;
    this.data.array[index2 + 1] = y;
    this.data.array[index2 + 2] = z2;
    return this;
  },
  setXYZW: function(index2, x2, y, z2, w2) {
    index2 = index2 * this.data.stride + this.offset;
    this.data.array[index2 + 0] = x2;
    this.data.array[index2 + 1] = y;
    this.data.array[index2 + 2] = z2;
    this.data.array[index2 + 3] = w2;
    return this;
  }
});
function SpriteMaterial(parameters) {
  Material.call(this);
  this.type = "SpriteMaterial";
  this.color = new Color(16777215);
  this.map = null;
  this.rotation = 0;
  this.sizeAttenuation = true;
  this.lights = false;
  this.transparent = true;
  this.setValues(parameters);
}
SpriteMaterial.prototype = Object.create(Material.prototype);
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;
SpriteMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.rotation = source.rotation;
  this.sizeAttenuation = source.sizeAttenuation;
  return this;
};
var geometry;
function Sprite(material) {
  Object3D.call(this);
  this.type = "Sprite";
  if (geometry === void 0) {
    geometry = new BufferGeometry();
    var float32Array = new Float32Array([
      -0.5,
      -0.5,
      0,
      0,
      0,
      0.5,
      -0.5,
      0,
      1,
      0,
      0.5,
      0.5,
      0,
      1,
      1,
      -0.5,
      0.5,
      0,
      0,
      1
    ]);
    var interleavedBuffer = new InterleavedBuffer(float32Array, 5);
    geometry.setIndex([0, 1, 2, 0, 2, 3]);
    geometry.addAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
    geometry.addAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
  }
  this.geometry = geometry;
  this.material = material !== void 0 ? material : new SpriteMaterial();
  this.center = new Vector2(0.5, 0.5);
}
Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Sprite,
  isSprite: true,
  raycast: function() {
    var intersectPoint = new Vector3();
    var worldScale = new Vector3();
    var mvPosition = new Vector3();
    var alignedPosition = new Vector2();
    var rotatedPosition = new Vector2();
    var viewWorldMatrix = new Matrix4();
    var vA = new Vector3();
    var vB = new Vector3();
    var vC = new Vector3();
    var uvA = new Vector2();
    var uvB = new Vector2();
    var uvC = new Vector2();
    function transformVertex(vertexPosition, mvPosition2, center, scale2, sin, cos) {
      alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale2);
      if (sin !== void 0) {
        rotatedPosition.x = cos * alignedPosition.x - sin * alignedPosition.y;
        rotatedPosition.y = sin * alignedPosition.x + cos * alignedPosition.y;
      } else {
        rotatedPosition.copy(alignedPosition);
      }
      vertexPosition.copy(mvPosition2);
      vertexPosition.x += rotatedPosition.x;
      vertexPosition.y += rotatedPosition.y;
      vertexPosition.applyMatrix4(viewWorldMatrix);
    }
    return function raycast(raycaster, intersects2) {
      worldScale.setFromMatrixScale(this.matrixWorld);
      viewWorldMatrix.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld);
      mvPosition.setFromMatrixPosition(this.modelViewMatrix);
      var rotation = this.material.rotation;
      var sin, cos;
      if (rotation !== 0) {
        cos = Math.cos(rotation);
        sin = Math.sin(rotation);
      }
      var center = this.center;
      transformVertex(vA.set(-0.5, -0.5, 0), mvPosition, center, worldScale, sin, cos);
      transformVertex(vB.set(0.5, -0.5, 0), mvPosition, center, worldScale, sin, cos);
      transformVertex(vC.set(0.5, 0.5, 0), mvPosition, center, worldScale, sin, cos);
      uvA.set(0, 0);
      uvB.set(1, 0);
      uvC.set(1, 1);
      var intersect = raycaster.ray.intersectTriangle(vA, vB, vC, false, intersectPoint);
      if (intersect === null) {
        transformVertex(vB.set(-0.5, 0.5, 0), mvPosition, center, worldScale, sin, cos);
        uvB.set(0, 1);
        intersect = raycaster.ray.intersectTriangle(vA, vC, vB, false, intersectPoint);
        if (intersect === null) {
          return;
        }
      }
      var distance = raycaster.ray.origin.distanceTo(intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far)
        return;
      intersects2.push({
        distance,
        point: intersectPoint.clone(),
        uv: Triangle.getUV(intersectPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2()),
        face: null,
        object: this
      });
    };
  }(),
  clone: function() {
    return new this.constructor(this.material).copy(this);
  },
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    if (source.center !== void 0)
      this.center.copy(source.center);
    return this;
  }
});
function LOD() {
  Object3D.call(this);
  this.type = "LOD";
  Object.defineProperties(this, {
    levels: {
      enumerable: true,
      value: []
    }
  });
}
LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: LOD,
  isLOD: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source, false);
    var levels = source.levels;
    for (var i2 = 0, l2 = levels.length; i2 < l2; i2++) {
      var level = levels[i2];
      this.addLevel(level.object.clone(), level.distance);
    }
    return this;
  },
  addLevel: function(object, distance) {
    if (distance === void 0)
      distance = 0;
    distance = Math.abs(distance);
    var levels = this.levels;
    for (var l2 = 0; l2 < levels.length; l2++) {
      if (distance < levels[l2].distance) {
        break;
      }
    }
    levels.splice(l2, 0, { distance, object });
    this.add(object);
    return this;
  },
  getObjectForDistance: function(distance) {
    var levels = this.levels;
    for (var i2 = 1, l2 = levels.length; i2 < l2; i2++) {
      if (distance < levels[i2].distance) {
        break;
      }
    }
    return levels[i2 - 1].object;
  },
  raycast: function() {
    var matrixPosition = new Vector3();
    return function raycast(raycaster, intersects2) {
      matrixPosition.setFromMatrixPosition(this.matrixWorld);
      var distance = raycaster.ray.origin.distanceTo(matrixPosition);
      this.getObjectForDistance(distance).raycast(raycaster, intersects2);
    };
  }(),
  update: function() {
    var v1 = new Vector3();
    var v2 = new Vector3();
    return function update3(camera) {
      var levels = this.levels;
      if (levels.length > 1) {
        v1.setFromMatrixPosition(camera.matrixWorld);
        v2.setFromMatrixPosition(this.matrixWorld);
        var distance = v1.distanceTo(v2);
        levels[0].object.visible = true;
        for (var i2 = 1, l2 = levels.length; i2 < l2; i2++) {
          if (distance >= levels[i2].distance) {
            levels[i2 - 1].object.visible = false;
            levels[i2].object.visible = true;
          } else {
            break;
          }
        }
        for (; i2 < l2; i2++) {
          levels[i2].object.visible = false;
        }
      }
    };
  }(),
  toJSON: function(meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.levels = [];
    var levels = this.levels;
    for (var i2 = 0, l2 = levels.length; i2 < l2; i2++) {
      var level = levels[i2];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance
      });
    }
    return data;
  }
});
function SkinnedMesh(geometry2, material) {
  if (geometry2 && geometry2.isGeometry) {
    console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
  }
  Mesh.call(this, geometry2, material);
  this.type = "SkinnedMesh";
  this.bindMode = "attached";
  this.bindMatrix = new Matrix4();
  this.bindMatrixInverse = new Matrix4();
}
SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: SkinnedMesh,
  isSkinnedMesh: true,
  bind: function(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.getInverse(bindMatrix);
  },
  pose: function() {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function() {
    var vector = new Vector4();
    var skinWeight = this.geometry.attributes.skinWeight;
    for (var i2 = 0, l2 = skinWeight.count; i2 < l2; i2++) {
      vector.x = skinWeight.getX(i2);
      vector.y = skinWeight.getY(i2);
      vector.z = skinWeight.getZ(i2);
      vector.w = skinWeight.getW(i2);
      var scale2 = 1 / vector.manhattanLength();
      if (scale2 !== Infinity) {
        vector.multiplyScalar(scale2);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
    }
  },
  updateMatrixWorld: function(force) {
    Mesh.prototype.updateMatrixWorld.call(this, force);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.getInverse(this.matrixWorld);
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.getInverse(this.bindMatrix);
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  },
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function Skeleton(bones, boneInverses) {
  bones = bones || [];
  this.bones = bones.slice(0);
  this.boneMatrices = new Float32Array(this.bones.length * 16);
  if (boneInverses === void 0) {
    this.calculateInverses();
  } else {
    if (this.bones.length === boneInverses.length) {
      this.boneInverses = boneInverses.slice(0);
    } else {
      console.warn("THREE.Skeleton boneInverses is the wrong length.");
      this.boneInverses = [];
      for (var i2 = 0, il = this.bones.length; i2 < il; i2++) {
        this.boneInverses.push(new Matrix4());
      }
    }
  }
}
Object.assign(Skeleton.prototype, {
  calculateInverses: function() {
    this.boneInverses = [];
    for (var i2 = 0, il = this.bones.length; i2 < il; i2++) {
      var inverse = new Matrix4();
      if (this.bones[i2]) {
        inverse.getInverse(this.bones[i2].matrixWorld);
      }
      this.boneInverses.push(inverse);
    }
  },
  pose: function() {
    var bone, i2, il;
    for (i2 = 0, il = this.bones.length; i2 < il; i2++) {
      bone = this.bones[i2];
      if (bone) {
        bone.matrixWorld.getInverse(this.boneInverses[i2]);
      }
    }
    for (i2 = 0, il = this.bones.length; i2 < il; i2++) {
      bone = this.bones[i2];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.getInverse(bone.parent.matrixWorld);
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  },
  update: function() {
    var offsetMatrix = new Matrix4();
    var identityMatrix = new Matrix4();
    return function update3() {
      var bones = this.bones;
      var boneInverses = this.boneInverses;
      var boneMatrices = this.boneMatrices;
      var boneTexture = this.boneTexture;
      for (var i2 = 0, il = bones.length; i2 < il; i2++) {
        var matrix = bones[i2] ? bones[i2].matrixWorld : identityMatrix;
        offsetMatrix.multiplyMatrices(matrix, boneInverses[i2]);
        offsetMatrix.toArray(boneMatrices, i2 * 16);
      }
      if (boneTexture !== void 0) {
        boneTexture.needsUpdate = true;
      }
    };
  }(),
  clone: function() {
    return new Skeleton(this.bones, this.boneInverses);
  },
  getBoneByName: function(name) {
    for (var i2 = 0, il = this.bones.length; i2 < il; i2++) {
      var bone = this.bones[i2];
      if (bone.name === name) {
        return bone;
      }
    }
    return void 0;
  }
});
function Bone() {
  Object3D.call(this);
  this.type = "Bone";
}
Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Bone,
  isBone: true
});
function LineBasicMaterial(parameters) {
  Material.call(this);
  this.type = "LineBasicMaterial";
  this.color = new Color(16777215);
  this.linewidth = 1;
  this.linecap = "round";
  this.linejoin = "round";
  this.lights = false;
  this.setValues(parameters);
}
LineBasicMaterial.prototype = Object.create(Material.prototype);
LineBasicMaterial.prototype.constructor = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = true;
LineBasicMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.linewidth = source.linewidth;
  this.linecap = source.linecap;
  this.linejoin = source.linejoin;
  return this;
};
function Line(geometry2, material, mode) {
  if (mode === 1) {
    console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");
  }
  Object3D.call(this);
  this.type = "Line";
  this.geometry = geometry2 !== void 0 ? geometry2 : new BufferGeometry();
  this.material = material !== void 0 ? material : new LineBasicMaterial({ color: Math.random() * 16777215 });
}
Line.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Line,
  isLine: true,
  computeLineDistances: function() {
    var start = new Vector3();
    var end = new Vector3();
    return function computeLineDistances() {
      var geometry2 = this.geometry;
      if (geometry2.isBufferGeometry) {
        if (geometry2.index === null) {
          var positionAttribute = geometry2.attributes.position;
          var lineDistances = [0];
          for (var i2 = 1, l2 = positionAttribute.count; i2 < l2; i2++) {
            start.fromBufferAttribute(positionAttribute, i2 - 1);
            end.fromBufferAttribute(positionAttribute, i2);
            lineDistances[i2] = lineDistances[i2 - 1];
            lineDistances[i2] += start.distanceTo(end);
          }
          geometry2.addAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        }
      } else if (geometry2.isGeometry) {
        var vertices = geometry2.vertices;
        var lineDistances = geometry2.lineDistances;
        lineDistances[0] = 0;
        for (var i2 = 1, l2 = vertices.length; i2 < l2; i2++) {
          lineDistances[i2] = lineDistances[i2 - 1];
          lineDistances[i2] += vertices[i2 - 1].distanceTo(vertices[i2]);
        }
      }
      return this;
    };
  }(),
  raycast: function() {
    var inverseMatrix = new Matrix4();
    var ray = new Ray();
    var sphere = new Sphere();
    return function raycast(raycaster, intersects2) {
      var precision = raycaster.linePrecision;
      var geometry2 = this.geometry;
      var matrixWorld = this.matrixWorld;
      if (geometry2.boundingSphere === null)
        geometry2.computeBoundingSphere();
      sphere.copy(geometry2.boundingSphere);
      sphere.applyMatrix4(matrixWorld);
      sphere.radius += precision;
      if (raycaster.ray.intersectsSphere(sphere) === false)
        return;
      inverseMatrix.getInverse(matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      var localPrecision = precision / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      var localPrecisionSq = localPrecision * localPrecision;
      var vStart = new Vector3();
      var vEnd = new Vector3();
      var interSegment = new Vector3();
      var interRay = new Vector3();
      var step = this && this.isLineSegments ? 2 : 1;
      if (geometry2.isBufferGeometry) {
        var index2 = geometry2.index;
        var attributes = geometry2.attributes;
        var positions = attributes.position.array;
        if (index2 !== null) {
          var indices = index2.array;
          for (var i2 = 0, l2 = indices.length - 1; i2 < l2; i2 += step) {
            var a2 = indices[i2];
            var b2 = indices[i2 + 1];
            vStart.fromArray(positions, a2 * 3);
            vEnd.fromArray(positions, b2 * 3);
            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > localPrecisionSq)
              continue;
            interRay.applyMatrix4(this.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects2.push({
              distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i2,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        } else {
          for (var i2 = 0, l2 = positions.length / 3 - 1; i2 < l2; i2 += step) {
            vStart.fromArray(positions, 3 * i2);
            vEnd.fromArray(positions, 3 * i2 + 3);
            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > localPrecisionSq)
              continue;
            interRay.applyMatrix4(this.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects2.push({
              distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i2,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      } else if (geometry2.isGeometry) {
        var vertices = geometry2.vertices;
        var nbVertices = vertices.length;
        for (var i2 = 0; i2 < nbVertices - 1; i2 += step) {
          var distSq = ray.distanceSqToSegment(vertices[i2], vertices[i2 + 1], interRay, interSegment);
          if (distSq > localPrecisionSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          var distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects2.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i2,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    };
  }(),
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function LineSegments(geometry2, material) {
  Line.call(this, geometry2, material);
  this.type = "LineSegments";
}
LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineSegments,
  isLineSegments: true,
  computeLineDistances: function() {
    var start = new Vector3();
    var end = new Vector3();
    return function computeLineDistances() {
      var geometry2 = this.geometry;
      if (geometry2.isBufferGeometry) {
        if (geometry2.index === null) {
          var positionAttribute = geometry2.attributes.position;
          var lineDistances = [];
          for (var i2 = 0, l2 = positionAttribute.count; i2 < l2; i2 += 2) {
            start.fromBufferAttribute(positionAttribute, i2);
            end.fromBufferAttribute(positionAttribute, i2 + 1);
            lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
            lineDistances[i2 + 1] = lineDistances[i2] + start.distanceTo(end);
          }
          geometry2.addAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        }
      } else if (geometry2.isGeometry) {
        var vertices = geometry2.vertices;
        var lineDistances = geometry2.lineDistances;
        for (var i2 = 0, l2 = vertices.length; i2 < l2; i2 += 2) {
          start.copy(vertices[i2]);
          end.copy(vertices[i2 + 1]);
          lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
          lineDistances[i2 + 1] = lineDistances[i2] + start.distanceTo(end);
        }
      }
      return this;
    };
  }()
});
function LineLoop(geometry2, material) {
  Line.call(this, geometry2, material);
  this.type = "LineLoop";
}
LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineLoop,
  isLineLoop: true
});
function PointsMaterial(parameters) {
  Material.call(this);
  this.type = "PointsMaterial";
  this.color = new Color(16777215);
  this.map = null;
  this.size = 1;
  this.sizeAttenuation = true;
  this.morphTargets = false;
  this.lights = false;
  this.setValues(parameters);
}
PointsMaterial.prototype = Object.create(Material.prototype);
PointsMaterial.prototype.constructor = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;
PointsMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.size = source.size;
  this.sizeAttenuation = source.sizeAttenuation;
  this.morphTargets = source.morphTargets;
  return this;
};
function Points(geometry2, material) {
  Object3D.call(this);
  this.type = "Points";
  this.geometry = geometry2 !== void 0 ? geometry2 : new BufferGeometry();
  this.material = material !== void 0 ? material : new PointsMaterial({ color: Math.random() * 16777215 });
}
Points.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Points,
  isPoints: true,
  raycast: function() {
    var inverseMatrix = new Matrix4();
    var ray = new Ray();
    var sphere = new Sphere();
    return function raycast(raycaster, intersects2) {
      var object = this;
      var geometry2 = this.geometry;
      var matrixWorld = this.matrixWorld;
      var threshold = raycaster.params.Points.threshold;
      if (geometry2.boundingSphere === null)
        geometry2.computeBoundingSphere();
      sphere.copy(geometry2.boundingSphere);
      sphere.applyMatrix4(matrixWorld);
      sphere.radius += threshold;
      if (raycaster.ray.intersectsSphere(sphere) === false)
        return;
      inverseMatrix.getInverse(matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      var localThresholdSq = localThreshold * localThreshold;
      var position = new Vector3();
      var intersectPoint = new Vector3();
      function testPoint(point, index3) {
        var rayPointDistanceSq = ray.distanceSqToPoint(point);
        if (rayPointDistanceSq < localThresholdSq) {
          ray.closestPointToPoint(point, intersectPoint);
          intersectPoint.applyMatrix4(matrixWorld);
          var distance = raycaster.ray.origin.distanceTo(intersectPoint);
          if (distance < raycaster.near || distance > raycaster.far)
            return;
          intersects2.push({
            distance,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint.clone(),
            index: index3,
            face: null,
            object
          });
        }
      }
      if (geometry2.isBufferGeometry) {
        var index2 = geometry2.index;
        var attributes = geometry2.attributes;
        var positions = attributes.position.array;
        if (index2 !== null) {
          var indices = index2.array;
          for (var i2 = 0, il = indices.length; i2 < il; i2++) {
            var a2 = indices[i2];
            position.fromArray(positions, a2 * 3);
            testPoint(position, a2);
          }
        } else {
          for (var i2 = 0, l2 = positions.length / 3; i2 < l2; i2++) {
            position.fromArray(positions, i2 * 3);
            testPoint(position, i2);
          }
        }
      } else {
        var vertices = geometry2.vertices;
        for (var i2 = 0, l2 = vertices.length; i2 < l2; i2++) {
          testPoint(vertices[i2], i2);
        }
      }
    };
  }(),
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.format = format !== void 0 ? format : RGBFormat;
  this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
  this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
  this.generateMipmaps = false;
}
VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
  constructor: VideoTexture,
  isVideoTexture: true,
  update: function() {
    var video = this.image;
    if (video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
});
function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.image = { width, height };
  this.mipmaps = mipmaps;
  this.flipY = false;
  this.generateMipmaps = false;
}
CompressedTexture.prototype = Object.create(Texture.prototype);
CompressedTexture.prototype.constructor = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = true;
function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.needsUpdate = true;
}
CanvasTexture.prototype = Object.create(Texture.prototype);
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;
function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
  format = format !== void 0 ? format : DepthFormat;
  if (format !== DepthFormat && format !== DepthStencilFormat) {
    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
  }
  if (type === void 0 && format === DepthFormat)
    type = UnsignedShortType;
  if (type === void 0 && format === DepthStencilFormat)
    type = UnsignedInt248Type;
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.image = { width, height };
  this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
  this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
  this.flipY = false;
  this.generateMipmaps = false;
}
DepthTexture.prototype = Object.create(Texture.prototype);
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;
function WireframeGeometry(geometry2) {
  BufferGeometry.call(this);
  this.type = "WireframeGeometry";
  var vertices = [];
  var i2, j, l2, o2, ol;
  var edge = [0, 0], edges = {}, e2, edge1, edge2;
  var key, keys = ["a", "b", "c"];
  var vertex;
  if (geometry2 && geometry2.isGeometry) {
    var faces = geometry2.faces;
    for (i2 = 0, l2 = faces.length; i2 < l2; i2++) {
      var face = faces[i2];
      for (j = 0; j < 3; j++) {
        edge1 = face[keys[j]];
        edge2 = face[keys[(j + 1) % 3]];
        edge[0] = Math.min(edge1, edge2);
        edge[1] = Math.max(edge1, edge2);
        key = edge[0] + "," + edge[1];
        if (edges[key] === void 0) {
          edges[key] = { index1: edge[0], index2: edge[1] };
        }
      }
    }
    for (key in edges) {
      e2 = edges[key];
      vertex = geometry2.vertices[e2.index1];
      vertices.push(vertex.x, vertex.y, vertex.z);
      vertex = geometry2.vertices[e2.index2];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  } else if (geometry2 && geometry2.isBufferGeometry) {
    var position, indices, groups;
    var group, start, count2;
    var index1, index2;
    vertex = new Vector3();
    if (geometry2.index !== null) {
      position = geometry2.attributes.position;
      indices = geometry2.index;
      groups = geometry2.groups;
      if (groups.length === 0) {
        groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
      }
      for (o2 = 0, ol = groups.length; o2 < ol; ++o2) {
        group = groups[o2];
        start = group.start;
        count2 = group.count;
        for (i2 = start, l2 = start + count2; i2 < l2; i2 += 3) {
          for (j = 0; j < 3; j++) {
            edge1 = indices.getX(i2 + j);
            edge2 = indices.getX(i2 + (j + 1) % 3);
            edge[0] = Math.min(edge1, edge2);
            edge[1] = Math.max(edge1, edge2);
            key = edge[0] + "," + edge[1];
            if (edges[key] === void 0) {
              edges[key] = { index1: edge[0], index2: edge[1] };
            }
          }
        }
      }
      for (key in edges) {
        e2 = edges[key];
        vertex.fromBufferAttribute(position, e2.index1);
        vertices.push(vertex.x, vertex.y, vertex.z);
        vertex.fromBufferAttribute(position, e2.index2);
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    } else {
      position = geometry2.attributes.position;
      for (i2 = 0, l2 = position.count / 3; i2 < l2; i2++) {
        for (j = 0; j < 3; j++) {
          index1 = 3 * i2 + j;
          vertex.fromBufferAttribute(position, index1);
          vertices.push(vertex.x, vertex.y, vertex.z);
          index2 = 3 * i2 + (j + 1) % 3;
          vertex.fromBufferAttribute(position, index2);
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      }
    }
  }
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
}
WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
WireframeGeometry.prototype.constructor = WireframeGeometry;
function ParametricGeometry(func, slices, stacks) {
  Geometry.call(this);
  this.type = "ParametricGeometry";
  this.parameters = {
    func,
    slices,
    stacks
  };
  this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
  this.mergeVertices();
}
ParametricGeometry.prototype = Object.create(Geometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry;
function ParametricBufferGeometry(func, slices, stacks) {
  BufferGeometry.call(this);
  this.type = "ParametricBufferGeometry";
  this.parameters = {
    func,
    slices,
    stacks
  };
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var EPS = 1e-5;
  var normal = new Vector3();
  var p0 = new Vector3(), p1 = new Vector3();
  var pu = new Vector3(), pv = new Vector3();
  var i2, j;
  if (func.length < 3) {
    console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
  }
  var sliceCount = slices + 1;
  for (i2 = 0; i2 <= stacks; i2++) {
    var v2 = i2 / stacks;
    for (j = 0; j <= slices; j++) {
      var u2 = j / slices;
      func(u2, v2, p0);
      vertices.push(p0.x, p0.y, p0.z);
      if (u2 - EPS >= 0) {
        func(u2 - EPS, v2, p1);
        pu.subVectors(p0, p1);
      } else {
        func(u2 + EPS, v2, p1);
        pu.subVectors(p1, p0);
      }
      if (v2 - EPS >= 0) {
        func(u2, v2 - EPS, p1);
        pv.subVectors(p0, p1);
      } else {
        func(u2, v2 + EPS, p1);
        pv.subVectors(p1, p0);
      }
      normal.crossVectors(pu, pv).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u2, v2);
    }
  }
  for (i2 = 0; i2 < stacks; i2++) {
    for (j = 0; j < slices; j++) {
      var a2 = i2 * sliceCount + j;
      var b2 = i2 * sliceCount + j + 1;
      var c2 = (i2 + 1) * sliceCount + j + 1;
      var d2 = (i2 + 1) * sliceCount + j;
      indices.push(a2, b2, d2);
      indices.push(b2, c2, d2);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
function PolyhedronGeometry(vertices, indices, radius, detail) {
  Geometry.call(this);
  this.type = "PolyhedronGeometry";
  this.parameters = {
    vertices,
    indices,
    radius,
    detail
  };
  this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
  this.mergeVertices();
}
PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
  BufferGeometry.call(this);
  this.type = "PolyhedronBufferGeometry";
  this.parameters = {
    vertices,
    indices,
    radius,
    detail
  };
  radius = radius || 1;
  detail = detail || 0;
  var vertexBuffer = [];
  var uvBuffer = [];
  subdivide(detail);
  appplyRadius(radius);
  generateUVs();
  this.addAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
  this.addAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
  if (detail === 0) {
    this.computeVertexNormals();
  } else {
    this.normalizeNormals();
  }
  function subdivide(detail2) {
    var a2 = new Vector3();
    var b2 = new Vector3();
    var c2 = new Vector3();
    for (var i2 = 0; i2 < indices.length; i2 += 3) {
      getVertexByIndex(indices[i2 + 0], a2);
      getVertexByIndex(indices[i2 + 1], b2);
      getVertexByIndex(indices[i2 + 2], c2);
      subdivideFace(a2, b2, c2, detail2);
    }
  }
  function subdivideFace(a2, b2, c2, detail2) {
    var cols = Math.pow(2, detail2);
    var v2 = [];
    var i2, j;
    for (i2 = 0; i2 <= cols; i2++) {
      v2[i2] = [];
      var aj = a2.clone().lerp(c2, i2 / cols);
      var bj = b2.clone().lerp(c2, i2 / cols);
      var rows = cols - i2;
      for (j = 0; j <= rows; j++) {
        if (j === 0 && i2 === cols) {
          v2[i2][j] = aj;
        } else {
          v2[i2][j] = aj.clone().lerp(bj, j / rows);
        }
      }
    }
    for (i2 = 0; i2 < cols; i2++) {
      for (j = 0; j < 2 * (cols - i2) - 1; j++) {
        var k2 = Math.floor(j / 2);
        if (j % 2 === 0) {
          pushVertex(v2[i2][k2 + 1]);
          pushVertex(v2[i2 + 1][k2]);
          pushVertex(v2[i2][k2]);
        } else {
          pushVertex(v2[i2][k2 + 1]);
          pushVertex(v2[i2 + 1][k2 + 1]);
          pushVertex(v2[i2 + 1][k2]);
        }
      }
    }
  }
  function appplyRadius(radius2) {
    var vertex = new Vector3();
    for (var i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
      vertex.x = vertexBuffer[i2 + 0];
      vertex.y = vertexBuffer[i2 + 1];
      vertex.z = vertexBuffer[i2 + 2];
      vertex.normalize().multiplyScalar(radius2);
      vertexBuffer[i2 + 0] = vertex.x;
      vertexBuffer[i2 + 1] = vertex.y;
      vertexBuffer[i2 + 2] = vertex.z;
    }
  }
  function generateUVs() {
    var vertex = new Vector3();
    for (var i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
      vertex.x = vertexBuffer[i2 + 0];
      vertex.y = vertexBuffer[i2 + 1];
      vertex.z = vertexBuffer[i2 + 2];
      var u2 = azimuth(vertex) / 2 / Math.PI + 0.5;
      var v2 = inclination(vertex) / Math.PI + 0.5;
      uvBuffer.push(u2, 1 - v2);
    }
    correctUVs();
    correctSeam();
  }
  function correctSeam() {
    for (var i2 = 0; i2 < uvBuffer.length; i2 += 6) {
      var x0 = uvBuffer[i2 + 0];
      var x1 = uvBuffer[i2 + 2];
      var x2 = uvBuffer[i2 + 4];
      var max = Math.max(x0, x1, x2);
      var min = Math.min(x0, x1, x2);
      if (max > 0.9 && min < 0.1) {
        if (x0 < 0.2)
          uvBuffer[i2 + 0] += 1;
        if (x1 < 0.2)
          uvBuffer[i2 + 2] += 1;
        if (x2 < 0.2)
          uvBuffer[i2 + 4] += 1;
      }
    }
  }
  function pushVertex(vertex) {
    vertexBuffer.push(vertex.x, vertex.y, vertex.z);
  }
  function getVertexByIndex(index2, vertex) {
    var stride = index2 * 3;
    vertex.x = vertices[stride + 0];
    vertex.y = vertices[stride + 1];
    vertex.z = vertices[stride + 2];
  }
  function correctUVs() {
    var a2 = new Vector3();
    var b2 = new Vector3();
    var c2 = new Vector3();
    var centroid = new Vector3();
    var uvA = new Vector2();
    var uvB = new Vector2();
    var uvC = new Vector2();
    for (var i2 = 0, j = 0; i2 < vertexBuffer.length; i2 += 9, j += 6) {
      a2.set(vertexBuffer[i2 + 0], vertexBuffer[i2 + 1], vertexBuffer[i2 + 2]);
      b2.set(vertexBuffer[i2 + 3], vertexBuffer[i2 + 4], vertexBuffer[i2 + 5]);
      c2.set(vertexBuffer[i2 + 6], vertexBuffer[i2 + 7], vertexBuffer[i2 + 8]);
      uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
      uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
      uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
      centroid.copy(a2).add(b2).add(c2).divideScalar(3);
      var azi = azimuth(centroid);
      correctUV(uvA, j + 0, a2, azi);
      correctUV(uvB, j + 2, b2, azi);
      correctUV(uvC, j + 4, c2, azi);
    }
  }
  function correctUV(uv, stride, vector, azimuth2) {
    if (azimuth2 < 0 && uv.x === 1) {
      uvBuffer[stride] = uv.x - 1;
    }
    if (vector.x === 0 && vector.z === 0) {
      uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
    }
  }
  function azimuth(vector) {
    return Math.atan2(vector.z, -vector.x);
  }
  function inclination(vector) {
    return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
  }
}
PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
function TetrahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = "TetrahedronGeometry";
  this.parameters = {
    radius,
    detail
  };
  this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}
TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
function TetrahedronBufferGeometry(radius, detail) {
  var vertices = [
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    1,
    -1,
    -1
  ];
  var indices = [
    2,
    1,
    0,
    0,
    3,
    2,
    1,
    3,
    0,
    2,
    3,
    1
  ];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = "TetrahedronBufferGeometry";
  this.parameters = {
    radius,
    detail
  };
}
TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
function OctahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = "OctahedronGeometry";
  this.parameters = {
    radius,
    detail
  };
  this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}
OctahedronGeometry.prototype = Object.create(Geometry.prototype);
OctahedronGeometry.prototype.constructor = OctahedronGeometry;
function OctahedronBufferGeometry(radius, detail) {
  var vertices = [
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1
  ];
  var indices = [
    0,
    2,
    4,
    0,
    4,
    3,
    0,
    3,
    5,
    0,
    5,
    2,
    1,
    2,
    5,
    1,
    5,
    3,
    1,
    3,
    4,
    1,
    4,
    2
  ];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = "OctahedronBufferGeometry";
  this.parameters = {
    radius,
    detail
  };
}
OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
function IcosahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = "IcosahedronGeometry";
  this.parameters = {
    radius,
    detail
  };
  this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}
IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
function IcosahedronBufferGeometry(radius, detail) {
  var t2 = (1 + Math.sqrt(5)) / 2;
  var vertices = [
    -1,
    t2,
    0,
    1,
    t2,
    0,
    -1,
    -t2,
    0,
    1,
    -t2,
    0,
    0,
    -1,
    t2,
    0,
    1,
    t2,
    0,
    -1,
    -t2,
    0,
    1,
    -t2,
    t2,
    0,
    -1,
    t2,
    0,
    1,
    -t2,
    0,
    -1,
    -t2,
    0,
    1
  ];
  var indices = [
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    0,
    10,
    11,
    1,
    5,
    9,
    5,
    11,
    4,
    11,
    10,
    2,
    10,
    7,
    6,
    7,
    1,
    8,
    3,
    9,
    4,
    3,
    4,
    2,
    3,
    2,
    6,
    3,
    6,
    8,
    3,
    8,
    9,
    4,
    9,
    5,
    2,
    4,
    11,
    6,
    2,
    10,
    8,
    6,
    7,
    9,
    8,
    1
  ];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = "IcosahedronBufferGeometry";
  this.parameters = {
    radius,
    detail
  };
}
IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
function DodecahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = "DodecahedronGeometry";
  this.parameters = {
    radius,
    detail
  };
  this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}
DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
function DodecahedronBufferGeometry(radius, detail) {
  var t2 = (1 + Math.sqrt(5)) / 2;
  var r2 = 1 / t2;
  var vertices = [
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    -1,
    1,
    1,
    1,
    0,
    -r2,
    -t2,
    0,
    -r2,
    t2,
    0,
    r2,
    -t2,
    0,
    r2,
    t2,
    -r2,
    -t2,
    0,
    -r2,
    t2,
    0,
    r2,
    -t2,
    0,
    r2,
    t2,
    0,
    -t2,
    0,
    -r2,
    t2,
    0,
    -r2,
    -t2,
    0,
    r2,
    t2,
    0,
    r2
  ];
  var indices = [
    3,
    11,
    7,
    3,
    7,
    15,
    3,
    15,
    13,
    7,
    19,
    17,
    7,
    17,
    6,
    7,
    6,
    15,
    17,
    4,
    8,
    17,
    8,
    10,
    17,
    10,
    6,
    8,
    0,
    16,
    8,
    16,
    2,
    8,
    2,
    10,
    0,
    12,
    1,
    0,
    1,
    18,
    0,
    18,
    16,
    6,
    10,
    2,
    6,
    2,
    13,
    6,
    13,
    15,
    2,
    16,
    18,
    2,
    18,
    3,
    2,
    3,
    13,
    18,
    1,
    9,
    18,
    9,
    11,
    18,
    11,
    3,
    4,
    14,
    12,
    4,
    12,
    0,
    4,
    0,
    8,
    11,
    9,
    5,
    11,
    5,
    19,
    11,
    19,
    7,
    19,
    5,
    14,
    19,
    14,
    4,
    19,
    4,
    17,
    1,
    12,
    14,
    1,
    14,
    5,
    1,
    5,
    9
  ];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = "DodecahedronBufferGeometry";
  this.parameters = {
    radius,
    detail
  };
}
DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
  Geometry.call(this);
  this.type = "TubeGeometry";
  this.parameters = {
    path,
    tubularSegments,
    radius,
    radialSegments,
    closed
  };
  if (taper !== void 0)
    console.warn("THREE.TubeGeometry: taper has been removed.");
  var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
  this.tangents = bufferGeometry.tangents;
  this.normals = bufferGeometry.normals;
  this.binormals = bufferGeometry.binormals;
  this.fromBufferGeometry(bufferGeometry);
  this.mergeVertices();
}
TubeGeometry.prototype = Object.create(Geometry.prototype);
TubeGeometry.prototype.constructor = TubeGeometry;
function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
  BufferGeometry.call(this);
  this.type = "TubeBufferGeometry";
  this.parameters = {
    path,
    tubularSegments,
    radius,
    radialSegments,
    closed
  };
  tubularSegments = tubularSegments || 64;
  radius = radius || 1;
  radialSegments = radialSegments || 8;
  closed = closed || false;
  var frames = path.computeFrenetFrames(tubularSegments, closed);
  this.tangents = frames.tangents;
  this.normals = frames.normals;
  this.binormals = frames.binormals;
  var vertex = new Vector3();
  var normal = new Vector3();
  var uv = new Vector2();
  var P2 = new Vector3();
  var i2, j;
  var vertices = [];
  var normals = [];
  var uvs = [];
  var indices = [];
  generateBufferData();
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function generateBufferData() {
    for (i2 = 0; i2 < tubularSegments; i2++) {
      generateSegment(i2);
    }
    generateSegment(closed === false ? tubularSegments : 0);
    generateUVs();
    generateIndices();
  }
  function generateSegment(i3) {
    P2 = path.getPointAt(i3 / tubularSegments, P2);
    var N2 = frames.normals[i3];
    var B = frames.binormals[i3];
    for (j = 0; j <= radialSegments; j++) {
      var v2 = j / radialSegments * Math.PI * 2;
      var sin = Math.sin(v2);
      var cos = -Math.cos(v2);
      normal.x = cos * N2.x + sin * B.x;
      normal.y = cos * N2.y + sin * B.y;
      normal.z = cos * N2.z + sin * B.z;
      normal.normalize();
      normals.push(normal.x, normal.y, normal.z);
      vertex.x = P2.x + radius * normal.x;
      vertex.y = P2.y + radius * normal.y;
      vertex.z = P2.z + radius * normal.z;
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  }
  function generateIndices() {
    for (j = 1; j <= tubularSegments; j++) {
      for (i2 = 1; i2 <= radialSegments; i2++) {
        var a2 = (radialSegments + 1) * (j - 1) + (i2 - 1);
        var b2 = (radialSegments + 1) * j + (i2 - 1);
        var c2 = (radialSegments + 1) * j + i2;
        var d2 = (radialSegments + 1) * (j - 1) + i2;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
  }
  function generateUVs() {
    for (i2 = 0; i2 <= tubularSegments; i2++) {
      for (j = 0; j <= radialSegments; j++) {
        uv.x = i2 / tubularSegments;
        uv.y = j / radialSegments;
        uvs.push(uv.x, uv.y);
      }
    }
  }
}
TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
TubeBufferGeometry.prototype.toJSON = function() {
  var data = BufferGeometry.prototype.toJSON.call(this);
  data.path = this.parameters.path.toJSON();
  return data;
};
function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p2, q, heightScale) {
  Geometry.call(this);
  this.type = "TorusKnotGeometry";
  this.parameters = {
    radius,
    tube,
    tubularSegments,
    radialSegments,
    p: p2,
    q
  };
  if (heightScale !== void 0)
    console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
  this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p2, q));
  this.mergeVertices();
}
TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p2, q) {
  BufferGeometry.call(this);
  this.type = "TorusKnotBufferGeometry";
  this.parameters = {
    radius,
    tube,
    tubularSegments,
    radialSegments,
    p: p2,
    q
  };
  radius = radius || 1;
  tube = tube || 0.4;
  tubularSegments = Math.floor(tubularSegments) || 64;
  radialSegments = Math.floor(radialSegments) || 8;
  p2 = p2 || 2;
  q = q || 3;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var i2, j;
  var vertex = new Vector3();
  var normal = new Vector3();
  var P1 = new Vector3();
  var P2 = new Vector3();
  var B = new Vector3();
  var T2 = new Vector3();
  var N2 = new Vector3();
  for (i2 = 0; i2 <= tubularSegments; ++i2) {
    var u2 = i2 / tubularSegments * p2 * Math.PI * 2;
    calculatePositionOnCurve(u2, p2, q, radius, P1);
    calculatePositionOnCurve(u2 + 0.01, p2, q, radius, P2);
    T2.subVectors(P2, P1);
    N2.addVectors(P2, P1);
    B.crossVectors(T2, N2);
    N2.crossVectors(B, T2);
    B.normalize();
    N2.normalize();
    for (j = 0; j <= radialSegments; ++j) {
      var v2 = j / radialSegments * Math.PI * 2;
      var cx = -tube * Math.cos(v2);
      var cy = tube * Math.sin(v2);
      vertex.x = P1.x + (cx * N2.x + cy * B.x);
      vertex.y = P1.y + (cx * N2.y + cy * B.y);
      vertex.z = P1.z + (cx * N2.z + cy * B.z);
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.subVectors(vertex, P1).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(i2 / tubularSegments);
      uvs.push(j / radialSegments);
    }
  }
  for (j = 1; j <= tubularSegments; j++) {
    for (i2 = 1; i2 <= radialSegments; i2++) {
      var a2 = (radialSegments + 1) * (j - 1) + (i2 - 1);
      var b2 = (radialSegments + 1) * j + (i2 - 1);
      var c2 = (radialSegments + 1) * j + i2;
      var d2 = (radialSegments + 1) * (j - 1) + i2;
      indices.push(a2, b2, d2);
      indices.push(b2, c2, d2);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function calculatePositionOnCurve(u3, p3, q2, radius2, position) {
    var cu = Math.cos(u3);
    var su = Math.sin(u3);
    var quOverP = q2 / p3 * u3;
    var cs = Math.cos(quOverP);
    position.x = radius2 * (2 + cs) * 0.5 * cu;
    position.y = radius2 * (2 + cs) * su * 0.5;
    position.z = radius2 * Math.sin(quOverP) * 0.5;
  }
}
TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
  Geometry.call(this);
  this.type = "TorusGeometry";
  this.parameters = {
    radius,
    tube,
    radialSegments,
    tubularSegments,
    arc
  };
  this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
  this.mergeVertices();
}
TorusGeometry.prototype = Object.create(Geometry.prototype);
TorusGeometry.prototype.constructor = TorusGeometry;
function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
  BufferGeometry.call(this);
  this.type = "TorusBufferGeometry";
  this.parameters = {
    radius,
    tube,
    radialSegments,
    tubularSegments,
    arc
  };
  radius = radius || 1;
  tube = tube || 0.4;
  radialSegments = Math.floor(radialSegments) || 8;
  tubularSegments = Math.floor(tubularSegments) || 6;
  arc = arc || Math.PI * 2;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var center = new Vector3();
  var vertex = new Vector3();
  var normal = new Vector3();
  var j, i2;
  for (j = 0; j <= radialSegments; j++) {
    for (i2 = 0; i2 <= tubularSegments; i2++) {
      var u2 = i2 / tubularSegments * arc;
      var v2 = j / radialSegments * Math.PI * 2;
      vertex.x = (radius + tube * Math.cos(v2)) * Math.cos(u2);
      vertex.y = (radius + tube * Math.cos(v2)) * Math.sin(u2);
      vertex.z = tube * Math.sin(v2);
      vertices.push(vertex.x, vertex.y, vertex.z);
      center.x = radius * Math.cos(u2);
      center.y = radius * Math.sin(u2);
      normal.subVectors(vertex, center).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(i2 / tubularSegments);
      uvs.push(j / radialSegments);
    }
  }
  for (j = 1; j <= radialSegments; j++) {
    for (i2 = 1; i2 <= tubularSegments; i2++) {
      var a2 = (tubularSegments + 1) * j + i2 - 1;
      var b2 = (tubularSegments + 1) * (j - 1) + i2 - 1;
      var c2 = (tubularSegments + 1) * (j - 1) + i2;
      var d2 = (tubularSegments + 1) * j + i2;
      indices.push(a2, b2, d2);
      indices.push(b2, c2, d2);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
var Earcut = {
  triangulate: function(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
    if (!outerNode)
      return triangles;
    var minX, minY, maxX, maxY, x2, y, invSize;
    if (hasHoles)
      outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (var i2 = dim; i2 < outerLen; i2 += dim) {
        x2 = data[i2];
        y = data[i2 + 1];
        if (x2 < minX)
          minX = x2;
        if (y < minY)
          minY = y;
        if (x2 > maxX)
          maxX = x2;
        if (y > maxY)
          maxY = y;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
};
function linkedList(data, start, end, dim, clockwise) {
  var i2, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i2 = start; i2 < end; i2 += dim)
      last = insertNode(i2, data[i2], data[i2 + 1], last);
  } else {
    for (i2 = end - dim; i2 >= start; i2 -= dim)
      last = insertNode(i2, data[i2], data[i2 + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  var p2 = start, again;
  do {
    again = false;
    if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
      removeNode(p2);
      p2 = end = p2.prev;
      if (p2 === p2.next)
        break;
      again = true;
    } else {
      p2 = p2.next;
    }
  } while (again || p2 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  var stop2 = ear, prev3, next3;
  while (ear.prev !== ear.next) {
    prev3 = ear.prev;
    next3 = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev3.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next3.i / dim);
      removeNode(ear);
      ear = next3.next;
      stop2 = next3.next;
      continue;
    }
    ear = next3;
    if (ear === stop2) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(ear, triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  var a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  var p2 = ear.next.next;
  while (p2 !== ear.prev) {
    if (pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) {
      return false;
    }
    p2 = p2.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  var a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  var minTX = a2.x < b2.x ? a2.x < c2.x ? a2.x : c2.x : b2.x < c2.x ? b2.x : c2.x, minTY = a2.y < b2.y ? a2.y < c2.y ? a2.y : c2.y : b2.y < c2.y ? b2.y : c2.y, maxTX = a2.x > b2.x ? a2.x > c2.x ? a2.x : c2.x : b2.x > c2.x ? b2.x : c2.x, maxTY = a2.y > b2.y ? a2.y > c2.y ? a2.y : c2.y : b2.y > c2.y ? b2.y : c2.y;
  var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  var p2 = ear.nextZ;
  while (p2 && p2.z <= maxZ) {
    if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.nextZ;
  }
  p2 = ear.prevZ;
  while (p2 && p2.z >= minZ) {
    if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  var p2 = start;
  do {
    var a2 = p2.prev, b2 = p2.next.next;
    if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
      triangles.push(a2.i / dim);
      triangles.push(p2.i / dim);
      triangles.push(b2.i / dim);
      removeNode(p2);
      removeNode(p2.next);
      p2 = start = b2;
    }
    p2 = p2.next;
  } while (p2 !== start);
  return p2;
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  var a2 = start;
  do {
    var b2 = a2.next.next;
    while (b2 !== a2.prev) {
      if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
        var c2 = splitPolygon(a2, b2);
        a2 = filterPoints(a2, a2.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a2, triangles, dim, minX, minY, invSize);
        earcutLinked(c2, triangles, dim, minX, minY, invSize);
        return;
      }
      b2 = b2.next;
    }
    a2 = a2.next;
  } while (a2 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [], i2, len, start, end, list;
  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    start = holeIndices[i2] * dim;
    end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i2 = 0; i2 < queue.length; i2++) {
    eliminateHole(queue[i2], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a2, b2) {
  return a2.x - b2.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    var b2 = splitPolygon(outerNode, hole);
    filterPoints(b2, b2.next);
  }
}
function findHoleBridge(hole, outerNode) {
  var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
  do {
    if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
      var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        if (x2 === hx) {
          if (hy === p2.y)
            return p2;
          if (hy === p2.next.y)
            return p2.next;
        }
        m2 = p2.x < p2.next.x ? p2 : p2.next;
      }
    }
    p2 = p2.next;
  } while (p2 !== outerNode);
  if (!m2)
    return null;
  if (hx === qx)
    return m2.prev;
  var stop2 = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
  p2 = m2.next;
  while (p2 !== stop2) {
    if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
      tan = Math.abs(hy - p2.y) / (hx - p2.x);
      if ((tan < tanMin || tan === tanMin && p2.x > m2.x) && locallyInside(p2, hole)) {
        m2 = p2;
        tanMin = tan;
      }
    }
    p2 = p2.next;
  }
  return m2;
}
function indexCurve(start, minX, minY, invSize) {
  var p2 = start;
  do {
    if (p2.z === null)
      p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
    p2.prevZ = p2.prev;
    p2.nextZ = p2.next;
    p2 = p2.next;
  } while (p2 !== start);
  p2.prevZ.nextZ = null;
  p2.prevZ = null;
  sortLinked(p2);
}
function sortLinked(list) {
  var i2, p2, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p2 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p2) {
      numMerges++;
      q = p2;
      pSize = 0;
      for (i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
          e2 = p2;
          p2 = p2.nextZ;
          pSize--;
        } else {
          e2 = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e2;
        else
          list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p2 = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y, minX, minY, invSize) {
  x2 = 32767 * (x2 - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x2 | y << 1;
}
function getLeftmost(start) {
  var p2 = start, leftmost = start;
  do {
    if (p2.x < leftmost.x)
      leftmost = p2;
    p2 = p2.next;
  } while (p2 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
}
function isValidDiagonal(a2, b2) {
  return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2);
}
function area(p2, q, r2) {
  return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1))
    return true;
  return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}
function intersectsPolygon(a2, b2) {
  var p2 = a2;
  do {
    if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2)) {
      return true;
    }
    p2 = p2.next;
  } while (p2 !== a2);
  return false;
}
function locallyInside(a2, b2) {
  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
}
function middleInside(a2, b2) {
  var p2 = a2, inside = false, px2 = (a2.x + b2.x) / 2, py2 = (a2.y + b2.y) / 2;
  do {
    if (p2.y > py2 !== p2.next.y > py2 && p2.next.y !== p2.y && px2 < (p2.next.x - p2.x) * (py2 - p2.y) / (p2.next.y - p2.y) + p2.x) {
      inside = !inside;
    }
    p2 = p2.next;
  } while (p2 !== a2);
  return inside;
}
function splitPolygon(a2, b2) {
  var a22 = new Node$1(a2.i, a2.x, a2.y), b22 = new Node$1(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
  a2.next = b2;
  b2.prev = a2;
  a22.next = an;
  an.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i2, x2, y, last) {
  var p2 = new Node$1(i2, x2, y);
  if (!last) {
    p2.prev = p2;
    p2.next = p2;
  } else {
    p2.next = last.next;
    p2.prev = last;
    last.next.prev = p2;
    last.next = p2;
  }
  return p2;
}
function removeNode(p2) {
  p2.next.prev = p2.prev;
  p2.prev.next = p2.next;
  if (p2.prevZ)
    p2.prevZ.nextZ = p2.nextZ;
  if (p2.nextZ)
    p2.nextZ.prevZ = p2.prevZ;
}
function Node$1(i2, x2, y) {
  this.i = i2;
  this.x = x2;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  var sum = 0;
  for (var i2 = start, j = end - dim; i2 < end; i2 += dim) {
    sum += (data[j] - data[i2]) * (data[i2 + 1] + data[j + 1]);
    j = i2;
  }
  return sum;
}
var ShapeUtils = {
  area: function(contour) {
    var n2 = contour.length;
    var a2 = 0;
    for (var p2 = n2 - 1, q = 0; q < n2; p2 = q++) {
      a2 += contour[p2].x * contour[q].y - contour[q].x * contour[p2].y;
    }
    return a2 * 0.5;
  },
  isClockWise: function(pts) {
    return ShapeUtils.area(pts) < 0;
  },
  triangulateShape: function(contour, holes) {
    var vertices = [];
    var holeIndices = [];
    var faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    var holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (var i2 = 0; i2 < holes.length; i2++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i2].length;
      addContour(vertices, holes[i2]);
    }
    var triangles = Earcut.triangulate(vertices, holeIndices);
    for (var i2 = 0; i2 < triangles.length; i2 += 3) {
      faces.push(triangles.slice(i2, i2 + 3));
    }
    return faces;
  }
};
function removeDupEndPts(points) {
  var l2 = points.length;
  if (l2 > 2 && points[l2 - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (var i2 = 0; i2 < contour.length; i2++) {
    vertices.push(contour[i2].x);
    vertices.push(contour[i2].y);
  }
}
function ExtrudeGeometry(shapes, options) {
  Geometry.call(this);
  this.type = "ExtrudeGeometry";
  this.parameters = {
    shapes,
    options
  };
  this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
  this.mergeVertices();
}
ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
ExtrudeGeometry.prototype.toJSON = function() {
  var data = Geometry.prototype.toJSON.call(this);
  var shapes = this.parameters.shapes;
  var options = this.parameters.options;
  return toJSON(shapes, options, data);
};
function ExtrudeBufferGeometry(shapes, options) {
  BufferGeometry.call(this);
  this.type = "ExtrudeBufferGeometry";
  this.parameters = {
    shapes,
    options
  };
  shapes = Array.isArray(shapes) ? shapes : [shapes];
  var scope = this;
  var verticesArray = [];
  var uvArray = [];
  for (var i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
    var shape = shapes[i2];
    addShape(shape);
  }
  this.addAttribute("position", new Float32BufferAttribute(verticesArray, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvArray, 2));
  this.computeVertexNormals();
  function addShape(shape2) {
    var placeholder = [];
    var curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
    var steps = options.steps !== void 0 ? options.steps : 1;
    var depth = options.depth !== void 0 ? options.depth : 100;
    var bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
    var bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 6;
    var bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 2;
    var bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
    var bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
    var extrudePath = options.extrudePath;
    var uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
    if (options.amount !== void 0) {
      console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
      depth = options.amount;
    }
    var extrudePts, extrudeByPath = false;
    var splineTube, binormal, normal, position2;
    if (extrudePath) {
      extrudePts = extrudePath.getSpacedPoints(steps);
      extrudeByPath = true;
      bevelEnabled = false;
      splineTube = extrudePath.computeFrenetFrames(steps, false);
      binormal = new Vector3();
      normal = new Vector3();
      position2 = new Vector3();
    }
    if (!bevelEnabled) {
      bevelSegments = 0;
      bevelThickness = 0;
      bevelSize = 0;
      bevelOffset = 0;
    }
    var ahole, h2, hl;
    var shapePoints = shape2.extractPoints(curveSegments);
    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;
    var reverse = !ShapeUtils.isClockWise(vertices);
    if (reverse) {
      vertices = vertices.reverse();
      for (h2 = 0, hl = holes.length; h2 < hl; h2++) {
        ahole = holes[h2];
        if (ShapeUtils.isClockWise(ahole)) {
          holes[h2] = ahole.reverse();
        }
      }
    }
    var faces = ShapeUtils.triangulateShape(vertices, holes);
    var contour = vertices;
    for (h2 = 0, hl = holes.length; h2 < hl; h2++) {
      ahole = holes[h2];
      vertices = vertices.concat(ahole);
    }
    function scalePt2(pt, vec, size) {
      if (!vec)
        console.error("THREE.ExtrudeGeometry: vec does not exist");
      return vec.clone().multiplyScalar(size).add(pt);
    }
    var b2, bs, t2, z2, vert, vlen = vertices.length, face, flen = faces.length;
    function getBevelVec(inPt, inPrev, inNext) {
      var v_trans_x, v_trans_y, shrink_by;
      var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
      var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
      var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
      var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
      if (Math.abs(collinear0) > Number.EPSILON) {
        var v_prev_len = Math.sqrt(v_prev_lensq);
        var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
        var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
        var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
        var ptNextShift_x = inNext.x - v_next_y / v_next_len;
        var ptNextShift_y = inNext.y + v_next_x / v_next_len;
        var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
        v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
        v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
        var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
        if (v_trans_lensq <= 2) {
          return new Vector2(v_trans_x, v_trans_y);
        } else {
          shrink_by = Math.sqrt(v_trans_lensq / 2);
        }
      } else {
        var direction_eq = false;
        if (v_prev_x > Number.EPSILON) {
          if (v_next_x > Number.EPSILON) {
            direction_eq = true;
          }
        } else {
          if (v_prev_x < -Number.EPSILON) {
            if (v_next_x < -Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
              direction_eq = true;
            }
          }
        }
        if (direction_eq) {
          v_trans_x = -v_prev_y;
          v_trans_y = v_prev_x;
          shrink_by = Math.sqrt(v_prev_lensq);
        } else {
          v_trans_x = v_prev_x;
          v_trans_y = v_prev_y;
          shrink_by = Math.sqrt(v_prev_lensq / 2);
        }
      }
      return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
    }
    var contourMovements = [];
    for (var i3 = 0, il = contour.length, j = il - 1, k2 = i3 + 1; i3 < il; i3++, j++, k2++) {
      if (j === il)
        j = 0;
      if (k2 === il)
        k2 = 0;
      contourMovements[i3] = getBevelVec(contour[i3], contour[j], contour[k2]);
    }
    var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
    for (h2 = 0, hl = holes.length; h2 < hl; h2++) {
      ahole = holes[h2];
      oneHoleMovements = [];
      for (i3 = 0, il = ahole.length, j = il - 1, k2 = i3 + 1; i3 < il; i3++, j++, k2++) {
        if (j === il)
          j = 0;
        if (k2 === il)
          k2 = 0;
        oneHoleMovements[i3] = getBevelVec(ahole[i3], ahole[j], ahole[k2]);
      }
      holesMovements.push(oneHoleMovements);
      verticesMovements = verticesMovements.concat(oneHoleMovements);
    }
    for (b2 = 0; b2 < bevelSegments; b2++) {
      t2 = b2 / bevelSegments;
      z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
      bs = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
      for (i3 = 0, il = contour.length; i3 < il; i3++) {
        vert = scalePt2(contour[i3], contourMovements[i3], bs);
        v2(vert.x, vert.y, -z2);
      }
      for (h2 = 0, hl = holes.length; h2 < hl; h2++) {
        ahole = holes[h2];
        oneHoleMovements = holesMovements[h2];
        for (i3 = 0, il = ahole.length; i3 < il; i3++) {
          vert = scalePt2(ahole[i3], oneHoleMovements[i3], bs);
          v2(vert.x, vert.y, -z2);
        }
      }
    }
    bs = bevelSize + bevelOffset;
    for (i3 = 0; i3 < vlen; i3++) {
      vert = bevelEnabled ? scalePt2(vertices[i3], verticesMovements[i3], bs) : vertices[i3];
      if (!extrudeByPath) {
        v2(vert.x, vert.y, 0);
      } else {
        normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
        binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
        position2.copy(extrudePts[0]).add(normal).add(binormal);
        v2(position2.x, position2.y, position2.z);
      }
    }
    var s2;
    for (s2 = 1; s2 <= steps; s2++) {
      for (i3 = 0; i3 < vlen; i3++) {
        vert = bevelEnabled ? scalePt2(vertices[i3], verticesMovements[i3], bs) : vertices[i3];
        if (!extrudeByPath) {
          v2(vert.x, vert.y, depth / steps * s2);
        } else {
          normal.copy(splineTube.normals[s2]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[s2]).multiplyScalar(vert.y);
          position2.copy(extrudePts[s2]).add(normal).add(binormal);
          v2(position2.x, position2.y, position2.z);
        }
      }
    }
    for (b2 = bevelSegments - 1; b2 >= 0; b2--) {
      t2 = b2 / bevelSegments;
      z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
      bs = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
      for (i3 = 0, il = contour.length; i3 < il; i3++) {
        vert = scalePt2(contour[i3], contourMovements[i3], bs);
        v2(vert.x, vert.y, depth + z2);
      }
      for (h2 = 0, hl = holes.length; h2 < hl; h2++) {
        ahole = holes[h2];
        oneHoleMovements = holesMovements[h2];
        for (i3 = 0, il = ahole.length; i3 < il; i3++) {
          vert = scalePt2(ahole[i3], oneHoleMovements[i3], bs);
          if (!extrudeByPath) {
            v2(vert.x, vert.y, depth + z2);
          } else {
            v2(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z2);
          }
        }
      }
    }
    buildLidFaces();
    buildSideFaces();
    function buildLidFaces() {
      var start = verticesArray.length / 3;
      if (bevelEnabled) {
        var layer = 0;
        var offset2 = vlen * layer;
        for (i3 = 0; i3 < flen; i3++) {
          face = faces[i3];
          f3(face[2] + offset2, face[1] + offset2, face[0] + offset2);
        }
        layer = steps + bevelSegments * 2;
        offset2 = vlen * layer;
        for (i3 = 0; i3 < flen; i3++) {
          face = faces[i3];
          f3(face[0] + offset2, face[1] + offset2, face[2] + offset2);
        }
      } else {
        for (i3 = 0; i3 < flen; i3++) {
          face = faces[i3];
          f3(face[2], face[1], face[0]);
        }
        for (i3 = 0; i3 < flen; i3++) {
          face = faces[i3];
          f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
        }
      }
      scope.addGroup(start, verticesArray.length / 3 - start, 0);
    }
    function buildSideFaces() {
      var start = verticesArray.length / 3;
      var layeroffset = 0;
      sidewalls(contour, layeroffset);
      layeroffset += contour.length;
      for (h2 = 0, hl = holes.length; h2 < hl; h2++) {
        ahole = holes[h2];
        sidewalls(ahole, layeroffset);
        layeroffset += ahole.length;
      }
      scope.addGroup(start, verticesArray.length / 3 - start, 1);
    }
    function sidewalls(contour2, layeroffset) {
      var j2, k3;
      i3 = contour2.length;
      while (--i3 >= 0) {
        j2 = i3;
        k3 = i3 - 1;
        if (k3 < 0)
          k3 = contour2.length - 1;
        var s3 = 0, sl = steps + bevelSegments * 2;
        for (s3 = 0; s3 < sl; s3++) {
          var slen1 = vlen * s3;
          var slen2 = vlen * (s3 + 1);
          var a2 = layeroffset + j2 + slen1, b3 = layeroffset + k3 + slen1, c2 = layeroffset + k3 + slen2, d2 = layeroffset + j2 + slen2;
          f4(a2, b3, c2, d2);
        }
      }
    }
    function v2(x2, y, z3) {
      placeholder.push(x2);
      placeholder.push(y);
      placeholder.push(z3);
    }
    function f3(a2, b3, c2) {
      addVertex(a2);
      addVertex(b3);
      addVertex(c2);
      var nextIndex = verticesArray.length / 3;
      var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
      addUV(uvs[0]);
      addUV(uvs[1]);
      addUV(uvs[2]);
    }
    function f4(a2, b3, c2, d2) {
      addVertex(a2);
      addVertex(b3);
      addVertex(d2);
      addVertex(b3);
      addVertex(c2);
      addVertex(d2);
      var nextIndex = verticesArray.length / 3;
      var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
      addUV(uvs[0]);
      addUV(uvs[1]);
      addUV(uvs[3]);
      addUV(uvs[1]);
      addUV(uvs[2]);
      addUV(uvs[3]);
    }
    function addVertex(index2) {
      verticesArray.push(placeholder[index2 * 3 + 0]);
      verticesArray.push(placeholder[index2 * 3 + 1]);
      verticesArray.push(placeholder[index2 * 3 + 2]);
    }
    function addUV(vector2) {
      uvArray.push(vector2.x);
      uvArray.push(vector2.y);
    }
  }
}
ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
ExtrudeBufferGeometry.prototype.toJSON = function() {
  var data = BufferGeometry.prototype.toJSON.call(this);
  var shapes = this.parameters.shapes;
  var options = this.parameters.options;
  return toJSON(shapes, options, data);
};
var WorldUVGenerator = {
  generateTopUV: function(geometry2, vertices, indexA, indexB, indexC) {
    var a_x = vertices[indexA * 3];
    var a_y = vertices[indexA * 3 + 1];
    var b_x = vertices[indexB * 3];
    var b_y = vertices[indexB * 3 + 1];
    var c_x = vertices[indexC * 3];
    var c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry2, vertices, indexA, indexB, indexC, indexD) {
    var a_x = vertices[indexA * 3];
    var a_y = vertices[indexA * 3 + 1];
    var a_z = vertices[indexA * 3 + 2];
    var b_x = vertices[indexB * 3];
    var b_y = vertices[indexB * 3 + 1];
    var b_z = vertices[indexB * 3 + 2];
    var c_x = vertices[indexC * 3];
    var c_y = vertices[indexC * 3 + 1];
    var c_z = vertices[indexC * 3 + 2];
    var d_x = vertices[indexD * 3];
    var d_y = vertices[indexD * 3 + 1];
    var d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < 0.01) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON(shapes, options, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (var i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      var shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  if (options.extrudePath !== void 0)
    data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
function TextGeometry(text2, parameters) {
  Geometry.call(this);
  this.type = "TextGeometry";
  this.parameters = {
    text: text2,
    parameters
  };
  this.fromBufferGeometry(new TextBufferGeometry(text2, parameters));
  this.mergeVertices();
}
TextGeometry.prototype = Object.create(Geometry.prototype);
TextGeometry.prototype.constructor = TextGeometry;
function TextBufferGeometry(text2, parameters) {
  parameters = parameters || {};
  var font = parameters.font;
  if (!(font && font.isFont)) {
    console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
    return new Geometry();
  }
  var shapes = font.generateShapes(text2, parameters.size);
  parameters.depth = parameters.height !== void 0 ? parameters.height : 50;
  if (parameters.bevelThickness === void 0)
    parameters.bevelThickness = 10;
  if (parameters.bevelSize === void 0)
    parameters.bevelSize = 8;
  if (parameters.bevelEnabled === void 0)
    parameters.bevelEnabled = false;
  ExtrudeBufferGeometry.call(this, shapes, parameters);
  this.type = "TextBufferGeometry";
}
TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
TextBufferGeometry.prototype.constructor = TextBufferGeometry;
function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = "SphereGeometry";
  this.parameters = {
    radius,
    widthSegments,
    heightSegments,
    phiStart,
    phiLength,
    thetaStart,
    thetaLength
  };
  this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
  this.mergeVertices();
}
SphereGeometry.prototype = Object.create(Geometry.prototype);
SphereGeometry.prototype.constructor = SphereGeometry;
function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = "SphereBufferGeometry";
  this.parameters = {
    radius,
    widthSegments,
    heightSegments,
    phiStart,
    phiLength,
    thetaStart,
    thetaLength
  };
  radius = radius || 1;
  widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
  heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
  phiStart = phiStart !== void 0 ? phiStart : 0;
  phiLength = phiLength !== void 0 ? phiLength : Math.PI * 2;
  thetaStart = thetaStart !== void 0 ? thetaStart : 0;
  thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI;
  var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
  var ix, iy;
  var index2 = 0;
  var grid = [];
  var vertex = new Vector3();
  var normal = new Vector3();
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  for (iy = 0; iy <= heightSegments; iy++) {
    var verticesRow = [];
    var v2 = iy / heightSegments;
    var uOffset = 0;
    if (iy == 0 && thetaStart == 0) {
      uOffset = 0.5 / widthSegments;
    } else if (iy == heightSegments && thetaEnd == Math.PI) {
      uOffset = -0.5 / widthSegments;
    }
    for (ix = 0; ix <= widthSegments; ix++) {
      var u2 = ix / widthSegments;
      vertex.x = -radius * Math.cos(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
      vertex.y = radius * Math.cos(thetaStart + v2 * thetaLength);
      vertex.z = radius * Math.sin(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.copy(vertex).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u2 + uOffset, 1 - v2);
      verticesRow.push(index2++);
    }
    grid.push(verticesRow);
  }
  for (iy = 0; iy < heightSegments; iy++) {
    for (ix = 0; ix < widthSegments; ix++) {
      var a2 = grid[iy][ix + 1];
      var b2 = grid[iy][ix];
      var c2 = grid[iy + 1][ix];
      var d2 = grid[iy + 1][ix + 1];
      if (iy !== 0 || thetaStart > 0)
        indices.push(a2, b2, d2);
      if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
        indices.push(b2, c2, d2);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = "RingGeometry";
  this.parameters = {
    innerRadius,
    outerRadius,
    thetaSegments,
    phiSegments,
    thetaStart,
    thetaLength
  };
  this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
  this.mergeVertices();
}
RingGeometry.prototype = Object.create(Geometry.prototype);
RingGeometry.prototype.constructor = RingGeometry;
function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = "RingBufferGeometry";
  this.parameters = {
    innerRadius,
    outerRadius,
    thetaSegments,
    phiSegments,
    thetaStart,
    thetaLength
  };
  innerRadius = innerRadius || 0.5;
  outerRadius = outerRadius || 1;
  thetaStart = thetaStart !== void 0 ? thetaStart : 0;
  thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
  thetaSegments = thetaSegments !== void 0 ? Math.max(3, thetaSegments) : 8;
  phiSegments = phiSegments !== void 0 ? Math.max(1, phiSegments) : 1;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var segment;
  var radius = innerRadius;
  var radiusStep = (outerRadius - innerRadius) / phiSegments;
  var vertex = new Vector3();
  var uv = new Vector2();
  var j, i2;
  for (j = 0; j <= phiSegments; j++) {
    for (i2 = 0; i2 <= thetaSegments; i2++) {
      segment = thetaStart + i2 / thetaSegments * thetaLength;
      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z);
      normals.push(0, 0, 1);
      uv.x = (vertex.x / outerRadius + 1) / 2;
      uv.y = (vertex.y / outerRadius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }
    radius += radiusStep;
  }
  for (j = 0; j < phiSegments; j++) {
    var thetaSegmentLevel = j * (thetaSegments + 1);
    for (i2 = 0; i2 < thetaSegments; i2++) {
      segment = i2 + thetaSegmentLevel;
      var a2 = segment;
      var b2 = segment + thetaSegments + 1;
      var c2 = segment + thetaSegments + 2;
      var d2 = segment + 1;
      indices.push(a2, b2, d2);
      indices.push(b2, c2, d2);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
RingBufferGeometry.prototype.constructor = RingBufferGeometry;
function LatheGeometry(points, segments, phiStart, phiLength) {
  Geometry.call(this);
  this.type = "LatheGeometry";
  this.parameters = {
    points,
    segments,
    phiStart,
    phiLength
  };
  this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
  this.mergeVertices();
}
LatheGeometry.prototype = Object.create(Geometry.prototype);
LatheGeometry.prototype.constructor = LatheGeometry;
function LatheBufferGeometry(points, segments, phiStart, phiLength) {
  BufferGeometry.call(this);
  this.type = "LatheBufferGeometry";
  this.parameters = {
    points,
    segments,
    phiStart,
    phiLength
  };
  segments = Math.floor(segments) || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || Math.PI * 2;
  phiLength = _Math.clamp(phiLength, 0, Math.PI * 2);
  var indices = [];
  var vertices = [];
  var uvs = [];
  var base;
  var inverseSegments = 1 / segments;
  var vertex = new Vector3();
  var uv = new Vector2();
  var i2, j;
  for (i2 = 0; i2 <= segments; i2++) {
    var phi = phiStart + i2 * inverseSegments * phiLength;
    var sin = Math.sin(phi);
    var cos = Math.cos(phi);
    for (j = 0; j <= points.length - 1; j++) {
      vertex.x = points[j].x * sin;
      vertex.y = points[j].y;
      vertex.z = points[j].x * cos;
      vertices.push(vertex.x, vertex.y, vertex.z);
      uv.x = i2 / segments;
      uv.y = j / (points.length - 1);
      uvs.push(uv.x, uv.y);
    }
  }
  for (i2 = 0; i2 < segments; i2++) {
    for (j = 0; j < points.length - 1; j++) {
      base = j + i2 * points.length;
      var a2 = base;
      var b2 = base + points.length;
      var c2 = base + points.length + 1;
      var d2 = base + 1;
      indices.push(a2, b2, d2);
      indices.push(b2, c2, d2);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  this.computeVertexNormals();
  if (phiLength === Math.PI * 2) {
    var normals = this.attributes.normal.array;
    var n1 = new Vector3();
    var n2 = new Vector3();
    var n3 = new Vector3();
    base = segments * points.length * 3;
    for (i2 = 0, j = 0; i2 < points.length; i2++, j += 3) {
      n1.x = normals[j + 0];
      n1.y = normals[j + 1];
      n1.z = normals[j + 2];
      n2.x = normals[base + j + 0];
      n2.y = normals[base + j + 1];
      n2.z = normals[base + j + 2];
      n3.addVectors(n1, n2).normalize();
      normals[j + 0] = normals[base + j + 0] = n3.x;
      normals[j + 1] = normals[base + j + 1] = n3.y;
      normals[j + 2] = normals[base + j + 2] = n3.z;
    }
  }
}
LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
function ShapeGeometry(shapes, curveSegments) {
  Geometry.call(this);
  this.type = "ShapeGeometry";
  if (typeof curveSegments === "object") {
    console.warn("THREE.ShapeGeometry: Options parameter has been removed.");
    curveSegments = curveSegments.curveSegments;
  }
  this.parameters = {
    shapes,
    curveSegments
  };
  this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
  this.mergeVertices();
}
ShapeGeometry.prototype = Object.create(Geometry.prototype);
ShapeGeometry.prototype.constructor = ShapeGeometry;
ShapeGeometry.prototype.toJSON = function() {
  var data = Geometry.prototype.toJSON.call(this);
  var shapes = this.parameters.shapes;
  return toJSON$1(shapes, data);
};
function ShapeBufferGeometry(shapes, curveSegments) {
  BufferGeometry.call(this);
  this.type = "ShapeBufferGeometry";
  this.parameters = {
    shapes,
    curveSegments
  };
  curveSegments = curveSegments || 12;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var groupStart = 0;
  var groupCount = 0;
  if (Array.isArray(shapes) === false) {
    addShape(shapes);
  } else {
    for (var i2 = 0; i2 < shapes.length; i2++) {
      addShape(shapes[i2]);
      this.addGroup(groupStart, groupCount, i2);
      groupStart += groupCount;
      groupCount = 0;
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function addShape(shape) {
    var i3, l2, shapeHole;
    var indexOffset = vertices.length / 3;
    var points = shape.extractPoints(curveSegments);
    var shapeVertices = points.shape;
    var shapeHoles = points.holes;
    if (ShapeUtils.isClockWise(shapeVertices) === false) {
      shapeVertices = shapeVertices.reverse();
    }
    for (i3 = 0, l2 = shapeHoles.length; i3 < l2; i3++) {
      shapeHole = shapeHoles[i3];
      if (ShapeUtils.isClockWise(shapeHole) === true) {
        shapeHoles[i3] = shapeHole.reverse();
      }
    }
    var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
    for (i3 = 0, l2 = shapeHoles.length; i3 < l2; i3++) {
      shapeHole = shapeHoles[i3];
      shapeVertices = shapeVertices.concat(shapeHole);
    }
    for (i3 = 0, l2 = shapeVertices.length; i3 < l2; i3++) {
      var vertex = shapeVertices[i3];
      vertices.push(vertex.x, vertex.y, 0);
      normals.push(0, 0, 1);
      uvs.push(vertex.x, vertex.y);
    }
    for (i3 = 0, l2 = faces.length; i3 < l2; i3++) {
      var face = faces[i3];
      var a2 = face[0] + indexOffset;
      var b2 = face[1] + indexOffset;
      var c2 = face[2] + indexOffset;
      indices.push(a2, b2, c2);
      groupCount += 3;
    }
  }
}
ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
ShapeBufferGeometry.prototype.toJSON = function() {
  var data = BufferGeometry.prototype.toJSON.call(this);
  var shapes = this.parameters.shapes;
  return toJSON$1(shapes, data);
};
function toJSON$1(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (var i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      var shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
function EdgesGeometry(geometry2, thresholdAngle) {
  BufferGeometry.call(this);
  this.type = "EdgesGeometry";
  this.parameters = {
    thresholdAngle
  };
  thresholdAngle = thresholdAngle !== void 0 ? thresholdAngle : 1;
  var vertices = [];
  var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);
  var edge = [0, 0], edges = {}, edge1, edge2;
  var key, keys = ["a", "b", "c"];
  var geometry22;
  if (geometry2.isBufferGeometry) {
    geometry22 = new Geometry();
    geometry22.fromBufferGeometry(geometry2);
  } else {
    geometry22 = geometry2.clone();
  }
  geometry22.mergeVertices();
  geometry22.computeFaceNormals();
  var sourceVertices = geometry22.vertices;
  var faces = geometry22.faces;
  for (var i2 = 0, l2 = faces.length; i2 < l2; i2++) {
    var face = faces[i2];
    for (var j = 0; j < 3; j++) {
      edge1 = face[keys[j]];
      edge2 = face[keys[(j + 1) % 3]];
      edge[0] = Math.min(edge1, edge2);
      edge[1] = Math.max(edge1, edge2);
      key = edge[0] + "," + edge[1];
      if (edges[key] === void 0) {
        edges[key] = { index1: edge[0], index2: edge[1], face1: i2, face2: void 0 };
      } else {
        edges[key].face2 = i2;
      }
    }
  }
  for (key in edges) {
    var e2 = edges[key];
    if (e2.face2 === void 0 || faces[e2.face1].normal.dot(faces[e2.face2].normal) <= thresholdDot) {
      var vertex = sourceVertices[e2.index1];
      vertices.push(vertex.x, vertex.y, vertex.z);
      vertex = sourceVertices[e2.index2];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  }
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
}
EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
EdgesGeometry.prototype.constructor = EdgesGeometry;
function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = "CylinderGeometry";
  this.parameters = {
    radiusTop,
    radiusBottom,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  };
  this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
  this.mergeVertices();
}
CylinderGeometry.prototype = Object.create(Geometry.prototype);
CylinderGeometry.prototype.constructor = CylinderGeometry;
function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = "CylinderBufferGeometry";
  this.parameters = {
    radiusTop,
    radiusBottom,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  };
  var scope = this;
  radiusTop = radiusTop !== void 0 ? radiusTop : 1;
  radiusBottom = radiusBottom !== void 0 ? radiusBottom : 1;
  height = height || 1;
  radialSegments = Math.floor(radialSegments) || 8;
  heightSegments = Math.floor(heightSegments) || 1;
  openEnded = openEnded !== void 0 ? openEnded : false;
  thetaStart = thetaStart !== void 0 ? thetaStart : 0;
  thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var index2 = 0;
  var indexArray = [];
  var halfHeight = height / 2;
  var groupStart = 0;
  generateTorso();
  if (openEnded === false) {
    if (radiusTop > 0)
      generateCap(true);
    if (radiusBottom > 0)
      generateCap(false);
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function generateTorso() {
    var x2, y;
    var normal = new Vector3();
    var vertex = new Vector3();
    var groupCount = 0;
    var slope = (radiusBottom - radiusTop) / height;
    for (y = 0; y <= heightSegments; y++) {
      var indexRow = [];
      var v2 = y / heightSegments;
      var radius = v2 * (radiusBottom - radiusTop) + radiusTop;
      for (x2 = 0; x2 <= radialSegments; x2++) {
        var u2 = x2 / radialSegments;
        var theta = u2 * thetaLength + thetaStart;
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta);
        vertex.x = radius * sinTheta;
        vertex.y = -v2 * height + halfHeight;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.set(sinTheta, slope, cosTheta).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u2, 1 - v2);
        indexRow.push(index2++);
      }
      indexArray.push(indexRow);
    }
    for (x2 = 0; x2 < radialSegments; x2++) {
      for (y = 0; y < heightSegments; y++) {
        var a2 = indexArray[y][x2];
        var b2 = indexArray[y + 1][x2];
        var c2 = indexArray[y + 1][x2 + 1];
        var d2 = indexArray[y][x2 + 1];
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
        groupCount += 6;
      }
    }
    scope.addGroup(groupStart, groupCount, 0);
    groupStart += groupCount;
  }
  function generateCap(top) {
    var x2, centerIndexStart, centerIndexEnd;
    var uv = new Vector2();
    var vertex = new Vector3();
    var groupCount = 0;
    var radius = top === true ? radiusTop : radiusBottom;
    var sign = top === true ? 1 : -1;
    centerIndexStart = index2;
    for (x2 = 1; x2 <= radialSegments; x2++) {
      vertices.push(0, halfHeight * sign, 0);
      normals.push(0, sign, 0);
      uvs.push(0.5, 0.5);
      index2++;
    }
    centerIndexEnd = index2;
    for (x2 = 0; x2 <= radialSegments; x2++) {
      var u2 = x2 / radialSegments;
      var theta = u2 * thetaLength + thetaStart;
      var cosTheta = Math.cos(theta);
      var sinTheta = Math.sin(theta);
      vertex.x = radius * sinTheta;
      vertex.y = halfHeight * sign;
      vertex.z = radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z);
      normals.push(0, sign, 0);
      uv.x = cosTheta * 0.5 + 0.5;
      uv.y = sinTheta * 0.5 * sign + 0.5;
      uvs.push(uv.x, uv.y);
      index2++;
    }
    for (x2 = 0; x2 < radialSegments; x2++) {
      var c2 = centerIndexStart + x2;
      var i2 = centerIndexEnd + x2;
      if (top === true) {
        indices.push(i2, i2 + 1, c2);
      } else {
        indices.push(i2 + 1, i2, c2);
      }
      groupCount += 3;
    }
    scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
    groupStart += groupCount;
  }
}
CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
  this.type = "ConeGeometry";
  this.parameters = {
    radius,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  };
}
ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
ConeGeometry.prototype.constructor = ConeGeometry;
function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
  this.type = "ConeBufferGeometry";
  this.parameters = {
    radius,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  };
}
ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
function CircleGeometry(radius, segments, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = "CircleGeometry";
  this.parameters = {
    radius,
    segments,
    thetaStart,
    thetaLength
  };
  this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
  this.mergeVertices();
}
CircleGeometry.prototype = Object.create(Geometry.prototype);
CircleGeometry.prototype.constructor = CircleGeometry;
function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = "CircleBufferGeometry";
  this.parameters = {
    radius,
    segments,
    thetaStart,
    thetaLength
  };
  radius = radius || 1;
  segments = segments !== void 0 ? Math.max(3, segments) : 8;
  thetaStart = thetaStart !== void 0 ? thetaStart : 0;
  thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var i2, s2;
  var vertex = new Vector3();
  var uv = new Vector2();
  vertices.push(0, 0, 0);
  normals.push(0, 0, 1);
  uvs.push(0.5, 0.5);
  for (s2 = 0, i2 = 3; s2 <= segments; s2++, i2 += 3) {
    var segment = thetaStart + s2 / segments * thetaLength;
    vertex.x = radius * Math.cos(segment);
    vertex.y = radius * Math.sin(segment);
    vertices.push(vertex.x, vertex.y, vertex.z);
    normals.push(0, 0, 1);
    uv.x = (vertices[i2] / radius + 1) / 2;
    uv.y = (vertices[i2 + 1] / radius + 1) / 2;
    uvs.push(uv.x, uv.y);
  }
  for (i2 = 1; i2 <= segments; i2++) {
    indices.push(i2, i2 + 1, 0);
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
var Geometries = /* @__PURE__ */ Object.freeze({
  WireframeGeometry,
  ParametricGeometry,
  ParametricBufferGeometry,
  TetrahedronGeometry,
  TetrahedronBufferGeometry,
  OctahedronGeometry,
  OctahedronBufferGeometry,
  IcosahedronGeometry,
  IcosahedronBufferGeometry,
  DodecahedronGeometry,
  DodecahedronBufferGeometry,
  PolyhedronGeometry,
  PolyhedronBufferGeometry,
  TubeGeometry,
  TubeBufferGeometry,
  TorusKnotGeometry,
  TorusKnotBufferGeometry,
  TorusGeometry,
  TorusBufferGeometry,
  TextGeometry,
  TextBufferGeometry,
  SphereGeometry,
  SphereBufferGeometry,
  RingGeometry,
  RingBufferGeometry,
  PlaneGeometry,
  PlaneBufferGeometry,
  LatheGeometry,
  LatheBufferGeometry,
  ShapeGeometry,
  ShapeBufferGeometry,
  ExtrudeGeometry,
  ExtrudeBufferGeometry,
  EdgesGeometry,
  ConeGeometry,
  ConeBufferGeometry,
  CylinderGeometry,
  CylinderBufferGeometry,
  CircleGeometry,
  CircleBufferGeometry,
  BoxGeometry,
  BoxBufferGeometry
});
function ShadowMaterial(parameters) {
  Material.call(this);
  this.type = "ShadowMaterial";
  this.color = new Color(0);
  this.transparent = true;
  this.setValues(parameters);
}
ShadowMaterial.prototype = Object.create(Material.prototype);
ShadowMaterial.prototype.constructor = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = true;
ShadowMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  return this;
};
function RawShaderMaterial(parameters) {
  ShaderMaterial.call(this, parameters);
  this.type = "RawShaderMaterial";
}
RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
RawShaderMaterial.prototype.constructor = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = true;
function MeshStandardMaterial(parameters) {
  Material.call(this);
  this.defines = { "STANDARD": "" };
  this.type = "MeshStandardMaterial";
  this.color = new Color(16777215);
  this.roughness = 0.5;
  this.metalness = 0.5;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.roughnessMap = null;
  this.metalnessMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.envMapIntensity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.defines = { "STANDARD": "" };
  this.color.copy(source.color);
  this.roughness = source.roughness;
  this.metalness = source.metalness;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.roughnessMap = source.roughnessMap;
  this.metalnessMap = source.metalnessMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.envMapIntensity = source.envMapIntensity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
function MeshPhysicalMaterial(parameters) {
  MeshStandardMaterial.call(this);
  this.defines = { "PHYSICAL": "" };
  this.type = "MeshPhysicalMaterial";
  this.reflectivity = 0.5;
  this.clearCoat = 0;
  this.clearCoatRoughness = 0;
  this.setValues(parameters);
}
MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
MeshPhysicalMaterial.prototype.copy = function(source) {
  MeshStandardMaterial.prototype.copy.call(this, source);
  this.defines = { "PHYSICAL": "" };
  this.reflectivity = source.reflectivity;
  this.clearCoat = source.clearCoat;
  this.clearCoatRoughness = source.clearCoatRoughness;
  return this;
};
function MeshPhongMaterial(parameters) {
  Material.call(this);
  this.type = "MeshPhongMaterial";
  this.color = new Color(16777215);
  this.specular = new Color(1118481);
  this.shininess = 30;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
MeshPhongMaterial.prototype = Object.create(Material.prototype);
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
MeshPhongMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.specular.copy(source.specular);
  this.shininess = source.shininess;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
function MeshToonMaterial(parameters) {
  MeshPhongMaterial.call(this);
  this.defines = { "TOON": "" };
  this.type = "MeshToonMaterial";
  this.gradientMap = null;
  this.setValues(parameters);
}
MeshToonMaterial.prototype = Object.create(MeshPhongMaterial.prototype);
MeshToonMaterial.prototype.constructor = MeshToonMaterial;
MeshToonMaterial.prototype.isMeshToonMaterial = true;
MeshToonMaterial.prototype.copy = function(source) {
  MeshPhongMaterial.prototype.copy.call(this, source);
  this.gradientMap = source.gradientMap;
  return this;
};
function MeshNormalMaterial(parameters) {
  Material.call(this);
  this.type = "MeshNormalMaterial";
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
MeshNormalMaterial.prototype = Object.create(Material.prototype);
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
MeshNormalMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
function MeshLambertMaterial(parameters) {
  Material.call(this);
  this.type = "MeshLambertMaterial";
  this.color = new Color(16777215);
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
MeshLambertMaterial.prototype = Object.create(Material.prototype);
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
MeshLambertMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
function MeshMatcapMaterial(parameters) {
  Material.call(this);
  this.defines = { "MATCAP": "" };
  this.type = "MeshMatcapMaterial";
  this.color = new Color(16777215);
  this.matcap = null;
  this.map = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.alphaMap = null;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.lights = false;
  this.setValues(parameters);
}
MeshMatcapMaterial.prototype = Object.create(Material.prototype);
MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
MeshMatcapMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.defines = { "MATCAP": "" };
  this.color.copy(source.color);
  this.matcap = source.matcap;
  this.map = source.map;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.alphaMap = source.alphaMap;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
function LineDashedMaterial(parameters) {
  LineBasicMaterial.call(this);
  this.type = "LineDashedMaterial";
  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.setValues(parameters);
}
LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
LineDashedMaterial.prototype.constructor = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;
LineDashedMaterial.prototype.copy = function(source) {
  LineBasicMaterial.prototype.copy.call(this, source);
  this.scale = source.scale;
  this.dashSize = source.dashSize;
  this.gapSize = source.gapSize;
  return this;
};
var Materials = /* @__PURE__ */ Object.freeze({
  ShadowMaterial,
  SpriteMaterial,
  RawShaderMaterial,
  ShaderMaterial,
  PointsMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshPhongMaterial,
  MeshToonMaterial,
  MeshNormalMaterial,
  MeshLambertMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshBasicMaterial,
  MeshMatcapMaterial,
  LineDashedMaterial,
  LineBasicMaterial,
  Material
});
var AnimationUtils = {
  arraySlice: function(array, from, to) {
    if (AnimationUtils.isTypedArray(array)) {
      return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
    }
    return array.slice(from, to);
  },
  convertArray: function(array, type, forceClone) {
    if (!array || !forceClone && array.constructor === type)
      return array;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array);
    }
    return Array.prototype.slice.call(array);
  },
  isTypedArray: function(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  getKeyframeOrder: function(times) {
    function compareTime(i3, j) {
      return times[i3] - times[j];
    }
    var n2 = times.length;
    var result = new Array(n2);
    for (var i2 = 0; i2 !== n2; ++i2)
      result[i2] = i2;
    result.sort(compareTime);
    return result;
  },
  sortedArray: function(values, stride, order) {
    var nValues = values.length;
    var result = new values.constructor(nValues);
    for (var i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
      var srcOffset = order[i2] * stride;
      for (var j = 0; j !== stride; ++j) {
        result[dstOffset++] = values[srcOffset + j];
      }
    }
    return result;
  },
  flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
    var i2 = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i2++];
    }
    if (key === void 0)
      return;
    var value = key[valuePropertyName];
    if (value === void 0)
      return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push.apply(values, value);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    }
  }
};
function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  this.parameterPositions = parameterPositions;
  this._cachedIndex = 0;
  this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
  this.sampleValues = sampleValues;
  this.valueSize = sampleSize;
}
Object.assign(Interpolant.prototype, {
  evaluate: function(t2) {
    var pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        var right;
        linear_scan: {
          forward_scan:
            if (!(t2 < t1)) {
              for (var giveUpAt = i1 + 2; ; ) {
                if (t1 === void 0) {
                  if (t2 < t0)
                    break forward_scan;
                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.afterEnd_(i1 - 1, t2, t0);
                }
                if (i1 === giveUpAt)
                  break;
                t0 = t1;
                t1 = pp[++i1];
                if (t2 < t1) {
                  break seek;
                }
              }
              right = pp.length;
              break linear_scan;
            }
          if (!(t2 >= t0)) {
            var t1global = pp[1];
            if (t2 < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (var giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t2, t1);
              }
              if (i1 === giveUpAt)
                break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t2 >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          var mid = i1 + right >>> 1;
          if (t2 < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t2, t1);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t2);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t2, t1);
  },
  settings: null,
  DefaultSettings_: {},
  getSettings_: function() {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function(index2) {
    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset2 = index2 * stride;
    for (var i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset2 + i2];
    }
    return result;
  },
  interpolate_: function() {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function() {
  }
});
//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(Interpolant.prototype, {
  beforeStart_: Interpolant.prototype.copySampleValue_,
  afterEnd_: Interpolant.prototype.copySampleValue_
});
function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  this._weightPrev = -0;
  this._offsetPrev = -0;
  this._weightNext = -0;
  this._offsetNext = -0;
}
CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: CubicInterpolant,
  DefaultSettings_: {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  },
  intervalChanged_: function(i1, t0, t1) {
    var pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    var halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  },
  interpolate_: function(i1, t0, t2, t1) {
    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p2 = (t2 - t0) / (t1 - t0), pp = p2 * p2, ppp = pp * p2;
    var sP = -wP * ppp + 2 * wP * pp - wP * p2;
    var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p2 + 1;
    var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p2;
    var sN = wN * ppp - wN * pp;
    for (var i2 = 0; i2 !== stride; ++i2) {
      result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
    }
    return result;
  }
});
function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: LinearInterpolant,
  interpolate_: function(i1, t0, t2, t1) {
    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (var i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
    }
    return result;
  }
});
function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: DiscreteInterpolant,
  interpolate_: function(i1) {
    return this.copySampleValue_(i1 - 1);
  }
});
function KeyframeTrack(name, times, values, interpolation) {
  if (name === void 0)
    throw new Error("THREE.KeyframeTrack: track name is undefined");
  if (times === void 0 || times.length === 0)
    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
  this.name = name;
  this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
  this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
  this.setInterpolation(interpolation || this.DefaultInterpolation);
}
Object.assign(KeyframeTrack, {
  toJSON: function(track) {
    var trackType = track.constructor;
    var json;
    if (trackType.toJSON !== void 0) {
      json = trackType.toJSON(track);
    } else {
      json = {
        "name": track.name,
        "times": AnimationUtils.convertArray(track.times, Array),
        "values": AnimationUtils.convertArray(track.values, Array)
      };
      var interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
});
Object.assign(KeyframeTrack.prototype, {
  constructor: KeyframeTrack,
  TimeBufferType: Float32Array,
  ValueBufferType: Float32Array,
  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodDiscrete: function(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodLinear: function(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodSmooth: function(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  setInterpolation: function(interpolation) {
    var factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  },
  getInterpolation: function() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  },
  getValueSize: function() {
    return this.values.length / this.times.length;
  },
  shift: function(timeOffset) {
    if (timeOffset !== 0) {
      var times = this.times;
      for (var i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
        times[i2] += timeOffset;
      }
    }
    return this;
  },
  scale: function(timeScale) {
    if (timeScale !== 1) {
      var times = this.times;
      for (var i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
        times[i2] *= timeScale;
      }
    }
    return this;
  },
  trim: function(startTime, endTime) {
    var times = this.times, nKeys = times.length, from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to)
        to = Math.max(to, 1), from = to - 1;
      var stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
    }
    return this;
  },
  validate: function() {
    var valid = true;
    var valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    var times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    var prevTime = null;
    for (var i2 = 0; i2 !== nKeys; i2++) {
      var currTime = times[i2];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (AnimationUtils.isTypedArray(values)) {
        for (var i2 = 0, n2 = values.length; i2 !== n2; ++i2) {
          var value = values[i2];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  },
  optimize: function() {
    var times = this.times, values = this.values, stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, writeIndex = 1, lastIndex = times.length - 1;
    for (var i2 = 1; i2 < lastIndex; ++i2) {
      var keep = false;
      var time = times[i2];
      var timeNext = times[i2 + 1];
      if (time !== timeNext && (i2 !== 1 || time !== time[0])) {
        if (!smoothInterpolation) {
          var offset2 = i2 * stride, offsetP = offset2 - stride, offsetN = offset2 + stride;
          for (var j = 0; j !== stride; ++j) {
            var value = values[offset2 + j];
            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i2 !== writeIndex) {
          times[writeIndex] = times[i2];
          var readOffset = i2 * stride, writeOffset = writeIndex * stride;
          for (var j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    }
    return this;
  },
  clone: function() {
    var times = AnimationUtils.arraySlice(this.times, 0);
    var values = AnimationUtils.arraySlice(this.values, 0);
    var TypedKeyframeTrack = this.constructor;
    var track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
});
function BooleanKeyframeTrack(name, times, values) {
  KeyframeTrack.call(this, name, times, values);
}
BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: BooleanKeyframeTrack,
  ValueTypeName: "bool",
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
});
function ColorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: ColorKeyframeTrack,
  ValueTypeName: "color"
});
function NumberKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: NumberKeyframeTrack,
  ValueTypeName: "number"
});
function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: QuaternionLinearInterpolant,
  interpolate_: function(i1, t0, t2, t1) {
    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset2 = i1 * stride, alpha = (t2 - t0) / (t1 - t0);
    for (var end = offset2 + stride; offset2 !== end; offset2 += 4) {
      Quaternion.slerpFlat(result, 0, values, offset2 - stride, values, offset2, alpha);
    }
    return result;
  }
});
function QuaternionKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: QuaternionKeyframeTrack,
  ValueTypeName: "quaternion",
  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodLinear: function(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodSmooth: void 0
});
function StringKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: StringKeyframeTrack,
  ValueTypeName: "string",
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
});
function VectorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: VectorKeyframeTrack,
  ValueTypeName: "vector"
});
function AnimationClip(name, duration, tracks) {
  this.name = name;
  this.tracks = tracks;
  this.duration = duration !== void 0 ? duration : -1;
  this.uuid = _Math.generateUUID();
  if (this.duration < 0) {
    this.resetDuration();
  }
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  var trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    var times = [], values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
Object.assign(AnimationClip, {
  parse: function(json) {
    var tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (var i2 = 0, n2 = jsonTracks.length; i2 !== n2; ++i2) {
      tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
    }
    return new AnimationClip(json.name, json.duration, tracks);
  },
  toJSON: function(clip) {
    var tracks = [], clipTracks = clip.tracks;
    var json = {
      "name": clip.name,
      "duration": clip.duration,
      "tracks": tracks,
      "uuid": clip.uuid
    };
    for (var i2 = 0, n2 = clipTracks.length; i2 !== n2; ++i2) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
    }
    return json;
  },
  CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
    var numMorphTargets = morphTargetSequence.length;
    var tracks = [];
    for (var i2 = 0; i2 < numMorphTargets; i2++) {
      var times = [];
      var values = [];
      times.push((i2 + numMorphTargets - 1) % numMorphTargets, i2, (i2 + 1) % numMorphTargets);
      values.push(0, 1, 0);
      var order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i2].name + "]", times, values).scale(1 / fps));
    }
    return new AnimationClip(name, -1, tracks);
  },
  findByName: function(objectOrClipArray, name) {
    var clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      var o2 = objectOrClipArray;
      clipArray = o2.geometry && o2.geometry.animations || o2.animations;
    }
    for (var i2 = 0; i2 < clipArray.length; i2++) {
      if (clipArray[i2].name === name) {
        return clipArray[i2];
      }
    }
    return null;
  },
  CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
    var animationToMorphTargets = {};
    var pattern = /^([\w-]*?)([\d]+)$/;
    for (var i2 = 0, il = morphTargets.length; i2 < il; i2++) {
      var morphTarget = morphTargets[i2];
      var parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        var name = parts[1];
        var animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    var clips = [];
    for (var name in animationToMorphTargets) {
      clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  },
  parseAnimation: function(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    var addNonemptyTrack = function(trackType, trackName, animationKeys2, propertyName, destTracks) {
      if (animationKeys2.length !== 0) {
        var times2 = [];
        var values2 = [];
        AnimationUtils.flattenJSON(animationKeys2, times2, values2, propertyName);
        if (times2.length !== 0) {
          destTracks.push(new trackType(trackName, times2, values2));
        }
      }
    };
    var tracks = [];
    var clipName = animation.name || "default";
    var duration = animation.length || -1;
    var fps = animation.fps || 30;
    var hierarchyTracks = animation.hierarchy || [];
    for (var h2 = 0; h2 < hierarchyTracks.length; h2++) {
      var animationKeys = hierarchyTracks[h2].keys;
      if (!animationKeys || animationKeys.length === 0)
        continue;
      if (animationKeys[0].morphTargets) {
        var morphTargetNames = {};
        for (var k2 = 0; k2 < animationKeys.length; k2++) {
          if (animationKeys[k2].morphTargets) {
            for (var m2 = 0; m2 < animationKeys[k2].morphTargets.length; m2++) {
              morphTargetNames[animationKeys[k2].morphTargets[m2]] = -1;
            }
          }
        }
        for (var morphTargetName in morphTargetNames) {
          var times = [];
          var values = [];
          for (var m2 = 0; m2 !== animationKeys[k2].morphTargets.length; ++m2) {
            var animationKey = animationKeys[k2];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * (fps || 1);
      } else {
        var boneName = ".bones[" + bones[h2].name + "]";
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    var clip = new AnimationClip(clipName, duration, tracks);
    return clip;
  }
});
Object.assign(AnimationClip.prototype, {
  resetDuration: function() {
    var tracks = this.tracks, duration = 0;
    for (var i2 = 0, n2 = tracks.length; i2 !== n2; ++i2) {
      var track = this.tracks[i2];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  },
  trim: function() {
    for (var i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].trim(0, this.duration);
    }
    return this;
  },
  validate: function() {
    var valid = true;
    for (var i2 = 0; i2 < this.tracks.length; i2++) {
      valid = valid && this.tracks[i2].validate();
    }
    return valid;
  },
  optimize: function() {
    for (var i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].optimize();
    }
    return this;
  },
  clone: function() {
    var tracks = [];
    for (var i2 = 0; i2 < this.tracks.length; i2++) {
      tracks.push(this.tracks[i2].clone());
    }
    return new AnimationClip(this.name, this.duration, tracks);
  }
});
var Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false)
      return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false)
      return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
function LoadingManager(onLoad, onProgress, onError) {
  var scope = this;
  var isLoading = false;
  var itemsLoaded = 0;
  var itemsTotal = 0;
  var urlModifier = void 0;
  this.onStart = void 0;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;
  this.itemStart = function(url) {
    itemsTotal++;
    if (isLoading === false) {
      if (scope.onStart !== void 0) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }
    isLoading = true;
  };
  this.itemEnd = function(url) {
    itemsLoaded++;
    if (scope.onProgress !== void 0) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }
    if (itemsLoaded === itemsTotal) {
      isLoading = false;
      if (scope.onLoad !== void 0) {
        scope.onLoad();
      }
    }
  };
  this.itemError = function(url) {
    if (scope.onError !== void 0) {
      scope.onError(url);
    }
  };
  this.resolveURL = function(url) {
    if (urlModifier) {
      return urlModifier(url);
    }
    return url;
  };
  this.setURLModifier = function(transform2) {
    urlModifier = transform2;
    return this;
  };
}
var DefaultLoadingManager = new LoadingManager();
var loading = {};
function FileLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(FileLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    var scope = this;
    var cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    var dataUriRegexResult = url.match(dataUriRegex);
    if (dataUriRegexResult) {
      var mimeType = dataUriRegexResult[1];
      var isBase64 = !!dataUriRegexResult[2];
      var data = dataUriRegexResult[3];
      data = decodeURIComponent(data);
      if (isBase64)
        data = atob(data);
      try {
        var response;
        var responseType = (this.responseType || "").toLowerCase();
        switch (responseType) {
          case "arraybuffer":
          case "blob":
            var view2 = new Uint8Array(data.length);
            for (var i2 = 0; i2 < data.length; i2++) {
              view2[i2] = data.charCodeAt(i2);
            }
            if (responseType === "blob") {
              response = new Blob([view2.buffer], { type: mimeType });
            } else {
              response = view2.buffer;
            }
            break;
          case "document":
            var parser = new DOMParser();
            response = parser.parseFromString(data, mimeType);
            break;
          case "json":
            response = JSON.parse(data);
            break;
          default:
            response = data;
            break;
        }
        setTimeout(function() {
          if (onLoad)
            onLoad(response);
          scope.manager.itemEnd(url);
        }, 0);
      } catch (error) {
        setTimeout(function() {
          if (onError)
            onError(error);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, 0);
      }
    } else {
      loading[url] = [];
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      var request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.addEventListener("load", function(event) {
        var response2 = this.response;
        Cache.add(url, response2);
        var callbacks = loading[url];
        delete loading[url];
        if (this.status === 200 || this.status === 0) {
          if (this.status === 0)
            console.warn("THREE.FileLoader: HTTP Status 0 received.");
          for (var i3 = 0, il = callbacks.length; i3 < il; i3++) {
            var callback = callbacks[i3];
            if (callback.onLoad)
              callback.onLoad(response2);
          }
          scope.manager.itemEnd(url);
        } else {
          for (var i3 = 0, il = callbacks.length; i3 < il; i3++) {
            var callback = callbacks[i3];
            if (callback.onError)
              callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
      }, false);
      request.addEventListener("progress", function(event) {
        var callbacks = loading[url];
        for (var i3 = 0, il = callbacks.length; i3 < il; i3++) {
          var callback = callbacks[i3];
          if (callback.onProgress)
            callback.onProgress(event);
        }
      }, false);
      request.addEventListener("error", function(event) {
        var callbacks = loading[url];
        delete loading[url];
        for (var i3 = 0, il = callbacks.length; i3 < il; i3++) {
          var callback = callbacks[i3];
          if (callback.onError)
            callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      request.addEventListener("abort", function(event) {
        var callbacks = loading[url];
        delete loading[url];
        for (var i3 = 0, il = callbacks.length; i3 < il; i3++) {
          var callback = callbacks[i3];
          if (callback.onError)
            callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      if (this.responseType !== void 0)
        request.responseType = this.responseType;
      if (this.withCredentials !== void 0)
        request.withCredentials = this.withCredentials;
      if (request.overrideMimeType)
        request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (var header in this.requestHeader) {
        request.setRequestHeader(header, this.requestHeader[header]);
      }
      request.send(null);
    }
    scope.manager.itemStart(url);
    return request;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  },
  setResponseType: function(value) {
    this.responseType = value;
    return this;
  },
  setWithCredentials: function(value) {
    this.withCredentials = value;
    return this;
  },
  setMimeType: function(value) {
    this.mimeType = value;
    return this;
  },
  setRequestHeader: function(value) {
    this.requestHeader = value;
    return this;
  }
});
function AnimationLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(AnimationLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.load(url, function(text2) {
      onLoad(scope.parse(JSON.parse(text2)));
    }, onProgress, onError);
  },
  parse: function(json) {
    var animations = [];
    for (var i2 = 0; i2 < json.length; i2++) {
      var clip = AnimationClip.parse(json[i2]);
      animations.push(clip);
    }
    return animations;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
function CompressedTextureLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this._parser = null;
}
Object.assign(CompressedTextureLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var images2 = [];
    var texture = new CompressedTexture();
    texture.image = images2;
    var loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    function loadTexture(i3) {
      loader.load(url[i3], function(buffer) {
        var texDatas = scope._parser(buffer, true);
        images2[i3] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;
        if (loaded === 6) {
          if (texDatas.mipmapCount === 1)
            texture.minFilter = LinearFilter;
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, onProgress, onError);
    }
    if (Array.isArray(url)) {
      var loaded = 0;
      for (var i2 = 0, il = url.length; i2 < il; ++i2) {
        loadTexture(i2);
      }
    } else {
      loader.load(url, function(buffer) {
        var texDatas = scope._parser(buffer, true);
        if (texDatas.isCubemap) {
          var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
          for (var f2 = 0; f2 < faces; f2++) {
            images2[f2] = { mipmaps: [] };
            for (var i3 = 0; i3 < texDatas.mipmapCount; i3++) {
              images2[f2].mipmaps.push(texDatas.mipmaps[f2 * texDatas.mipmapCount + i3]);
              images2[f2].format = texDatas.format;
              images2[f2].width = texDatas.width;
              images2[f2].height = texDatas.height;
            }
          }
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }
        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad)
          onLoad(texture);
      }, onProgress, onError);
    }
    return texture;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
function DataTextureLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this._parser = null;
}
Object.assign(DataTextureLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var texture = new DataTexture();
    var loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.load(url, function(buffer) {
      var texData = scope._parser(buffer);
      if (!texData)
        return;
      if (texData.image !== void 0) {
        texture.image = texData.image;
      } else if (texData.data !== void 0) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }
      texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearMipMapLinearFilter;
      texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
      if (texData.format !== void 0) {
        texture.format = texData.format;
      }
      if (texData.type !== void 0) {
        texture.type = texData.type;
      }
      if (texData.mipmaps !== void 0) {
        texture.mipmaps = texData.mipmaps;
      }
      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }
      texture.needsUpdate = true;
      if (onLoad)
        onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
function ImageLoader$1(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(ImageLoader$1.prototype, {
  crossOrigin: "anonymous",
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    var scope = this;
    var cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    var image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function onImageLoad() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
      Cache.add(url, this);
      if (onLoad)
        onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
      if (onError)
        onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.substr(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0)
        image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  },
  setCrossOrigin: function(value) {
    this.crossOrigin = value;
    return this;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
function CubeTextureLoader$1(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(CubeTextureLoader$1.prototype, {
  crossOrigin: "anonymous",
  load: function(urls, onLoad, onProgress, onError) {
    var texture = new CubeTexture();
    var loader = new ImageLoader$1(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    var loaded = 0;
    function loadTexture(i3) {
      loader.load(urls[i3], function(image) {
        texture.images[i3] = image;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, void 0, onError);
    }
    for (var i2 = 0; i2 < urls.length; ++i2) {
      loadTexture(i2);
    }
    return texture;
  },
  setCrossOrigin: function(value) {
    this.crossOrigin = value;
    return this;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
function TextureLoader$1(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(TextureLoader$1.prototype, {
  crossOrigin: "anonymous",
  load: function(url, onLoad, onProgress, onError) {
    var texture = new Texture();
    var loader = new ImageLoader$1(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      var isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? RGBFormat : RGBAFormat;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  },
  setCrossOrigin: function(value) {
    this.crossOrigin = value;
    return this;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
function Curve() {
  this.type = "Curve";
  this.arcLengthDivisions = 200;
}
Object.assign(Curve.prototype, {
  getPoint: function() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  },
  getPointAt: function(u2, optionalTarget) {
    var t2 = this.getUtoTmapping(u2);
    return this.getPoint(t2, optionalTarget);
  },
  getPoints: function(divisions) {
    if (divisions === void 0)
      divisions = 5;
    var points = [];
    for (var d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPoint(d2 / divisions));
    }
    return points;
  },
  getSpacedPoints: function(divisions) {
    if (divisions === void 0)
      divisions = 5;
    var points = [];
    for (var d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPointAt(d2 / divisions));
    }
    return points;
  },
  getLength: function() {
    var lengths = this.getLengths();
    return lengths[lengths.length - 1];
  },
  getLengths: function(divisions) {
    if (divisions === void 0)
      divisions = this.arcLengthDivisions;
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    var cache = [];
    var current, last = this.getPoint(0);
    var p2, sum = 0;
    cache.push(0);
    for (p2 = 1; p2 <= divisions; p2++) {
      current = this.getPoint(p2 / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache;
    return cache;
  },
  updateArcLengths: function() {
    this.needsUpdate = true;
    this.getLengths();
  },
  getUtoTmapping: function(u2, distance) {
    var arcLengths = this.getLengths();
    var i2 = 0, il = arcLengths.length;
    var targetArcLength;
    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u2 * arcLengths[il - 1];
    }
    var low = 0, high = il - 1, comparison;
    while (low <= high) {
      i2 = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i2] - targetArcLength;
      if (comparison < 0) {
        low = i2 + 1;
      } else if (comparison > 0) {
        high = i2 - 1;
      } else {
        high = i2;
        break;
      }
    }
    i2 = high;
    if (arcLengths[i2] === targetArcLength) {
      return i2 / (il - 1);
    }
    var lengthBefore = arcLengths[i2];
    var lengthAfter = arcLengths[i2 + 1];
    var segmentLength = lengthAfter - lengthBefore;
    var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    var t2 = (i2 + segmentFraction) / (il - 1);
    return t2;
  },
  getTangent: function(t2) {
    var delta = 1e-4;
    var t1 = t2 - delta;
    var t22 = t2 + delta;
    if (t1 < 0)
      t1 = 0;
    if (t22 > 1)
      t22 = 1;
    var pt1 = this.getPoint(t1);
    var pt2 = this.getPoint(t22);
    var vec = pt2.clone().sub(pt1);
    return vec.normalize();
  },
  getTangentAt: function(u2) {
    var t2 = this.getUtoTmapping(u2);
    return this.getTangent(t2);
  },
  computeFrenetFrames: function(segments, closed) {
    var normal = new Vector3();
    var tangents = [];
    var normals = [];
    var binormals = [];
    var vec = new Vector3();
    var mat = new Matrix4();
    var i2, u2, theta;
    for (i2 = 0; i2 <= segments; i2++) {
      u2 = i2 / segments;
      tangents[i2] = this.getTangentAt(u2);
      tangents[i2].normalize();
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    var min = Number.MAX_VALUE;
    var tx = Math.abs(tangents[0].x);
    var ty = Math.abs(tangents[0].y);
    var tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (i2 = 1; i2 <= segments; i2++) {
      normals[i2] = normals[i2 - 1].clone();
      binormals[i2] = binormals[i2 - 1].clone();
      vec.crossVectors(tangents[i2 - 1], tangents[i2]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        theta = Math.acos(_Math.clamp(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
        normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i2].crossVectors(tangents[i2], normals[i2]);
    }
    if (closed === true) {
      theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (i2 = 1; i2 <= segments; i2++) {
        normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
        binormals[i2].crossVectors(tangents[i2], normals[i2]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  },
  toJSON: function() {
    var data = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  },
  fromJSON: function(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
});
function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
  Curve.call(this);
  this.type = "EllipseCurve";
  this.aX = aX || 0;
  this.aY = aY || 0;
  this.xRadius = xRadius || 1;
  this.yRadius = yRadius || 1;
  this.aStartAngle = aStartAngle || 0;
  this.aEndAngle = aEndAngle || 2 * Math.PI;
  this.aClockwise = aClockwise || false;
  this.aRotation = aRotation || 0;
}
EllipseCurve.prototype = Object.create(Curve.prototype);
EllipseCurve.prototype.constructor = EllipseCurve;
EllipseCurve.prototype.isEllipseCurve = true;
EllipseCurve.prototype.getPoint = function(t2, optionalTarget) {
  var point = optionalTarget || new Vector2();
  var twoPi = Math.PI * 2;
  var deltaAngle = this.aEndAngle - this.aStartAngle;
  var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
  while (deltaAngle < 0)
    deltaAngle += twoPi;
  while (deltaAngle > twoPi)
    deltaAngle -= twoPi;
  if (deltaAngle < Number.EPSILON) {
    if (samePoints) {
      deltaAngle = 0;
    } else {
      deltaAngle = twoPi;
    }
  }
  if (this.aClockwise === true && !samePoints) {
    if (deltaAngle === twoPi) {
      deltaAngle = -twoPi;
    } else {
      deltaAngle = deltaAngle - twoPi;
    }
  }
  var angle = this.aStartAngle + t2 * deltaAngle;
  var x2 = this.aX + this.xRadius * Math.cos(angle);
  var y = this.aY + this.yRadius * Math.sin(angle);
  if (this.aRotation !== 0) {
    var cos = Math.cos(this.aRotation);
    var sin = Math.sin(this.aRotation);
    var tx = x2 - this.aX;
    var ty = y - this.aY;
    x2 = tx * cos - ty * sin + this.aX;
    y = tx * sin + ty * cos + this.aY;
  }
  return point.set(x2, y);
};
EllipseCurve.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.aX = source.aX;
  this.aY = source.aY;
  this.xRadius = source.xRadius;
  this.yRadius = source.yRadius;
  this.aStartAngle = source.aStartAngle;
  this.aEndAngle = source.aEndAngle;
  this.aClockwise = source.aClockwise;
  this.aRotation = source.aRotation;
  return this;
};
EllipseCurve.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.aX = this.aX;
  data.aY = this.aY;
  data.xRadius = this.xRadius;
  data.yRadius = this.yRadius;
  data.aStartAngle = this.aStartAngle;
  data.aEndAngle = this.aEndAngle;
  data.aClockwise = this.aClockwise;
  data.aRotation = this.aRotation;
  return data;
};
EllipseCurve.prototype.fromJSON = function(json) {
  Curve.prototype.fromJSON.call(this, json);
  this.aX = json.aX;
  this.aY = json.aY;
  this.xRadius = json.xRadius;
  this.yRadius = json.yRadius;
  this.aStartAngle = json.aStartAngle;
  this.aEndAngle = json.aEndAngle;
  this.aClockwise = json.aClockwise;
  this.aRotation = json.aRotation;
  return this;
};
function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
  EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
  this.type = "ArcCurve";
}
ArcCurve.prototype = Object.create(EllipseCurve.prototype);
ArcCurve.prototype.constructor = ArcCurve;
ArcCurve.prototype.isArcCurve = true;
function CubicPoly() {
  var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function(t2) {
      var t22 = t2 * t2;
      var t3 = t22 * t2;
      return c0 + c1 * t2 + c2 * t22 + c3 * t3;
    }
  };
}
var tmp = new Vector3();
var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
function CatmullRomCurve3(points, closed, curveType, tension) {
  Curve.call(this);
  this.type = "CatmullRomCurve3";
  this.points = points || [];
  this.closed = closed || false;
  this.curveType = curveType || "centripetal";
  this.tension = tension || 0.5;
}
CatmullRomCurve3.prototype = Object.create(Curve.prototype);
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
CatmullRomCurve3.prototype.getPoint = function(t2, optionalTarget) {
  var point = optionalTarget || new Vector3();
  var points = this.points;
  var l2 = points.length;
  var p2 = (l2 - (this.closed ? 0 : 1)) * t2;
  var intPoint = Math.floor(p2);
  var weight = p2 - intPoint;
  if (this.closed) {
    intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l2) + 1) * l2;
  } else if (weight === 0 && intPoint === l2 - 1) {
    intPoint = l2 - 2;
    weight = 1;
  }
  var p0, p1, p22, p3;
  if (this.closed || intPoint > 0) {
    p0 = points[(intPoint - 1) % l2];
  } else {
    tmp.subVectors(points[0], points[1]).add(points[0]);
    p0 = tmp;
  }
  p1 = points[intPoint % l2];
  p22 = points[(intPoint + 1) % l2];
  if (this.closed || intPoint + 2 < l2) {
    p3 = points[(intPoint + 2) % l2];
  } else {
    tmp.subVectors(points[l2 - 1], points[l2 - 2]).add(points[l2 - 1]);
    p3 = tmp;
  }
  if (this.curveType === "centripetal" || this.curveType === "chordal") {
    var pow = this.curveType === "chordal" ? 0.5 : 0.25;
    var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
    var dt1 = Math.pow(p1.distanceToSquared(p22), pow);
    var dt2 = Math.pow(p22.distanceToSquared(p3), pow);
    if (dt1 < 1e-4)
      dt1 = 1;
    if (dt0 < 1e-4)
      dt0 = dt1;
    if (dt2 < 1e-4)
      dt2 = dt1;
    px.initNonuniformCatmullRom(p0.x, p1.x, p22.x, p3.x, dt0, dt1, dt2);
    py.initNonuniformCatmullRom(p0.y, p1.y, p22.y, p3.y, dt0, dt1, dt2);
    pz.initNonuniformCatmullRom(p0.z, p1.z, p22.z, p3.z, dt0, dt1, dt2);
  } else if (this.curveType === "catmullrom") {
    px.initCatmullRom(p0.x, p1.x, p22.x, p3.x, this.tension);
    py.initCatmullRom(p0.y, p1.y, p22.y, p3.y, this.tension);
    pz.initCatmullRom(p0.z, p1.z, p22.z, p3.z, this.tension);
  }
  point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
  return point;
};
CatmullRomCurve3.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.points = [];
  for (var i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
    var point = source.points[i2];
    this.points.push(point.clone());
  }
  this.closed = source.closed;
  this.curveType = source.curveType;
  this.tension = source.tension;
  return this;
};
CatmullRomCurve3.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.points = [];
  for (var i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
    var point = this.points[i2];
    data.points.push(point.toArray());
  }
  data.closed = this.closed;
  data.curveType = this.curveType;
  data.tension = this.tension;
  return data;
};
CatmullRomCurve3.prototype.fromJSON = function(json) {
  Curve.prototype.fromJSON.call(this, json);
  this.points = [];
  for (var i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
    var point = json.points[i2];
    this.points.push(new Vector3().fromArray(point));
  }
  this.closed = json.closed;
  this.curveType = json.curveType;
  this.tension = json.tension;
  return this;
};
function CatmullRom(t2, p0, p1, p2, p3) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  var t22 = t2 * t2;
  var t3 = t2 * t22;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t22 + v0 * t2 + p1;
}
function QuadraticBezierP0(t2, p2) {
  var k2 = 1 - t2;
  return k2 * k2 * p2;
}
function QuadraticBezierP1(t2, p2) {
  return 2 * (1 - t2) * t2 * p2;
}
function QuadraticBezierP2(t2, p2) {
  return t2 * t2 * p2;
}
function QuadraticBezier(t2, p0, p1, p2) {
  return QuadraticBezierP0(t2, p0) + QuadraticBezierP1(t2, p1) + QuadraticBezierP2(t2, p2);
}
function CubicBezierP0(t2, p2) {
  var k2 = 1 - t2;
  return k2 * k2 * k2 * p2;
}
function CubicBezierP1(t2, p2) {
  var k2 = 1 - t2;
  return 3 * k2 * k2 * t2 * p2;
}
function CubicBezierP2(t2, p2) {
  return 3 * (1 - t2) * t2 * t2 * p2;
}
function CubicBezierP3(t2, p2) {
  return t2 * t2 * t2 * p2;
}
function CubicBezier(t2, p0, p1, p2, p3) {
  return CubicBezierP0(t2, p0) + CubicBezierP1(t2, p1) + CubicBezierP2(t2, p2) + CubicBezierP3(t2, p3);
}
function CubicBezierCurve(v0, v1, v2, v3) {
  Curve.call(this);
  this.type = "CubicBezierCurve";
  this.v0 = v0 || new Vector2();
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
  this.v3 = v3 || new Vector2();
}
CubicBezierCurve.prototype = Object.create(Curve.prototype);
CubicBezierCurve.prototype.constructor = CubicBezierCurve;
CubicBezierCurve.prototype.isCubicBezierCurve = true;
CubicBezierCurve.prototype.getPoint = function(t2, optionalTarget) {
  var point = optionalTarget || new Vector2();
  var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
  point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y));
  return point;
};
CubicBezierCurve.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  this.v3.copy(source.v3);
  return this;
};
CubicBezierCurve.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  data.v3 = this.v3.toArray();
  return data;
};
CubicBezierCurve.prototype.fromJSON = function(json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  this.v3.fromArray(json.v3);
  return this;
};
function CubicBezierCurve3(v0, v1, v2, v3) {
  Curve.call(this);
  this.type = "CubicBezierCurve3";
  this.v0 = v0 || new Vector3();
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
  this.v3 = v3 || new Vector3();
}
CubicBezierCurve3.prototype = Object.create(Curve.prototype);
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
CubicBezierCurve3.prototype.getPoint = function(t2, optionalTarget) {
  var point = optionalTarget || new Vector3();
  var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
  point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y), CubicBezier(t2, v0.z, v1.z, v2.z, v3.z));
  return point;
};
CubicBezierCurve3.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  this.v3.copy(source.v3);
  return this;
};
CubicBezierCurve3.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  data.v3 = this.v3.toArray();
  return data;
};
CubicBezierCurve3.prototype.fromJSON = function(json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  this.v3.fromArray(json.v3);
  return this;
};
function LineCurve(v1, v2) {
  Curve.call(this);
  this.type = "LineCurve";
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
}
LineCurve.prototype = Object.create(Curve.prototype);
LineCurve.prototype.constructor = LineCurve;
LineCurve.prototype.isLineCurve = true;
LineCurve.prototype.getPoint = function(t2, optionalTarget) {
  var point = optionalTarget || new Vector2();
  if (t2 === 1) {
    point.copy(this.v2);
  } else {
    point.copy(this.v2).sub(this.v1);
    point.multiplyScalar(t2).add(this.v1);
  }
  return point;
};
LineCurve.prototype.getPointAt = function(u2, optionalTarget) {
  return this.getPoint(u2, optionalTarget);
};
LineCurve.prototype.getTangent = function() {
  var tangent = this.v2.clone().sub(this.v1);
  return tangent.normalize();
};
LineCurve.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};
LineCurve.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};
LineCurve.prototype.fromJSON = function(json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};
function LineCurve3(v1, v2) {
  Curve.call(this);
  this.type = "LineCurve3";
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
}
LineCurve3.prototype = Object.create(Curve.prototype);
LineCurve3.prototype.constructor = LineCurve3;
LineCurve3.prototype.isLineCurve3 = true;
LineCurve3.prototype.getPoint = function(t2, optionalTarget) {
  var point = optionalTarget || new Vector3();
  if (t2 === 1) {
    point.copy(this.v2);
  } else {
    point.copy(this.v2).sub(this.v1);
    point.multiplyScalar(t2).add(this.v1);
  }
  return point;
};
LineCurve3.prototype.getPointAt = function(u2, optionalTarget) {
  return this.getPoint(u2, optionalTarget);
};
LineCurve3.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};
LineCurve3.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};
LineCurve3.prototype.fromJSON = function(json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};
function QuadraticBezierCurve(v0, v1, v2) {
  Curve.call(this);
  this.type = "QuadraticBezierCurve";
  this.v0 = v0 || new Vector2();
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
}
QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
QuadraticBezierCurve.prototype.getPoint = function(t2, optionalTarget) {
  var point = optionalTarget || new Vector2();
  var v0 = this.v0, v1 = this.v1, v2 = this.v2;
  point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y));
  return point;
};
QuadraticBezierCurve.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};
QuadraticBezierCurve.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};
QuadraticBezierCurve.prototype.fromJSON = function(json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};
function QuadraticBezierCurve3(v0, v1, v2) {
  Curve.call(this);
  this.type = "QuadraticBezierCurve3";
  this.v0 = v0 || new Vector3();
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
}
QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
QuadraticBezierCurve3.prototype.getPoint = function(t2, optionalTarget) {
  var point = optionalTarget || new Vector3();
  var v0 = this.v0, v1 = this.v1, v2 = this.v2;
  point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y), QuadraticBezier(t2, v0.z, v1.z, v2.z));
  return point;
};
QuadraticBezierCurve3.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};
QuadraticBezierCurve3.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};
QuadraticBezierCurve3.prototype.fromJSON = function(json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};
function SplineCurve(points) {
  Curve.call(this);
  this.type = "SplineCurve";
  this.points = points || [];
}
SplineCurve.prototype = Object.create(Curve.prototype);
SplineCurve.prototype.constructor = SplineCurve;
SplineCurve.prototype.isSplineCurve = true;
SplineCurve.prototype.getPoint = function(t2, optionalTarget) {
  var point = optionalTarget || new Vector2();
  var points = this.points;
  var p2 = (points.length - 1) * t2;
  var intPoint = Math.floor(p2);
  var weight = p2 - intPoint;
  var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
  var p1 = points[intPoint];
  var p22 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
  var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
  point.set(CatmullRom(weight, p0.x, p1.x, p22.x, p3.x), CatmullRom(weight, p0.y, p1.y, p22.y, p3.y));
  return point;
};
SplineCurve.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.points = [];
  for (var i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
    var point = source.points[i2];
    this.points.push(point.clone());
  }
  return this;
};
SplineCurve.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.points = [];
  for (var i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
    var point = this.points[i2];
    data.points.push(point.toArray());
  }
  return data;
};
SplineCurve.prototype.fromJSON = function(json) {
  Curve.prototype.fromJSON.call(this, json);
  this.points = [];
  for (var i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
    var point = json.points[i2];
    this.points.push(new Vector2().fromArray(point));
  }
  return this;
};
var Curves = /* @__PURE__ */ Object.freeze({
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
function CurvePath() {
  Curve.call(this);
  this.type = "CurvePath";
  this.curves = [];
  this.autoClose = false;
}
CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
  constructor: CurvePath,
  add: function(curve) {
    this.curves.push(curve);
  },
  closePath: function() {
    var startPoint = this.curves[0].getPoint(0);
    var endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  },
  getPoint: function(t2) {
    var d2 = t2 * this.getLength();
    var curveLengths = this.getCurveLengths();
    var i2 = 0;
    while (i2 < curveLengths.length) {
      if (curveLengths[i2] >= d2) {
        var diff = curveLengths[i2] - d2;
        var curve = this.curves[i2];
        var segmentLength = curve.getLength();
        var u2 = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u2);
      }
      i2++;
    }
    return null;
  },
  getLength: function() {
    var lens = this.getCurveLengths();
    return lens[lens.length - 1];
  },
  updateArcLengths: function() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  },
  getCurveLengths: function() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    var lengths = [], sums = 0;
    for (var i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
      sums += this.curves[i2].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  },
  getSpacedPoints: function(divisions) {
    if (divisions === void 0)
      divisions = 40;
    var points = [];
    for (var i2 = 0; i2 <= divisions; i2++) {
      points.push(this.getPoint(i2 / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  },
  getPoints: function(divisions) {
    divisions = divisions || 12;
    var points = [], last;
    for (var i2 = 0, curves = this.curves; i2 < curves.length; i2++) {
      var curve = curves[i2];
      var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      var pts = curve.getPoints(resolution);
      for (var j = 0; j < pts.length; j++) {
        var point = pts[j];
        if (last && last.equals(point))
          continue;
        points.push(point);
        last = point;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  },
  copy: function(source) {
    Curve.prototype.copy.call(this, source);
    this.curves = [];
    for (var i2 = 0, l2 = source.curves.length; i2 < l2; i2++) {
      var curve = source.curves[i2];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  },
  toJSON: function() {
    var data = Curve.prototype.toJSON.call(this);
    data.autoClose = this.autoClose;
    data.curves = [];
    for (var i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
      var curve = this.curves[i2];
      data.curves.push(curve.toJSON());
    }
    return data;
  },
  fromJSON: function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (var i2 = 0, l2 = json.curves.length; i2 < l2; i2++) {
      var curve = json.curves[i2];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
});
function Path(points) {
  CurvePath.call(this);
  this.type = "Path";
  this.currentPoint = new Vector2();
  if (points) {
    this.setFromPoints(points);
  }
}
Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
  constructor: Path,
  setFromPoints: function(points) {
    this.moveTo(points[0].x, points[0].y);
    for (var i2 = 1, l2 = points.length; i2 < l2; i2++) {
      this.lineTo(points[i2].x, points[i2].y);
    }
  },
  moveTo: function(x2, y) {
    this.currentPoint.set(x2, y);
  },
  lineTo: function(x2, y) {
    var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x2, y));
    this.curves.push(curve);
    this.currentPoint.set(x2, y);
  },
  quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
    var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
  },
  bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
  },
  splineThru: function(pts) {
    var npts = [this.currentPoint.clone()].concat(pts);
    var curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
  },
  arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    var x0 = this.currentPoint.x;
    var y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
  },
  absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
  },
  ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    var x0 = this.currentPoint.x;
    var y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
  },
  absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      var firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    var lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
  },
  copy: function(source) {
    CurvePath.prototype.copy.call(this, source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  },
  toJSON: function() {
    var data = CurvePath.prototype.toJSON.call(this);
    data.currentPoint = this.currentPoint.toArray();
    return data;
  },
  fromJSON: function(json) {
    CurvePath.prototype.fromJSON.call(this, json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
});
function Shape(points) {
  Path.call(this, points);
  this.uuid = _Math.generateUUID();
  this.type = "Shape";
  this.holes = [];
}
Shape.prototype = Object.assign(Object.create(Path.prototype), {
  constructor: Shape,
  getPointsHoles: function(divisions) {
    var holesPts = [];
    for (var i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
      holesPts[i2] = this.holes[i2].getPoints(divisions);
    }
    return holesPts;
  },
  extractPoints: function(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  },
  copy: function(source) {
    Path.prototype.copy.call(this, source);
    this.holes = [];
    for (var i2 = 0, l2 = source.holes.length; i2 < l2; i2++) {
      var hole = source.holes[i2];
      this.holes.push(hole.clone());
    }
    return this;
  },
  toJSON: function() {
    var data = Path.prototype.toJSON.call(this);
    data.uuid = this.uuid;
    data.holes = [];
    for (var i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
      var hole = this.holes[i2];
      data.holes.push(hole.toJSON());
    }
    return data;
  },
  fromJSON: function(json) {
    Path.prototype.fromJSON.call(this, json);
    this.uuid = json.uuid;
    this.holes = [];
    for (var i2 = 0, l2 = json.holes.length; i2 < l2; i2++) {
      var hole = json.holes[i2];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
});
function Light(color, intensity) {
  Object3D.call(this);
  this.type = "Light";
  this.color = new Color(color);
  this.intensity = intensity !== void 0 ? intensity : 1;
  this.receiveShadow = void 0;
}
Light.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Light,
  isLight: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  },
  toJSON: function(meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0)
      data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0)
      data.object.distance = this.distance;
    if (this.angle !== void 0)
      data.object.angle = this.angle;
    if (this.decay !== void 0)
      data.object.decay = this.decay;
    if (this.penumbra !== void 0)
      data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0)
      data.object.shadow = this.shadow.toJSON();
    return data;
  }
});
function HemisphereLight(skyColor, groundColor, intensity) {
  Light.call(this, skyColor, intensity);
  this.type = "HemisphereLight";
  this.castShadow = void 0;
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.groundColor = new Color(groundColor);
}
HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: HemisphereLight,
  isHemisphereLight: true,
  copy: function(source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }
});
function LightShadow(camera) {
  this.camera = camera;
  this.bias = 0;
  this.radius = 1;
  this.mapSize = new Vector2(512, 512);
  this.map = null;
  this.matrix = new Matrix4();
}
Object.assign(LightShadow.prototype, {
  copy: function(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    var object = {};
    if (this.bias !== 0)
      object.bias = this.bias;
    if (this.radius !== 1)
      object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
});
function SpotLightShadow() {
  LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
}
SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: SpotLightShadow,
  isSpotLightShadow: true,
  update: function(light) {
    var camera = this.camera;
    var fov2 = _Math.RAD2DEG * 2 * light.angle;
    var aspect2 = this.mapSize.width / this.mapSize.height;
    var far = light.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
  }
});
function SpotLight(color, intensity, distance, angle, penumbra, decay) {
  Light.call(this, color, intensity);
  this.type = "SpotLight";
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * Math.PI;
    },
    set: function(power) {
      this.intensity = power / Math.PI;
    }
  });
  this.distance = distance !== void 0 ? distance : 0;
  this.angle = angle !== void 0 ? angle : Math.PI / 3;
  this.penumbra = penumbra !== void 0 ? penumbra : 0;
  this.decay = decay !== void 0 ? decay : 1;
  this.shadow = new SpotLightShadow();
}
SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: SpotLight,
  isSpotLight: true,
  copy: function(source) {
    Light.prototype.copy.call(this, source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
});
function PointLight(color, intensity, distance, decay) {
  Light.call(this, color, intensity);
  this.type = "PointLight";
  Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * 4 * Math.PI;
    },
    set: function(power) {
      this.intensity = power / (4 * Math.PI);
    }
  });
  this.distance = distance !== void 0 ? distance : 0;
  this.decay = decay !== void 0 ? decay : 1;
  this.shadow = new LightShadow(new PerspectiveCamera(90, 1, 0.5, 500));
}
PointLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: PointLight,
  isPointLight: true,
  copy: function(source) {
    Light.prototype.copy.call(this, source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
});
function OrthographicCamera(left, right, top, bottom, near, far) {
  Camera.call(this);
  this.type = "OrthographicCamera";
  this.zoom = 1;
  this.view = null;
  this.left = left !== void 0 ? left : -1;
  this.right = right !== void 0 ? right : 1;
  this.top = top !== void 0 ? top : 1;
  this.bottom = bottom !== void 0 ? bottom : -1;
  this.near = near !== void 0 ? near : 0.1;
  this.far = far !== void 0 ? far : 2e3;
  this.updateProjectionMatrix();
}
OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: OrthographicCamera,
  isOrthographicCamera: true,
  copy: function(source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  },
  setViewOffset: function(fullWidth, fullHeight, x2, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x2;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    var dx = (this.right - this.left) / (2 * this.zoom);
    var dy = (this.top - this.bottom) / (2 * this.zoom);
    var cx = (this.right + this.left) / 2;
    var cy = (this.top + this.bottom) / 2;
    var left = cx - dx;
    var right = cx + dx;
    var top = cy + dy;
    var bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
      var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
      var scaleW = (this.right - this.left) / this.view.width;
      var scaleH = (this.top - this.bottom) / this.view.height;
      left += scaleW * (this.view.offsetX / zoomW);
      right = left + scaleW * (this.view.width / zoomW);
      top -= scaleH * (this.view.offsetY / zoomH);
      bottom = top - scaleH * (this.view.height / zoomH);
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function(meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    return data;
  }
});
function DirectionalLightShadow() {
  LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
}
DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: DirectionalLightShadow
});
function DirectionalLight(color, intensity) {
  Light.call(this, color, intensity);
  this.type = "DirectionalLight";
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  this.shadow = new DirectionalLightShadow();
}
DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: DirectionalLight,
  isDirectionalLight: true,
  copy: function(source) {
    Light.prototype.copy.call(this, source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
});
function AmbientLight(color, intensity) {
  Light.call(this, color, intensity);
  this.type = "AmbientLight";
  this.castShadow = void 0;
}
AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: AmbientLight,
  isAmbientLight: true
});
function RectAreaLight(color, intensity, width, height) {
  Light.call(this, color, intensity);
  this.type = "RectAreaLight";
  this.width = width !== void 0 ? width : 10;
  this.height = height !== void 0 ? height : 10;
}
RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: RectAreaLight,
  isRectAreaLight: true,
  copy: function(source) {
    Light.prototype.copy.call(this, source);
    this.width = source.width;
    this.height = source.height;
    return this;
  },
  toJSON: function(meta) {
    var data = Light.prototype.toJSON.call(this, meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
});
function MaterialLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this.textures = {};
}
Object.assign(MaterialLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.load(url, function(text2) {
      onLoad(scope.parse(JSON.parse(text2)));
    }, onProgress, onError);
  },
  parse: function(json) {
    var textures = this.textures;
    function getTexture(name2) {
      if (textures[name2] === void 0) {
        console.warn("THREE.MaterialLoader: Undefined texture", name2);
      }
      return textures[name2];
    }
    var material = new Materials[json.type]();
    if (json.uuid !== void 0)
      material.uuid = json.uuid;
    if (json.name !== void 0)
      material.name = json.name;
    if (json.color !== void 0)
      material.color.setHex(json.color);
    if (json.roughness !== void 0)
      material.roughness = json.roughness;
    if (json.metalness !== void 0)
      material.metalness = json.metalness;
    if (json.emissive !== void 0)
      material.emissive.setHex(json.emissive);
    if (json.specular !== void 0)
      material.specular.setHex(json.specular);
    if (json.shininess !== void 0)
      material.shininess = json.shininess;
    if (json.clearCoat !== void 0)
      material.clearCoat = json.clearCoat;
    if (json.clearCoatRoughness !== void 0)
      material.clearCoatRoughness = json.clearCoatRoughness;
    if (json.vertexColors !== void 0)
      material.vertexColors = json.vertexColors;
    if (json.fog !== void 0)
      material.fog = json.fog;
    if (json.flatShading !== void 0)
      material.flatShading = json.flatShading;
    if (json.blending !== void 0)
      material.blending = json.blending;
    if (json.combine !== void 0)
      material.combine = json.combine;
    if (json.side !== void 0)
      material.side = json.side;
    if (json.opacity !== void 0)
      material.opacity = json.opacity;
    if (json.transparent !== void 0)
      material.transparent = json.transparent;
    if (json.alphaTest !== void 0)
      material.alphaTest = json.alphaTest;
    if (json.depthTest !== void 0)
      material.depthTest = json.depthTest;
    if (json.depthWrite !== void 0)
      material.depthWrite = json.depthWrite;
    if (json.colorWrite !== void 0)
      material.colorWrite = json.colorWrite;
    if (json.wireframe !== void 0)
      material.wireframe = json.wireframe;
    if (json.wireframeLinewidth !== void 0)
      material.wireframeLinewidth = json.wireframeLinewidth;
    if (json.wireframeLinecap !== void 0)
      material.wireframeLinecap = json.wireframeLinecap;
    if (json.wireframeLinejoin !== void 0)
      material.wireframeLinejoin = json.wireframeLinejoin;
    if (json.rotation !== void 0)
      material.rotation = json.rotation;
    if (json.linewidth !== 1)
      material.linewidth = json.linewidth;
    if (json.dashSize !== void 0)
      material.dashSize = json.dashSize;
    if (json.gapSize !== void 0)
      material.gapSize = json.gapSize;
    if (json.scale !== void 0)
      material.scale = json.scale;
    if (json.polygonOffset !== void 0)
      material.polygonOffset = json.polygonOffset;
    if (json.polygonOffsetFactor !== void 0)
      material.polygonOffsetFactor = json.polygonOffsetFactor;
    if (json.polygonOffsetUnits !== void 0)
      material.polygonOffsetUnits = json.polygonOffsetUnits;
    if (json.skinning !== void 0)
      material.skinning = json.skinning;
    if (json.morphTargets !== void 0)
      material.morphTargets = json.morphTargets;
    if (json.dithering !== void 0)
      material.dithering = json.dithering;
    if (json.visible !== void 0)
      material.visible = json.visible;
    if (json.userData !== void 0)
      material.userData = json.userData;
    if (json.uniforms !== void 0) {
      for (var name in json.uniforms) {
        var uniform = json.uniforms[name];
        material.uniforms[name] = {};
        switch (uniform.type) {
          case "t":
            material.uniforms[name].value = getTexture(uniform.value);
            break;
          case "c":
            material.uniforms[name].value = new Color().setHex(uniform.value);
            break;
          case "v2":
            material.uniforms[name].value = new Vector2().fromArray(uniform.value);
            break;
          case "v3":
            material.uniforms[name].value = new Vector3().fromArray(uniform.value);
            break;
          case "v4":
            material.uniforms[name].value = new Vector4().fromArray(uniform.value);
            break;
          case "m3":
            material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
          case "m4":
            material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
            break;
          default:
            material.uniforms[name].value = uniform.value;
        }
      }
    }
    if (json.defines !== void 0)
      material.defines = json.defines;
    if (json.vertexShader !== void 0)
      material.vertexShader = json.vertexShader;
    if (json.fragmentShader !== void 0)
      material.fragmentShader = json.fragmentShader;
    if (json.extensions !== void 0) {
      for (var key in json.extensions) {
        material.extensions[key] = json.extensions[key];
      }
    }
    if (json.shading !== void 0)
      material.flatShading = json.shading === 1;
    if (json.size !== void 0)
      material.size = json.size;
    if (json.sizeAttenuation !== void 0)
      material.sizeAttenuation = json.sizeAttenuation;
    if (json.map !== void 0)
      material.map = getTexture(json.map);
    if (json.matcap !== void 0)
      material.matcap = getTexture(json.matcap);
    if (json.alphaMap !== void 0) {
      material.alphaMap = getTexture(json.alphaMap);
      material.transparent = true;
    }
    if (json.bumpMap !== void 0)
      material.bumpMap = getTexture(json.bumpMap);
    if (json.bumpScale !== void 0)
      material.bumpScale = json.bumpScale;
    if (json.normalMap !== void 0)
      material.normalMap = getTexture(json.normalMap);
    if (json.normalMapType !== void 0)
      material.normalMapType = json.normalMapType;
    if (json.normalScale !== void 0) {
      var normalScale = json.normalScale;
      if (Array.isArray(normalScale) === false) {
        normalScale = [normalScale, normalScale];
      }
      material.normalScale = new Vector2().fromArray(normalScale);
    }
    if (json.displacementMap !== void 0)
      material.displacementMap = getTexture(json.displacementMap);
    if (json.displacementScale !== void 0)
      material.displacementScale = json.displacementScale;
    if (json.displacementBias !== void 0)
      material.displacementBias = json.displacementBias;
    if (json.roughnessMap !== void 0)
      material.roughnessMap = getTexture(json.roughnessMap);
    if (json.metalnessMap !== void 0)
      material.metalnessMap = getTexture(json.metalnessMap);
    if (json.emissiveMap !== void 0)
      material.emissiveMap = getTexture(json.emissiveMap);
    if (json.emissiveIntensity !== void 0)
      material.emissiveIntensity = json.emissiveIntensity;
    if (json.specularMap !== void 0)
      material.specularMap = getTexture(json.specularMap);
    if (json.envMap !== void 0)
      material.envMap = getTexture(json.envMap);
    if (json.envMapIntensity !== void 0)
      material.envMapIntensity = json.envMapIntensity;
    if (json.reflectivity !== void 0)
      material.reflectivity = json.reflectivity;
    if (json.lightMap !== void 0)
      material.lightMap = getTexture(json.lightMap);
    if (json.lightMapIntensity !== void 0)
      material.lightMapIntensity = json.lightMapIntensity;
    if (json.aoMap !== void 0)
      material.aoMap = getTexture(json.aoMap);
    if (json.aoMapIntensity !== void 0)
      material.aoMapIntensity = json.aoMapIntensity;
    if (json.gradientMap !== void 0)
      material.gradientMap = getTexture(json.gradientMap);
    return material;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  },
  setTextures: function(value) {
    this.textures = value;
    return this;
  }
});
var LoaderUtils = {
  decodeText: function(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    var s2 = "";
    for (var i2 = 0, il = array.length; i2 < il; i2++) {
      s2 += String.fromCharCode(array[i2]);
    }
    try {
      return decodeURIComponent(escape(s2));
    } catch (e2) {
      return s2;
    }
  },
  extractUrlBase: function(url) {
    var index2 = url.lastIndexOf("/");
    if (index2 === -1)
      return "./";
    return url.substr(0, index2 + 1);
  }
};
function InstancedBufferGeometry() {
  BufferGeometry.call(this);
  this.type = "InstancedBufferGeometry";
  this.maxInstancedCount = void 0;
}
InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
  constructor: InstancedBufferGeometry,
  isInstancedBufferGeometry: true,
  copy: function(source) {
    BufferGeometry.prototype.copy.call(this, source);
    this.maxInstancedCount = source.maxInstancedCount;
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    var data = BufferGeometry.prototype.toJSON.call(this);
    data.maxInstancedCount = this.maxInstancedCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
});
function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
  if (typeof normalized === "number") {
    meshPerAttribute = normalized;
    normalized = false;
    console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
  }
  BufferAttribute.call(this, array, itemSize, normalized);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
  constructor: InstancedBufferAttribute,
  isInstancedBufferAttribute: true,
  copy: function(source) {
    BufferAttribute.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  toJSON: function() {
    var data = BufferAttribute.prototype.toJSON.call(this);
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
});
function BufferGeometryLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(BufferGeometryLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.load(url, function(text2) {
      onLoad(scope.parse(JSON.parse(text2)));
    }, onProgress, onError);
  },
  parse: function(json) {
    var geometry2 = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
    var index2 = json.data.index;
    if (index2 !== void 0) {
      var typedArray = new TYPED_ARRAYS[index2.type](index2.array);
      geometry2.setIndex(new BufferAttribute(typedArray, 1));
    }
    var attributes = json.data.attributes;
    for (var key in attributes) {
      var attribute = attributes[key];
      var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
      var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
      var bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
      if (attribute.name !== void 0)
        bufferAttribute.name = attribute.name;
      geometry2.addAttribute(key, bufferAttribute);
    }
    var morphAttributes = json.data.morphAttributes;
    if (morphAttributes) {
      for (var key in morphAttributes) {
        var attributeArray = morphAttributes[key];
        var array = [];
        for (var i2 = 0, il = attributeArray.length; i2 < il; i2++) {
          var attribute = attributeArray[i2];
          var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
          var bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
          if (attribute.name !== void 0)
            bufferAttribute.name = attribute.name;
          array.push(bufferAttribute);
        }
        geometry2.morphAttributes[key] = array;
      }
    }
    var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
    if (groups !== void 0) {
      for (var i2 = 0, n2 = groups.length; i2 !== n2; ++i2) {
        var group = groups[i2];
        geometry2.addGroup(group.start, group.count, group.materialIndex);
      }
    }
    var boundingSphere = json.data.boundingSphere;
    if (boundingSphere !== void 0) {
      var center = new Vector3();
      if (boundingSphere.center !== void 0) {
        center.fromArray(boundingSphere.center);
      }
      geometry2.boundingSphere = new Sphere(center, boundingSphere.radius);
    }
    if (json.name)
      geometry2.name = json.name;
    if (json.userData)
      geometry2.userData = json.userData;
    return geometry2;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
var TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray: typeof Uint8ClampedArray !== "undefined" ? Uint8ClampedArray : Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function ObjectLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this.resourcePath = "";
}
Object.assign(ObjectLoader.prototype, {
  crossOrigin: "anonymous",
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var path = this.path === void 0 ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    var loader = new FileLoader(scope.manager);
    loader.setPath(this.path);
    loader.load(url, function(text2) {
      var json = null;
      try {
        json = JSON.parse(text2);
      } catch (error) {
        if (onError !== void 0)
          onError(error);
        console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
        return;
      }
      var metadata = json.metadata;
      if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
        console.error("THREE.ObjectLoader: Can't load " + url);
        return;
      }
      scope.parse(json, onLoad);
    }, onProgress, onError);
  },
  setPath: function(value) {
    this.path = value;
    return this;
  },
  setResourcePath: function(value) {
    this.resourcePath = value;
    return this;
  },
  setCrossOrigin: function(value) {
    this.crossOrigin = value;
    return this;
  },
  parse: function(json, onLoad) {
    var shapes = this.parseShape(json.shapes);
    var geometries = this.parseGeometries(json.geometries, shapes);
    var images2 = this.parseImages(json.images, function() {
      if (onLoad !== void 0)
        onLoad(object);
    });
    var textures = this.parseTextures(json.textures, images2);
    var materials = this.parseMaterials(json.materials, textures);
    var object = this.parseObject(json.object, geometries, materials);
    if (json.animations) {
      object.animations = this.parseAnimations(json.animations);
    }
    if (json.images === void 0 || json.images.length === 0) {
      if (onLoad !== void 0)
        onLoad(object);
    }
    return object;
  },
  parseShape: function(json) {
    var shapes = {};
    if (json !== void 0) {
      for (var i2 = 0, l2 = json.length; i2 < l2; i2++) {
        var shape = new Shape().fromJSON(json[i2]);
        shapes[shape.uuid] = shape;
      }
    }
    return shapes;
  },
  parseGeometries: function(json, shapes) {
    var geometries = {};
    if (json !== void 0) {
      var bufferGeometryLoader = new BufferGeometryLoader();
      for (var i2 = 0, l2 = json.length; i2 < l2; i2++) {
        var geometry2;
        var data = json[i2];
        switch (data.type) {
          case "PlaneGeometry":
          case "PlaneBufferGeometry":
            geometry2 = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
            break;
          case "BoxGeometry":
          case "BoxBufferGeometry":
          case "CubeGeometry":
            geometry2 = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
            break;
          case "CircleGeometry":
          case "CircleBufferGeometry":
            geometry2 = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
            break;
          case "CylinderGeometry":
          case "CylinderBufferGeometry":
            geometry2 = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;
          case "ConeGeometry":
          case "ConeBufferGeometry":
            geometry2 = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;
          case "SphereGeometry":
          case "SphereBufferGeometry":
            geometry2 = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
            break;
          case "DodecahedronGeometry":
          case "DodecahedronBufferGeometry":
          case "IcosahedronGeometry":
          case "IcosahedronBufferGeometry":
          case "OctahedronGeometry":
          case "OctahedronBufferGeometry":
          case "TetrahedronGeometry":
          case "TetrahedronBufferGeometry":
            geometry2 = new Geometries[data.type](data.radius, data.detail);
            break;
          case "RingGeometry":
          case "RingBufferGeometry":
            geometry2 = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
            break;
          case "TorusGeometry":
          case "TorusBufferGeometry":
            geometry2 = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
            break;
          case "TorusKnotGeometry":
          case "TorusKnotBufferGeometry":
            geometry2 = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
            break;
          case "TubeGeometry":
          case "TubeBufferGeometry":
            geometry2 = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
            break;
          case "LatheGeometry":
          case "LatheBufferGeometry":
            geometry2 = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
            break;
          case "PolyhedronGeometry":
          case "PolyhedronBufferGeometry":
            geometry2 = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
            break;
          case "ShapeGeometry":
          case "ShapeBufferGeometry":
            var geometryShapes = [];
            for (var j = 0, jl = data.shapes.length; j < jl; j++) {
              var shape = shapes[data.shapes[j]];
              geometryShapes.push(shape);
            }
            geometry2 = new Geometries[data.type](geometryShapes, data.curveSegments);
            break;
          case "ExtrudeGeometry":
          case "ExtrudeBufferGeometry":
            var geometryShapes = [];
            for (var j = 0, jl = data.shapes.length; j < jl; j++) {
              var shape = shapes[data.shapes[j]];
              geometryShapes.push(shape);
            }
            var extrudePath = data.options.extrudePath;
            if (extrudePath !== void 0) {
              data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
            }
            geometry2 = new Geometries[data.type](geometryShapes, data.options);
            break;
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            geometry2 = bufferGeometryLoader.parse(data);
            break;
          case "Geometry":
            if ("THREE" in window && "LegacyJSONLoader" in THREE) {
              var geometryLoader = new THREE.LegacyJSONLoader();
              geometry2 = geometryLoader.parse(data, this.resourcePath).geometry;
            } else {
              console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
            }
            break;
          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
            continue;
        }
        geometry2.uuid = data.uuid;
        if (data.name !== void 0)
          geometry2.name = data.name;
        if (geometry2.isBufferGeometry === true && data.userData !== void 0)
          geometry2.userData = data.userData;
        geometries[data.uuid] = geometry2;
      }
    }
    return geometries;
  },
  parseMaterials: function(json, textures) {
    var cache = {};
    var materials = {};
    if (json !== void 0) {
      var loader = new MaterialLoader();
      loader.setTextures(textures);
      for (var i2 = 0, l2 = json.length; i2 < l2; i2++) {
        var data = json[i2];
        if (data.type === "MultiMaterial") {
          var array = [];
          for (var j = 0; j < data.materials.length; j++) {
            var material = data.materials[j];
            if (cache[material.uuid] === void 0) {
              cache[material.uuid] = loader.parse(material);
            }
            array.push(cache[material.uuid]);
          }
          materials[data.uuid] = array;
        } else {
          if (cache[data.uuid] === void 0) {
            cache[data.uuid] = loader.parse(data);
          }
          materials[data.uuid] = cache[data.uuid];
        }
      }
    }
    return materials;
  },
  parseAnimations: function(json) {
    var animations = [];
    for (var i2 = 0; i2 < json.length; i2++) {
      var data = json[i2];
      var clip = AnimationClip.parse(data);
      if (data.uuid !== void 0)
        clip.uuid = data.uuid;
      animations.push(clip);
    }
    return animations;
  },
  parseImages: function(json, onLoad) {
    var scope = this;
    var images2 = {};
    function loadImage3(url2) {
      scope.manager.itemStart(url2);
      return loader.load(url2, function() {
        scope.manager.itemEnd(url2);
      }, void 0, function() {
        scope.manager.itemError(url2);
        scope.manager.itemEnd(url2);
      });
    }
    if (json !== void 0 && json.length > 0) {
      var manager = new LoadingManager(onLoad);
      var loader = new ImageLoader$1(manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (var i2 = 0, il = json.length; i2 < il; i2++) {
        var image = json[i2];
        var url = image.url;
        if (Array.isArray(url)) {
          images2[image.uuid] = [];
          for (var j = 0, jl = url.length; j < jl; j++) {
            var currentUrl = url[j];
            var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;
            images2[image.uuid].push(loadImage3(path));
          }
        } else {
          var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.resourcePath + image.url;
          images2[image.uuid] = loadImage3(path);
        }
      }
    }
    return images2;
  },
  parseTextures: function(json, images2) {
    function parseConstant(value, type) {
      if (typeof value === "number")
        return value;
      console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
      return type[value];
    }
    var textures = {};
    if (json !== void 0) {
      for (var i2 = 0, l2 = json.length; i2 < l2; i2++) {
        var data = json[i2];
        if (data.image === void 0) {
          console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
        }
        if (images2[data.image] === void 0) {
          console.warn("THREE.ObjectLoader: Undefined image", data.image);
        }
        var texture;
        if (Array.isArray(images2[data.image])) {
          texture = new CubeTexture(images2[data.image]);
        } else {
          texture = new Texture(images2[data.image]);
        }
        texture.needsUpdate = true;
        texture.uuid = data.uuid;
        if (data.name !== void 0)
          texture.name = data.name;
        if (data.mapping !== void 0)
          texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
        if (data.offset !== void 0)
          texture.offset.fromArray(data.offset);
        if (data.repeat !== void 0)
          texture.repeat.fromArray(data.repeat);
        if (data.center !== void 0)
          texture.center.fromArray(data.center);
        if (data.rotation !== void 0)
          texture.rotation = data.rotation;
        if (data.wrap !== void 0) {
          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
        }
        if (data.format !== void 0)
          texture.format = data.format;
        if (data.type !== void 0)
          texture.type = data.type;
        if (data.encoding !== void 0)
          texture.encoding = data.encoding;
        if (data.minFilter !== void 0)
          texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
        if (data.magFilter !== void 0)
          texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
        if (data.anisotropy !== void 0)
          texture.anisotropy = data.anisotropy;
        if (data.flipY !== void 0)
          texture.flipY = data.flipY;
        if (data.premultiplyAlpha !== void 0)
          texture.premultiplyAlpha = data.premultiplyAlpha;
        if (data.unpackAlignment !== void 0)
          texture.unpackAlignment = data.unpackAlignment;
        textures[data.uuid] = texture;
      }
    }
    return textures;
  },
  parseObject: function(data, geometries, materials) {
    var object;
    function getGeometry(name) {
      if (geometries[name] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined geometry", name);
      }
      return geometries[name];
    }
    function getMaterial(name) {
      if (name === void 0)
        return void 0;
      if (Array.isArray(name)) {
        var array = [];
        for (var i3 = 0, l3 = name.length; i3 < l3; i3++) {
          var uuid = name[i3];
          if (materials[uuid] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined material", uuid);
          }
          array.push(materials[uuid]);
        }
        return array;
      }
      if (materials[name] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined material", name);
      }
      return materials[name];
    }
    switch (data.type) {
      case "Scene":
        object = new Scene();
        if (data.background !== void 0) {
          if (Number.isInteger(data.background)) {
            object.background = new Color(data.background);
          }
        }
        if (data.fog !== void 0) {
          if (data.fog.type === "Fog") {
            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
          } else if (data.fog.type === "FogExp2") {
            object.fog = new FogExp2(data.fog.color, data.fog.density);
          }
        }
        break;
      case "PerspectiveCamera":
        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
        if (data.focus !== void 0)
          object.focus = data.focus;
        if (data.zoom !== void 0)
          object.zoom = data.zoom;
        if (data.filmGauge !== void 0)
          object.filmGauge = data.filmGauge;
        if (data.filmOffset !== void 0)
          object.filmOffset = data.filmOffset;
        if (data.view !== void 0)
          object.view = Object.assign({}, data.view);
        break;
      case "OrthographicCamera":
        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
        if (data.zoom !== void 0)
          object.zoom = data.zoom;
        if (data.view !== void 0)
          object.view = Object.assign({}, data.view);
        break;
      case "AmbientLight":
        object = new AmbientLight(data.color, data.intensity);
        break;
      case "DirectionalLight":
        object = new DirectionalLight(data.color, data.intensity);
        break;
      case "PointLight":
        object = new PointLight(data.color, data.intensity, data.distance, data.decay);
        break;
      case "RectAreaLight":
        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
        break;
      case "SpotLight":
        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
        break;
      case "HemisphereLight":
        object = new HemisphereLight(data.color, data.groundColor, data.intensity);
        break;
      case "SkinnedMesh":
        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
      case "Mesh":
        var geometry2 = getGeometry(data.geometry);
        var material = getMaterial(data.material);
        if (geometry2.bones && geometry2.bones.length > 0) {
          object = new SkinnedMesh(geometry2, material);
        } else {
          object = new Mesh(geometry2, material);
        }
        if (data.drawMode !== void 0)
          object.setDrawMode(data.drawMode);
        break;
      case "LOD":
        object = new LOD();
        break;
      case "Line":
        object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
        break;
      case "LineLoop":
        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "LineSegments":
        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "PointCloud":
      case "Points":
        object = new Points(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "Sprite":
        object = new Sprite(getMaterial(data.material));
        break;
      case "Group":
        object = new Group();
        break;
      default:
        object = new Object3D();
    }
    object.uuid = data.uuid;
    if (data.name !== void 0)
      object.name = data.name;
    if (data.matrix !== void 0) {
      object.matrix.fromArray(data.matrix);
      if (data.matrixAutoUpdate !== void 0)
        object.matrixAutoUpdate = data.matrixAutoUpdate;
      if (object.matrixAutoUpdate)
        object.matrix.decompose(object.position, object.quaternion, object.scale);
    } else {
      if (data.position !== void 0)
        object.position.fromArray(data.position);
      if (data.rotation !== void 0)
        object.rotation.fromArray(data.rotation);
      if (data.quaternion !== void 0)
        object.quaternion.fromArray(data.quaternion);
      if (data.scale !== void 0)
        object.scale.fromArray(data.scale);
    }
    if (data.castShadow !== void 0)
      object.castShadow = data.castShadow;
    if (data.receiveShadow !== void 0)
      object.receiveShadow = data.receiveShadow;
    if (data.shadow) {
      if (data.shadow.bias !== void 0)
        object.shadow.bias = data.shadow.bias;
      if (data.shadow.radius !== void 0)
        object.shadow.radius = data.shadow.radius;
      if (data.shadow.mapSize !== void 0)
        object.shadow.mapSize.fromArray(data.shadow.mapSize);
      if (data.shadow.camera !== void 0)
        object.shadow.camera = this.parseObject(data.shadow.camera);
    }
    if (data.visible !== void 0)
      object.visible = data.visible;
    if (data.frustumCulled !== void 0)
      object.frustumCulled = data.frustumCulled;
    if (data.renderOrder !== void 0)
      object.renderOrder = data.renderOrder;
    if (data.userData !== void 0)
      object.userData = data.userData;
    if (data.layers !== void 0)
      object.layers.mask = data.layers;
    if (data.children !== void 0) {
      var children2 = data.children;
      for (var i2 = 0; i2 < children2.length; i2++) {
        object.add(this.parseObject(children2[i2], geometries, materials));
      }
    }
    if (data.type === "LOD") {
      var levels = data.levels;
      for (var l2 = 0; l2 < levels.length; l2++) {
        var level = levels[l2];
        var child = object.getObjectByProperty("uuid", level.object);
        if (child !== void 0) {
          object.addLevel(child, level.distance);
        }
      }
    }
    return object;
  }
});
var TEXTURE_MAPPING = {
  UVMapping,
  CubeReflectionMapping,
  CubeRefractionMapping,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  SphericalReflectionMapping,
  CubeUVReflectionMapping,
  CubeUVRefractionMapping
};
var TEXTURE_WRAPPING = {
  RepeatWrapping,
  ClampToEdgeWrapping,
  MirroredRepeatWrapping
};
var TEXTURE_FILTER = {
  NearestFilter,
  NearestMipMapNearestFilter,
  NearestMipMapLinearFilter,
  LinearFilter,
  LinearMipMapNearestFilter,
  LinearMipMapLinearFilter
};
function ShapePath() {
  this.type = "ShapePath";
  this.color = new Color();
  this.subPaths = [];
  this.currentPath = null;
}
Object.assign(ShapePath.prototype, {
  moveTo: function(x2, y) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x2, y);
  },
  lineTo: function(x2, y) {
    this.currentPath.lineTo(x2, y);
  },
  quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
  },
  bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
  },
  splineThru: function(pts) {
    this.currentPath.splineThru(pts);
  },
  toShapes: function(isCCW, noHoles) {
    function toShapesNoHoles(inSubpaths) {
      var shapes2 = [];
      for (var i3 = 0, l3 = inSubpaths.length; i3 < l3; i3++) {
        var tmpPath2 = inSubpaths[i3];
        var tmpShape2 = new Shape();
        tmpShape2.curves = tmpPath2.curves;
        shapes2.push(tmpShape2);
      }
      return shapes2;
    }
    function isPointInsidePolygon(inPt, inPolygon) {
      var polyLen = inPolygon.length;
      var inside = false;
      for (var p2 = polyLen - 1, q = 0; q < polyLen; p2 = q++) {
        var edgeLowPt = inPolygon[p2];
        var edgeHighPt = inPolygon[q];
        var edgeDx = edgeHighPt.x - edgeLowPt.x;
        var edgeDy = edgeHighPt.y - edgeLowPt.y;
        if (Math.abs(edgeDy) > Number.EPSILON) {
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p2];
            edgeDy = -edgeDy;
          }
          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
            continue;
          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x)
              return true;
          } else {
            var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0)
              return true;
            if (perpEdge < 0)
              continue;
            inside = !inside;
          }
        } else {
          if (inPt.y !== edgeLowPt.y)
            continue;
          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
            return true;
        }
      }
      return inside;
    }
    var isClockWise = ShapeUtils.isClockWise;
    var subPaths = this.subPaths;
    if (subPaths.length === 0)
      return [];
    if (noHoles === true)
      return toShapesNoHoles(subPaths);
    var solid, tmpPath, tmpShape, shapes = [];
    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }
    var holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst;
    var betterShapeHoles = [];
    var newShapes = [];
    var newShapeHoles = [];
    var mainIdx = 0;
    var tmpPoints;
    newShapes[mainIdx] = void 0;
    newShapeHoles[mainIdx] = [];
    for (var i2 = 0, l2 = subPaths.length; i2 < l2; i2++) {
      tmpPath = subPaths[i2];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;
      if (solid) {
        if (!holesFirst && newShapes[mainIdx])
          mainIdx++;
        newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst)
          mainIdx++;
        newShapeHoles[mainIdx] = [];
      } else {
        newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
      }
    }
    if (!newShapes[0])
      return toShapesNoHoles(subPaths);
    if (newShapes.length > 1) {
      var ambiguous = false;
      var toChange = [];
      for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }
      for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        var sho = newShapeHoles[sIdx];
        for (var hIdx = 0; hIdx < sho.length; hIdx++) {
          var ho = sho[hIdx];
          var hole_unassigned = true;
          for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx)
                toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }
          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      }
      if (toChange.length > 0) {
        if (!ambiguous)
          newShapeHoles = betterShapeHoles;
      }
    }
    var tmpHoles;
    for (var i2 = 0, il = newShapes.length; i2 < il; i2++) {
      tmpShape = newShapes[i2].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i2];
      for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h);
      }
    }
    return shapes;
  }
});
function Font(data) {
  this.type = "Font";
  this.data = data;
}
Object.assign(Font.prototype, {
  isFont: true,
  generateShapes: function(text2, size) {
    if (size === void 0)
      size = 100;
    var shapes = [];
    var paths = createPaths(text2, size, this.data);
    for (var p2 = 0, pl = paths.length; p2 < pl; p2++) {
      Array.prototype.push.apply(shapes, paths[p2].toShapes());
    }
    return shapes;
  }
});
function createPaths(text2, size, data) {
  var chars = Array.from ? Array.from(text2) : String(text2).split("");
  var scale2 = size / data.resolution;
  var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale2;
  var paths = [];
  var offsetX = 0, offsetY = 0;
  for (var i2 = 0; i2 < chars.length; i2++) {
    var char = chars[i2];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      var ret = createPath(char, scale2, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }
  return paths;
}
function createPath(char, scale2, offsetX, offsetY, data) {
  var glyph = data.glyphs[char] || data.glyphs["?"];
  if (!glyph)
    return;
  var path = new ShapePath();
  var x2, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (var i2 = 0, l2 = outline.length; i2 < l2; ) {
      var action = outline[i2++];
      switch (action) {
        case "m":
          x2 = outline[i2++] * scale2 + offsetX;
          y = outline[i2++] * scale2 + offsetY;
          path.moveTo(x2, y);
          break;
        case "l":
          x2 = outline[i2++] * scale2 + offsetX;
          y = outline[i2++] * scale2 + offsetY;
          path.lineTo(x2, y);
          break;
        case "q":
          cpx = outline[i2++] * scale2 + offsetX;
          cpy = outline[i2++] * scale2 + offsetY;
          cpx1 = outline[i2++] * scale2 + offsetX;
          cpy1 = outline[i2++] * scale2 + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = outline[i2++] * scale2 + offsetX;
          cpy = outline[i2++] * scale2 + offsetY;
          cpx1 = outline[i2++] * scale2 + offsetX;
          cpy1 = outline[i2++] * scale2 + offsetY;
          cpx2 = outline[i2++] * scale2 + offsetX;
          cpy2 = outline[i2++] * scale2 + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return { offsetX: glyph.ha * scale2, path };
}
function FontLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(FontLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.load(url, function(text2) {
      var json;
      try {
        json = JSON.parse(text2);
      } catch (e2) {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
        json = JSON.parse(text2.substring(65, text2.length - 2));
      }
      var font = scope.parse(json);
      if (onLoad)
        onLoad(font);
    }, onProgress, onError);
  },
  parse: function(json) {
    return new Font(json);
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
function Loader() {
}
Loader.Handlers = {
  handlers: [],
  add: function(regex, loader) {
    this.handlers.push(regex, loader);
  },
  get: function(file) {
    var handlers2 = this.handlers;
    for (var i2 = 0, l2 = handlers2.length; i2 < l2; i2 += 2) {
      var regex = handlers2[i2];
      var loader = handlers2[i2 + 1];
      if (regex.test(file)) {
        return loader;
      }
    }
    return null;
  }
};
Object.assign(Loader.prototype, {
  crossOrigin: "anonymous",
  onLoadStart: function() {
  },
  onLoadProgress: function() {
  },
  onLoadComplete: function() {
  },
  initMaterials: function(materials, texturePath, crossOrigin) {
    var array = [];
    for (var i2 = 0; i2 < materials.length; ++i2) {
      array[i2] = this.createMaterial(materials[i2], texturePath, crossOrigin);
    }
    return array;
  },
  createMaterial: function() {
    var BlendingMode = {
      NoBlending,
      NormalBlending,
      AdditiveBlending,
      SubtractiveBlending,
      MultiplyBlending,
      CustomBlending
    };
    var color = new Color();
    var textureLoader = new TextureLoader$1();
    var materialLoader = new MaterialLoader();
    return function createMaterial(m2, texturePath, crossOrigin) {
      var textures = {};
      function loadTexture(path, repeat, offset2, wrap, anisotropy) {
        var fullPath = texturePath + path;
        var loader = Loader.Handlers.get(fullPath);
        var texture;
        if (loader !== null) {
          texture = loader.load(fullPath);
        } else {
          textureLoader.setCrossOrigin(crossOrigin);
          texture = textureLoader.load(fullPath);
        }
        if (repeat !== void 0) {
          texture.repeat.fromArray(repeat);
          if (repeat[0] !== 1)
            texture.wrapS = RepeatWrapping;
          if (repeat[1] !== 1)
            texture.wrapT = RepeatWrapping;
        }
        if (offset2 !== void 0) {
          texture.offset.fromArray(offset2);
        }
        if (wrap !== void 0) {
          if (wrap[0] === "repeat")
            texture.wrapS = RepeatWrapping;
          if (wrap[0] === "mirror")
            texture.wrapS = MirroredRepeatWrapping;
          if (wrap[1] === "repeat")
            texture.wrapT = RepeatWrapping;
          if (wrap[1] === "mirror")
            texture.wrapT = MirroredRepeatWrapping;
        }
        if (anisotropy !== void 0) {
          texture.anisotropy = anisotropy;
        }
        var uuid = _Math.generateUUID();
        textures[uuid] = texture;
        return uuid;
      }
      var json = {
        uuid: _Math.generateUUID(),
        type: "MeshLambertMaterial"
      };
      for (var name in m2) {
        var value = m2[name];
        switch (name) {
          case "DbgColor":
          case "DbgIndex":
          case "opticalDensity":
          case "illumination":
            break;
          case "DbgName":
            json.name = value;
            break;
          case "blending":
            json.blending = BlendingMode[value];
            break;
          case "colorAmbient":
          case "mapAmbient":
            console.warn("THREE.Loader.createMaterial:", name, "is no longer supported.");
            break;
          case "colorDiffuse":
            json.color = color.fromArray(value).getHex();
            break;
          case "colorSpecular":
            json.specular = color.fromArray(value).getHex();
            break;
          case "colorEmissive":
            json.emissive = color.fromArray(value).getHex();
            break;
          case "specularCoef":
            json.shininess = value;
            break;
          case "shading":
            if (value.toLowerCase() === "basic")
              json.type = "MeshBasicMaterial";
            if (value.toLowerCase() === "phong")
              json.type = "MeshPhongMaterial";
            if (value.toLowerCase() === "standard")
              json.type = "MeshStandardMaterial";
            break;
          case "mapDiffuse":
            json.map = loadTexture(value, m2.mapDiffuseRepeat, m2.mapDiffuseOffset, m2.mapDiffuseWrap, m2.mapDiffuseAnisotropy);
            break;
          case "mapDiffuseRepeat":
          case "mapDiffuseOffset":
          case "mapDiffuseWrap":
          case "mapDiffuseAnisotropy":
            break;
          case "mapEmissive":
            json.emissiveMap = loadTexture(value, m2.mapEmissiveRepeat, m2.mapEmissiveOffset, m2.mapEmissiveWrap, m2.mapEmissiveAnisotropy);
            break;
          case "mapEmissiveRepeat":
          case "mapEmissiveOffset":
          case "mapEmissiveWrap":
          case "mapEmissiveAnisotropy":
            break;
          case "mapLight":
            json.lightMap = loadTexture(value, m2.mapLightRepeat, m2.mapLightOffset, m2.mapLightWrap, m2.mapLightAnisotropy);
            break;
          case "mapLightRepeat":
          case "mapLightOffset":
          case "mapLightWrap":
          case "mapLightAnisotropy":
            break;
          case "mapAO":
            json.aoMap = loadTexture(value, m2.mapAORepeat, m2.mapAOOffset, m2.mapAOWrap, m2.mapAOAnisotropy);
            break;
          case "mapAORepeat":
          case "mapAOOffset":
          case "mapAOWrap":
          case "mapAOAnisotropy":
            break;
          case "mapBump":
            json.bumpMap = loadTexture(value, m2.mapBumpRepeat, m2.mapBumpOffset, m2.mapBumpWrap, m2.mapBumpAnisotropy);
            break;
          case "mapBumpScale":
            json.bumpScale = value;
            break;
          case "mapBumpRepeat":
          case "mapBumpOffset":
          case "mapBumpWrap":
          case "mapBumpAnisotropy":
            break;
          case "mapNormal":
            json.normalMap = loadTexture(value, m2.mapNormalRepeat, m2.mapNormalOffset, m2.mapNormalWrap, m2.mapNormalAnisotropy);
            break;
          case "mapNormalFactor":
            json.normalScale = value;
            break;
          case "mapNormalRepeat":
          case "mapNormalOffset":
          case "mapNormalWrap":
          case "mapNormalAnisotropy":
            break;
          case "mapSpecular":
            json.specularMap = loadTexture(value, m2.mapSpecularRepeat, m2.mapSpecularOffset, m2.mapSpecularWrap, m2.mapSpecularAnisotropy);
            break;
          case "mapSpecularRepeat":
          case "mapSpecularOffset":
          case "mapSpecularWrap":
          case "mapSpecularAnisotropy":
            break;
          case "mapMetalness":
            json.metalnessMap = loadTexture(value, m2.mapMetalnessRepeat, m2.mapMetalnessOffset, m2.mapMetalnessWrap, m2.mapMetalnessAnisotropy);
            break;
          case "mapMetalnessRepeat":
          case "mapMetalnessOffset":
          case "mapMetalnessWrap":
          case "mapMetalnessAnisotropy":
            break;
          case "mapRoughness":
            json.roughnessMap = loadTexture(value, m2.mapRoughnessRepeat, m2.mapRoughnessOffset, m2.mapRoughnessWrap, m2.mapRoughnessAnisotropy);
            break;
          case "mapRoughnessRepeat":
          case "mapRoughnessOffset":
          case "mapRoughnessWrap":
          case "mapRoughnessAnisotropy":
            break;
          case "mapAlpha":
            json.alphaMap = loadTexture(value, m2.mapAlphaRepeat, m2.mapAlphaOffset, m2.mapAlphaWrap, m2.mapAlphaAnisotropy);
            break;
          case "mapAlphaRepeat":
          case "mapAlphaOffset":
          case "mapAlphaWrap":
          case "mapAlphaAnisotropy":
            break;
          case "flipSided":
            json.side = BackSide;
            break;
          case "doubleSided":
            json.side = DoubleSide;
            break;
          case "transparency":
            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");
            json.opacity = value;
            break;
          case "depthTest":
          case "depthWrite":
          case "colorWrite":
          case "opacity":
          case "reflectivity":
          case "transparent":
          case "visible":
          case "wireframe":
            json[name] = value;
            break;
          case "vertexColors":
            if (value === true)
              json.vertexColors = VertexColors;
            if (value === "face")
              json.vertexColors = FaceColors;
            break;
          default:
            console.error("THREE.Loader.createMaterial: Unsupported", name, value);
            break;
        }
      }
      if (json.type === "MeshBasicMaterial")
        delete json.emissive;
      if (json.type !== "MeshPhongMaterial")
        delete json.specular;
      if (json.opacity < 1)
        json.transparent = true;
      materialLoader.setTextures(textures);
      return materialLoader.parse(json);
    };
  }()
});
var context;
var AudioContext = {
  getContext: function() {
    if (context === void 0) {
      context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return context;
  },
  setContext: function(value) {
    context = value;
  }
};
function AudioLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(AudioLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.load(url, function(buffer) {
      var bufferCopy = buffer.slice(0);
      var context2 = AudioContext.getContext();
      context2.decodeAudioData(bufferCopy, function(audioBuffer) {
        onLoad(audioBuffer);
      });
    }, onProgress, onError);
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
function SphericalHarmonics3() {
  this.coefficients = [];
  for (var i2 = 0; i2 < 9; i2++) {
    this.coefficients.push(new Vector3());
  }
}
Object.assign(SphericalHarmonics3.prototype, {
  isSphericalHarmonics3: true,
  set: function(coefficients) {
    for (var i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].copy(coefficients[i2]);
    }
    return this;
  },
  zero: function() {
    for (var i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].set(0, 0, 0);
    }
    return this;
  },
  getAt: function(normal, target) {
    var x2 = normal.x, y = normal.y, z2 = normal.z;
    var coeff = this.coefficients;
    target = coeff[0] * 0.282095;
    target += coeff[1] * 0.488603 * y;
    target += coeff[2] * 0.488603 * z2;
    target += coeff[3] * 0.488603 * x2;
    target += coeff[4] * 1.092548 * (x2 * y);
    target += coeff[5] * 1.092548 * (y * z2);
    target += coeff[6] * 0.315392 * (3 * z2 * z2 - 1);
    target += coeff[7] * 1.092548 * (x2 * z2);
    target += coeff[8] * 0.546274 * (x2 * x2 - y * y);
    return target;
  },
  getIrradianceAt: function(normal, target) {
    var x2 = normal.x, y = normal.y, z2 = normal.z;
    var coeff = this.coefficients;
    target = coeff[0] * 0.886227;
    target += coeff[1] * 2 * 0.511664 * y;
    target += coeff[2] * 2 * 0.511664 * z2;
    target += coeff[3] * 2 * 0.511664 * x2;
    target += coeff[4] * 2 * 0.429043 * x2 * y;
    target += coeff[5] * 2 * 0.429043 * y * z2;
    target += coeff[6] * (0.743125 * z2 * z2 - 0.247708);
    target += coeff[7] * 2 * 0.429043 * x2 * z2;
    target += coeff[8] * 0.429043 * (x2 * x2 - y * y);
    return target;
  },
  add: function(sh) {
    for (var i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].add(sh.coefficients[i2]);
    }
    return this;
  },
  scale: function(s2) {
    for (var i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].multiplyScalar(s2);
    }
    return this;
  },
  lerp: function(sh, alpha) {
    for (var i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].lerp(sh.coefficients[i2], alpha);
    }
    return this;
  },
  equals: function(sh) {
    for (var i2 = 0; i2 < 9; i2++) {
      if (!this.coefficients[i2].equals(sh.coefficients[i2])) {
        return false;
      }
    }
    return true;
  },
  copy: function(sh) {
    return this.set(sh.coefficients);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  fromArray: function(array) {
    var coefficients = this.coefficients;
    for (var i2 = 0; i2 < 9; i2++) {
      coefficients[i2].fromArray(array, i2 * 3);
    }
    return this;
  },
  toArray: function() {
    var array = [];
    var coefficients = this.coefficients;
    for (var i2 = 0; i2 < 9; i2++) {
      coefficients[i2].toArray(array, i2 * 3);
    }
    return array;
  }
});
Object.assign(SphericalHarmonics3, {
  getBasisAt: function(normal, shBasis) {
    var x2 = normal.x, y = normal.y, z2 = normal.z;
    shBasis[0] = 0.282095;
    shBasis[1] = 0.488603 * y;
    shBasis[2] = 0.488603 * z2;
    shBasis[3] = 0.488603 * x2;
    shBasis[4] = 1.092548 * x2 * y;
    shBasis[5] = 1.092548 * y * z2;
    shBasis[6] = 0.315392 * (3 * z2 * z2 - 1);
    shBasis[7] = 1.092548 * x2 * z2;
    shBasis[8] = 0.546274 * (x2 * x2 - y * y);
  }
});
function LightProbe(sh, intensity) {
  Light.call(this, void 0, intensity);
  this.sh = sh !== void 0 ? sh : new SphericalHarmonics3();
}
LightProbe.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: LightProbe,
  isLightProbe: true,
  copy: function(source) {
    Light.prototype.copy.call(this, source);
    this.sh.copy(source.sh);
    this.intensity = source.intensity;
    return this;
  },
  toJSON: function(meta) {
    var data = Light.prototype.toJSON.call(this, meta);
    return data;
  }
});
function HemisphereLightProbe(skyColor, groundColor, intensity) {
  LightProbe.call(this, void 0, intensity);
  var color1 = new Color().set(skyColor);
  var color2 = new Color().set(groundColor);
  var sky = new Vector3(color1.r, color1.g, color1.b);
  var ground = new Vector3(color2.r, color2.g, color2.b);
  var c0 = Math.sqrt(Math.PI);
  var c1 = c0 * Math.sqrt(0.75);
  this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
  this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
}
HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
  constructor: HemisphereLightProbe,
  isHemisphereLightProbe: true,
  copy: function(source) {
    LightProbe.prototype.copy.call(this, source);
    return this;
  },
  toJSON: function(meta) {
    var data = LightProbe.prototype.toJSON.call(this, meta);
    return data;
  }
});
function AmbientLightProbe(color, intensity) {
  LightProbe.call(this, void 0, intensity);
  var color1 = new Color().set(color);
  this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
}
AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
  constructor: AmbientLightProbe,
  isAmbientLightProbe: true,
  copy: function(source) {
    LightProbe.prototype.copy.call(this, source);
    return this;
  },
  toJSON: function(meta) {
    var data = LightProbe.prototype.toJSON.call(this, meta);
    return data;
  }
});
function StereoCamera() {
  this.type = "StereoCamera";
  this.aspect = 1;
  this.eyeSep = 0.064;
  this.cameraL = new PerspectiveCamera();
  this.cameraL.layers.enable(1);
  this.cameraL.matrixAutoUpdate = false;
  this.cameraR = new PerspectiveCamera();
  this.cameraR.layers.enable(2);
  this.cameraR.matrixAutoUpdate = false;
}
Object.assign(StereoCamera.prototype, {
  update: function() {
    var instance, focus, fov2, aspect2, near, far, zoom2, eyeSep;
    var eyeRight = new Matrix4();
    var eyeLeft = new Matrix4();
    return function update3(camera) {
      var needsUpdate = instance !== this || focus !== camera.focus || fov2 !== camera.fov || aspect2 !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far || zoom2 !== camera.zoom || eyeSep !== this.eyeSep;
      if (needsUpdate) {
        instance = this;
        focus = camera.focus;
        fov2 = camera.fov;
        aspect2 = camera.aspect * this.aspect;
        near = camera.near;
        far = camera.far;
        zoom2 = camera.zoom;
        var projectionMatrix = camera.projectionMatrix.clone();
        eyeSep = this.eyeSep / 2;
        var eyeSepOnProjection = eyeSep * near / focus;
        var ymax = near * Math.tan(_Math.DEG2RAD * fov2 * 0.5) / zoom2;
        var xmin, xmax;
        eyeLeft.elements[12] = -eyeSep;
        eyeRight.elements[12] = eyeSep;
        xmin = -ymax * aspect2 + eyeSepOnProjection;
        xmax = ymax * aspect2 + eyeSepOnProjection;
        projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraL.projectionMatrix.copy(projectionMatrix);
        xmin = -ymax * aspect2 - eyeSepOnProjection;
        xmax = ymax * aspect2 - eyeSepOnProjection;
        projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraR.projectionMatrix.copy(projectionMatrix);
      }
      this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
      this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
    };
  }()
});
var fov = 90, aspect = 1;
function CubeCamera(near, far, cubeResolution, options) {
  Object3D.call(this);
  this.type = "CubeCamera";
  var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
  cameraPX.up.set(0, -1, 0);
  cameraPX.lookAt(new Vector3(1, 0, 0));
  this.add(cameraPX);
  var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
  cameraNX.up.set(0, -1, 0);
  cameraNX.lookAt(new Vector3(-1, 0, 0));
  this.add(cameraNX);
  var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
  cameraPY.up.set(0, 0, 1);
  cameraPY.lookAt(new Vector3(0, 1, 0));
  this.add(cameraPY);
  var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
  cameraNY.up.set(0, 0, -1);
  cameraNY.lookAt(new Vector3(0, -1, 0));
  this.add(cameraNY);
  var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
  cameraPZ.up.set(0, -1, 0);
  cameraPZ.lookAt(new Vector3(0, 0, 1));
  this.add(cameraPZ);
  var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
  cameraNZ.up.set(0, -1, 0);
  cameraNZ.lookAt(new Vector3(0, 0, -1));
  this.add(cameraNZ);
  options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };
  this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
  this.renderTarget.texture.name = "CubeCamera";
  this.update = function(renderer, scene) {
    if (this.parent === null)
      this.updateMatrixWorld();
    var currentRenderTarget = renderer.getRenderTarget();
    var renderTarget = this.renderTarget;
    var generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
  };
  this.clear = function(renderer, color, depth, stencil) {
    var currentRenderTarget = renderer.getRenderTarget();
    var renderTarget = this.renderTarget;
    for (var i2 = 0; i2 < 6; i2++) {
      renderer.setRenderTarget(renderTarget, i2);
      renderer.clear(color, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  };
}
CubeCamera.prototype = Object.create(Object3D.prototype);
CubeCamera.prototype.constructor = CubeCamera;
function Clock(autoStart) {
  this.autoStart = autoStart !== void 0 ? autoStart : true;
  this.startTime = 0;
  this.oldTime = 0;
  this.elapsedTime = 0;
  this.running = false;
}
Object.assign(Clock.prototype, {
  start: function() {
    this.startTime = (typeof performance === "undefined" ? Date : performance).now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  },
  stop: function() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  },
  getElapsedTime: function() {
    this.getDelta();
    return this.elapsedTime;
  },
  getDelta: function() {
    var diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      var newTime = (typeof performance === "undefined" ? Date : performance).now();
      diff = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
});
function AudioListener() {
  Object3D.call(this);
  this.type = "AudioListener";
  this.context = AudioContext.getContext();
  this.gain = this.context.createGain();
  this.gain.connect(this.context.destination);
  this.filter = null;
  this.timeDelta = 0;
}
AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: AudioListener,
  getInput: function() {
    return this.gain;
  },
  removeFilter: function() {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
      this.gain.connect(this.context.destination);
      this.filter = null;
    }
    return this;
  },
  getFilter: function() {
    return this.filter;
  },
  setFilter: function(value) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
    } else {
      this.gain.disconnect(this.context.destination);
    }
    this.filter = value;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  },
  getMasterVolume: function() {
    return this.gain.gain.value;
  },
  setMasterVolume: function(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  },
  updateMatrixWorld: function() {
    var position = new Vector3();
    var quaternion = new Quaternion();
    var scale2 = new Vector3();
    var orientation = new Vector3();
    var clock = new Clock();
    return function updateMatrixWorld(force) {
      Object3D.prototype.updateMatrixWorld.call(this, force);
      var listener = this.context.listener;
      var up = this.up;
      this.timeDelta = clock.getDelta();
      this.matrixWorld.decompose(position, quaternion, scale2);
      orientation.set(0, 0, -1).applyQuaternion(quaternion);
      if (listener.positionX) {
        var endTime = this.context.currentTime + this.timeDelta;
        listener.positionX.linearRampToValueAtTime(position.x, endTime);
        listener.positionY.linearRampToValueAtTime(position.y, endTime);
        listener.positionZ.linearRampToValueAtTime(position.z, endTime);
        listener.forwardX.linearRampToValueAtTime(orientation.x, endTime);
        listener.forwardY.linearRampToValueAtTime(orientation.y, endTime);
        listener.forwardZ.linearRampToValueAtTime(orientation.z, endTime);
        listener.upX.linearRampToValueAtTime(up.x, endTime);
        listener.upY.linearRampToValueAtTime(up.y, endTime);
        listener.upZ.linearRampToValueAtTime(up.z, endTime);
      } else {
        listener.setPosition(position.x, position.y, position.z);
        listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
      }
    };
  }()
});
function Audio(listener) {
  Object3D.call(this);
  this.type = "Audio";
  this.listener = listener;
  this.context = listener.context;
  this.gain = this.context.createGain();
  this.gain.connect(listener.getInput());
  this.autoplay = false;
  this.buffer = null;
  this.detune = 0;
  this.loop = false;
  this.startTime = 0;
  this.offset = 0;
  this.playbackRate = 1;
  this.isPlaying = false;
  this.hasPlaybackControl = true;
  this.sourceType = "empty";
  this.filters = [];
}
Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Audio,
  getOutput: function() {
    return this.gain;
  },
  setNodeSource: function(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  },
  setMediaElementSource: function(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  },
  setBuffer: function(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay)
      this.play();
    return this;
  },
  play: function() {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    var source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.onended = this.onEnded.bind(this);
    this.startTime = this.context.currentTime;
    source.start(this.startTime, this.offset);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  },
  pause: function() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    if (this.isPlaying === true) {
      this.source.stop();
      this.source.onended = null;
      this.offset += (this.context.currentTime - this.startTime) * this.playbackRate;
      this.isPlaying = false;
    }
    return this;
  },
  stop: function() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.source.stop();
    this.source.onended = null;
    this.offset = 0;
    this.isPlaying = false;
    return this;
  },
  connect: function() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (var i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
        this.filters[i2 - 1].connect(this.filters[i2]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    return this;
  },
  disconnect: function() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (var i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
        this.filters[i2 - 1].disconnect(this.filters[i2]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    return this;
  },
  getFilters: function() {
    return this.filters;
  },
  setFilters: function(value) {
    if (!value)
      value = [];
    if (this.isPlaying === true) {
      this.disconnect();
      this.filters = value;
      this.connect();
    } else {
      this.filters = value;
    }
    return this;
  },
  setDetune: function(value) {
    this.detune = value;
    if (this.source.detune === void 0)
      return;
    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }
    return this;
  },
  getDetune: function() {
    return this.detune;
  },
  getFilter: function() {
    return this.getFilters()[0];
  },
  setFilter: function(filter2) {
    return this.setFilters(filter2 ? [filter2] : []);
  },
  setPlaybackRate: function(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }
    return this;
  },
  getPlaybackRate: function() {
    return this.playbackRate;
  },
  onEnded: function() {
    this.isPlaying = false;
  },
  getLoop: function() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  },
  setLoop: function(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  },
  getVolume: function() {
    return this.gain.gain.value;
  },
  setVolume: function(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
});
function PositionalAudio(listener) {
  Audio.call(this, listener);
  this.panner = this.context.createPanner();
  this.panner.panningModel = "HRTF";
  this.panner.connect(this.gain);
}
PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
  constructor: PositionalAudio,
  getOutput: function() {
    return this.panner;
  },
  getRefDistance: function() {
    return this.panner.refDistance;
  },
  setRefDistance: function(value) {
    this.panner.refDistance = value;
    return this;
  },
  getRolloffFactor: function() {
    return this.panner.rolloffFactor;
  },
  setRolloffFactor: function(value) {
    this.panner.rolloffFactor = value;
    return this;
  },
  getDistanceModel: function() {
    return this.panner.distanceModel;
  },
  setDistanceModel: function(value) {
    this.panner.distanceModel = value;
    return this;
  },
  getMaxDistance: function() {
    return this.panner.maxDistance;
  },
  setMaxDistance: function(value) {
    this.panner.maxDistance = value;
    return this;
  },
  setDirectionalCone: function(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.panner.coneInnerAngle = coneInnerAngle;
    this.panner.coneOuterAngle = coneOuterAngle;
    this.panner.coneOuterGain = coneOuterGain;
    return this;
  },
  updateMatrixWorld: function() {
    var position = new Vector3();
    var quaternion = new Quaternion();
    var scale2 = new Vector3();
    var orientation = new Vector3();
    return function updateMatrixWorld(force) {
      Object3D.prototype.updateMatrixWorld.call(this, force);
      if (this.hasPlaybackControl === true && this.isPlaying === false)
        return;
      this.matrixWorld.decompose(position, quaternion, scale2);
      orientation.set(0, 0, 1).applyQuaternion(quaternion);
      var panner = this.panner;
      if (panner.positionX) {
        var endTime = this.context.currentTime + this.listener.timeDelta;
        panner.positionX.linearRampToValueAtTime(position.x, endTime);
        panner.positionY.linearRampToValueAtTime(position.y, endTime);
        panner.positionZ.linearRampToValueAtTime(position.z, endTime);
        panner.orientationX.linearRampToValueAtTime(orientation.x, endTime);
        panner.orientationY.linearRampToValueAtTime(orientation.y, endTime);
        panner.orientationZ.linearRampToValueAtTime(orientation.z, endTime);
      } else {
        panner.setPosition(position.x, position.y, position.z);
        panner.setOrientation(orientation.x, orientation.y, orientation.z);
      }
    };
  }()
});
function AudioAnalyser(audio, fftSize) {
  this.analyser = audio.context.createAnalyser();
  this.analyser.fftSize = fftSize !== void 0 ? fftSize : 2048;
  this.data = new Uint8Array(this.analyser.frequencyBinCount);
  audio.getOutput().connect(this.analyser);
}
Object.assign(AudioAnalyser.prototype, {
  getFrequencyData: function() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  },
  getAverageFrequency: function() {
    var value = 0, data = this.getFrequencyData();
    for (var i2 = 0; i2 < data.length; i2++) {
      value += data[i2];
    }
    return value / data.length;
  }
});
function PropertyMixer(binding, typeName, valueSize) {
  this.binding = binding;
  this.valueSize = valueSize;
  var bufferType = Float64Array, mixFunction;
  switch (typeName) {
    case "quaternion":
      mixFunction = this._slerp;
      break;
    case "string":
    case "bool":
      bufferType = Array;
      mixFunction = this._select;
      break;
    default:
      mixFunction = this._lerp;
  }
  this.buffer = new bufferType(valueSize * 4);
  this._mixBufferRegion = mixFunction;
  this.cumulativeWeight = 0;
  this.useCount = 0;
  this.referenceCount = 0;
}
Object.assign(PropertyMixer.prototype, {
  accumulate: function(accuIndex, weight) {
    var buffer = this.buffer, stride = this.valueSize, offset2 = accuIndex * stride + stride, currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (var i2 = 0; i2 !== stride; ++i2) {
        buffer[offset2 + i2] = buffer[i2];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      var mix = weight / currentWeight;
      this._mixBufferRegion(buffer, offset2, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  },
  apply: function(accuIndex) {
    var stride = this.valueSize, buffer = this.buffer, offset2 = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;
    this.cumulativeWeight = 0;
    if (weight < 1) {
      var originalValueOffset = stride * 3;
      this._mixBufferRegion(buffer, offset2, originalValueOffset, 1 - weight, stride);
    }
    for (var i2 = stride, e2 = stride + stride; i2 !== e2; ++i2) {
      if (buffer[i2] !== buffer[i2 + stride]) {
        binding.setValue(buffer, offset2);
        break;
      }
    }
  },
  saveOriginalState: function() {
    var binding = this.binding;
    var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3;
    binding.getValue(buffer, originalValueOffset);
    for (var i2 = stride, e2 = originalValueOffset; i2 !== e2; ++i2) {
      buffer[i2] = buffer[originalValueOffset + i2 % stride];
    }
    this.cumulativeWeight = 0;
  },
  restoreOriginalState: function() {
    var originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  },
  _select: function(buffer, dstOffset, srcOffset, t2, stride) {
    if (t2 >= 0.5) {
      for (var i2 = 0; i2 !== stride; ++i2) {
        buffer[dstOffset + i2] = buffer[srcOffset + i2];
      }
    }
  },
  _slerp: function(buffer, dstOffset, srcOffset, t2) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t2);
  },
  _lerp: function(buffer, dstOffset, srcOffset, t2, stride) {
    var s2 = 1 - t2;
    for (var i2 = 0; i2 !== stride; ++i2) {
      var j = dstOffset + i2;
      buffer[j] = buffer[j] * s2 + buffer[srcOffset + i2] * t2;
    }
  }
});
var RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
function Composite(targetGroup, path, optionalParsedPath) {
  var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
  this._targetGroup = targetGroup;
  this._bindings = targetGroup.subscribe_(path, parsedPath);
}
Object.assign(Composite.prototype, {
  getValue: function(array, offset2) {
    this.bind();
    var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0)
      binding.getValue(array, offset2);
  },
  setValue: function(array, offset2) {
    var bindings = this._bindings;
    for (var i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].setValue(array, offset2);
    }
  },
  bind: function() {
    var bindings = this._bindings;
    for (var i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].bind();
    }
  },
  unbind: function() {
    var bindings = this._bindings;
    for (var i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].unbind();
    }
  }
});
function PropertyBinding(rootNode, path, parsedPath) {
  this.path = path;
  this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
  this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
  this.rootNode = rootNode;
}
Object.assign(PropertyBinding, {
  Composite,
  create: function(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  },
  sanitizeNodeName: function() {
    var reservedRe = new RegExp("[" + RESERVED_CHARS_RE + "]", "g");
    return function sanitizeNodeName(name) {
      return name.replace(/\s/g, "_").replace(reservedRe, "");
    };
  }(),
  parseTrackName: function() {
    var wordChar = "[^" + RESERVED_CHARS_RE + "]";
    var wordCharOrDot = "[^" + RESERVED_CHARS_RE.replace("\\.", "") + "]";
    var directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", wordChar);
    var nodeRe = /(WCOD+)?/.source.replace("WCOD", wordCharOrDot);
    var objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", wordChar);
    var propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", wordChar);
    var trackRe = new RegExp("^" + directoryRe + nodeRe + objectRe + propertyRe + "$");
    var supportedObjectNames = ["material", "materials", "bones"];
    return function parseTrackName(trackName) {
      var matches = trackRe.exec(trackName);
      if (!matches) {
        throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
      }
      var results = {
        nodeName: matches[2],
        objectName: matches[3],
        objectIndex: matches[4],
        propertyName: matches[5],
        propertyIndex: matches[6]
      };
      var lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
      if (lastDot !== void 0 && lastDot !== -1) {
        var objectName = results.nodeName.substring(lastDot + 1);
        if (supportedObjectNames.indexOf(objectName) !== -1) {
          results.nodeName = results.nodeName.substring(0, lastDot);
          results.objectName = objectName;
        }
      }
      if (results.propertyName === null || results.propertyName.length === 0) {
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
      }
      return results;
    };
  }(),
  findNode: function(root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      var bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      var searchNodeSubtree = function(children2) {
        for (var i2 = 0; i2 < children2.length; i2++) {
          var childNode = children2[i2];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          var result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      };
      var subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
});
Object.assign(PropertyBinding.prototype, {
  _getValue_unavailable: function() {
  },
  _setValue_unavailable: function() {
  },
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [
    function getValue_direct(buffer, offset2) {
      buffer[offset2] = this.node[this.propertyName];
    },
    function getValue_array(buffer, offset2) {
      var source = this.resolvedProperty;
      for (var i2 = 0, n2 = source.length; i2 !== n2; ++i2) {
        buffer[offset2++] = source[i2];
      }
    },
    function getValue_arrayElement(buffer, offset2) {
      buffer[offset2] = this.resolvedProperty[this.propertyIndex];
    },
    function getValue_toArray(buffer, offset2) {
      this.resolvedProperty.toArray(buffer, offset2);
    }
  ],
  SetterByBindingTypeAndVersioning: [
    [
      function setValue_direct(buffer, offset2) {
        this.targetObject[this.propertyName] = buffer[offset2];
      },
      function setValue_direct_setNeedsUpdate(buffer, offset2) {
        this.targetObject[this.propertyName] = buffer[offset2];
        this.targetObject.needsUpdate = true;
      },
      function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset2) {
        this.targetObject[this.propertyName] = buffer[offset2];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_array(buffer, offset2) {
        var dest = this.resolvedProperty;
        for (var i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
          dest[i2] = buffer[offset2++];
        }
      },
      function setValue_array_setNeedsUpdate(buffer, offset2) {
        var dest = this.resolvedProperty;
        for (var i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
          dest[i2] = buffer[offset2++];
        }
        this.targetObject.needsUpdate = true;
      },
      function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset2) {
        var dest = this.resolvedProperty;
        for (var i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
          dest[i2] = buffer[offset2++];
        }
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_arrayElement(buffer, offset2) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset2];
      },
      function setValue_arrayElement_setNeedsUpdate(buffer, offset2) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset2];
        this.targetObject.needsUpdate = true;
      },
      function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset2) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset2];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_fromArray(buffer, offset2) {
        this.resolvedProperty.fromArray(buffer, offset2);
      },
      function setValue_fromArray_setNeedsUpdate(buffer, offset2) {
        this.resolvedProperty.fromArray(buffer, offset2);
        this.targetObject.needsUpdate = true;
      },
      function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset2) {
        this.resolvedProperty.fromArray(buffer, offset2);
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ]
  ],
  getValue: function getValue_unbound(targetArray, offset2) {
    this.bind();
    this.getValue(targetArray, offset2);
  },
  setValue: function getValue_unbound2(sourceArray, offset2) {
    this.bind();
    this.setValue(sourceArray, offset2);
  },
  bind: function() {
    var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      var objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (var i2 = 0; i2 < targetObject.length; i2++) {
            if (targetObject[i2].name === objectIndex) {
              objectIndex = i2;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    var nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      var nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    var versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    var bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          for (var i2 = 0; i2 < this.node.geometry.morphAttributes.position.length; i2++) {
            if (targetObject.geometry.morphAttributes.position[i2].name === propertyIndex) {
              propertyIndex = i2;
              break;
            }
          }
        } else {
          if (!targetObject.geometry.morphTargets) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
            return;
          }
          for (var i2 = 0; i2 < this.node.geometry.morphTargets.length; i2++) {
            if (targetObject.geometry.morphTargets[i2].name === propertyIndex) {
              propertyIndex = i2;
              break;
            }
          }
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  },
  unbind: function() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
});
//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(PropertyBinding.prototype, {
  _getValue_unbound: PropertyBinding.prototype.getValue,
  _setValue_unbound: PropertyBinding.prototype.setValue
});
function AnimationObjectGroup() {
  this.uuid = _Math.generateUUID();
  this._objects = Array.prototype.slice.call(arguments);
  this.nCachedObjects_ = 0;
  var indices = {};
  this._indicesByUUID = indices;
  for (var i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
    indices[arguments[i2].uuid] = i2;
  }
  this._paths = [];
  this._parsedPaths = [];
  this._bindings = [];
  this._bindingsIndicesByPath = {};
  var scope = this;
  this.stats = {
    objects: {
      get total() {
        return scope._objects.length;
      },
      get inUse() {
        return this.total - scope.nCachedObjects_;
      }
    },
    get bindingsPerObject() {
      return scope._bindings.length;
    }
  };
}
Object.assign(AnimationObjectGroup.prototype, {
  isAnimationObjectGroup: true,
  add: function() {
    var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, knownObject = void 0;
    for (var i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
      var object = arguments[i2], uuid = object.uuid, index2 = indicesByUUID[uuid];
      if (index2 === void 0) {
        index2 = nObjects++;
        indicesByUUID[uuid] = index2;
        objects.push(object);
        for (var j = 0, m2 = nBindings; j !== m2; ++j) {
          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
        }
      } else if (index2 < nCachedObjects) {
        knownObject = objects[index2];
        var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index2;
        objects[index2] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object;
        for (var j = 0, m2 = nBindings; j !== m2; ++j) {
          var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index2];
          bindingsForPath[index2] = lastCached;
          if (binding === void 0) {
            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
          }
          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index2] !== knownObject) {
        console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  },
  remove: function() {
    var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    for (var i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
      var object = arguments[i2], uuid = object.uuid, index2 = indicesByUUID[uuid];
      if (index2 !== void 0 && index2 >= nCachedObjects) {
        var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index2;
        objects[index2] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object;
        for (var j = 0, m2 = nBindings; j !== m2; ++j) {
          var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index2];
          bindingsForPath[index2] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  },
  uncache: function() {
    var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    for (var i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
      var object = arguments[i2], uuid = object.uuid, index2 = indicesByUUID[uuid];
      if (index2 !== void 0) {
        delete indicesByUUID[uuid];
        if (index2 < nCachedObjects) {
          var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
          indicesByUUID[lastCachedObject.uuid] = index2;
          objects[index2] = lastCachedObject;
          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop();
          for (var j = 0, m2 = nBindings; j !== m2; ++j) {
            var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
            bindingsForPath[index2] = lastCached;
            bindingsForPath[firstActiveIndex] = last;
            bindingsForPath.pop();
          }
        } else {
          var lastIndex = --nObjects, lastObject = objects[lastIndex];
          indicesByUUID[lastObject.uuid] = index2;
          objects[index2] = lastObject;
          objects.pop();
          for (var j = 0, m2 = nBindings; j !== m2; ++j) {
            var bindingsForPath = bindings[j];
            bindingsForPath[index2] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  },
  subscribe_: function(path, parsedPath) {
    var indicesByPath = this._bindingsIndicesByPath, index2 = indicesByPath[path], bindings = this._bindings;
    if (index2 !== void 0)
      return bindings[index2];
    var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
    index2 = bindings.length;
    indicesByPath[path] = index2;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);
    for (var i2 = nCachedObjects, n2 = objects.length; i2 !== n2; ++i2) {
      var object = objects[i2];
      bindingsForPath[i2] = new PropertyBinding(object, path, parsedPath);
    }
    return bindingsForPath;
  },
  unsubscribe_: function(path) {
    var indicesByPath = this._bindingsIndicesByPath, index2 = indicesByPath[path];
    if (index2 !== void 0) {
      var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index2;
      bindings[index2] = lastBindings;
      bindings.pop();
      parsedPaths[index2] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index2] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
});
function AnimationAction(mixer, clip, localRoot) {
  this._mixer = mixer;
  this._clip = clip;
  this._localRoot = localRoot || null;
  var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
  var interpolantSettings = {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  };
  for (var i2 = 0; i2 !== nTracks; ++i2) {
    var interpolant = tracks[i2].createInterpolant(null);
    interpolants[i2] = interpolant;
    interpolant.settings = interpolantSettings;
  }
  this._interpolantSettings = interpolantSettings;
  this._interpolants = interpolants;
  this._propertyBindings = new Array(nTracks);
  this._cacheIndex = null;
  this._byClipCacheIndex = null;
  this._timeScaleInterpolant = null;
  this._weightInterpolant = null;
  this.loop = LoopRepeat;
  this._loopCount = -1;
  this._startTime = null;
  this.time = 0;
  this.timeScale = 1;
  this._effectiveTimeScale = 1;
  this.weight = 1;
  this._effectiveWeight = 1;
  this.repetitions = Infinity;
  this.paused = false;
  this.enabled = true;
  this.clampWhenFinished = false;
  this.zeroSlopeAtStart = true;
  this.zeroSlopeAtEnd = true;
}
Object.assign(AnimationAction.prototype, {
  play: function() {
    this._mixer._activateAction(this);
    return this;
  },
  stop: function() {
    this._mixer._deactivateAction(this);
    return this.reset();
  },
  reset: function() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  },
  isRunning: function() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  },
  isScheduled: function() {
    return this._mixer._isActiveAction(this);
  },
  startAt: function(time) {
    this._startTime = time;
    return this;
  },
  setLoop: function(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  },
  setEffectiveWeight: function(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  },
  getEffectiveWeight: function() {
    return this._effectiveWeight;
  },
  fadeIn: function(duration) {
    return this._scheduleFading(duration, 0, 1);
  },
  fadeOut: function(duration) {
    return this._scheduleFading(duration, 1, 0);
  },
  crossFadeFrom: function(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  },
  crossFadeTo: function(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  },
  stopFading: function() {
    var weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  },
  setEffectiveTimeScale: function(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  },
  getEffectiveTimeScale: function() {
    return this._effectiveTimeScale;
  },
  setDuration: function(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  },
  syncWith: function(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  },
  halt: function(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  },
  warp: function(startTimeScale, endTimeScale, duration) {
    var mixer = this._mixer, now2 = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    var times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    times[1] = now2 + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  },
  stopWarping: function() {
    var timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  },
  getMixer: function() {
    return this._mixer;
  },
  getClip: function() {
    return this._clip;
  },
  getRoot: function() {
    return this._localRoot || this._mixer._root;
  },
  _update: function(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time);
      return;
    }
    var startTime = this._startTime;
    if (startTime !== null) {
      var timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        return;
      }
      this._startTime = null;
      deltaTime = timeDirection * timeRunning;
    }
    deltaTime *= this._updateTimeScale(time);
    var clipTime = this._updateTime(deltaTime);
    var weight = this._updateWeight(time);
    if (weight > 0) {
      var interpolants = this._interpolants;
      var propertyMixers = this._propertyBindings;
      for (var j = 0, m2 = interpolants.length; j !== m2; ++j) {
        interpolants[j].evaluate(clipTime);
        propertyMixers[j].accumulate(accuIndex, weight);
      }
    }
  },
  _updateWeight: function(time) {
    var weight = 0;
    if (this.enabled) {
      weight = this.weight;
      var interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        var interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  },
  _updateTimeScale: function(time) {
    var timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      var interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        var interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  },
  _updateTime: function(deltaTime) {
    var time = this.time + deltaTime;
    var duration = this._clip.duration;
    var loop2 = this.loop;
    var loopCount = this._loopCount;
    var pingPong = loop2 === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1)
        return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }
    if (loop2 === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }
        if (this.clampWhenFinished)
          this.paused = true;
        else
          this.enabled = false;
        this.time = time;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        var loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        var pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 1) {
            var atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      } else {
        this.time = time;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time;
      }
    }
    return time;
  },
  _setEndings: function(atStart, atEnd, pingPong) {
    var settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  },
  _scheduleFading: function(duration, weightNow, weightThen) {
    var mixer = this._mixer, now2 = mixer.time, interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    var times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    values[0] = weightNow;
    times[1] = now2 + duration;
    values[1] = weightThen;
    return this;
  }
});
function AnimationMixer(root) {
  this._root = root;
  this._initMemoryManager();
  this._accuIndex = 0;
  this.time = 0;
  this.timeScale = 1;
}
AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: AnimationMixer,
  _bindAction: function(action, prototypeAction) {
    var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (var i2 = 0; i2 !== nTracks; ++i2) {
      var track = tracks[i2], trackName = track.name, binding = bindingsByName[trackName];
      if (binding !== void 0) {
        bindings[i2] = binding;
      } else {
        binding = bindings[i2];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        var path = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i2] = binding;
      }
      interpolants[i2].resultBuffer = binding.buffer;
    }
  },
  _activateAction: function(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      var bindings = action._propertyBindings;
      for (var i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
        var binding = bindings[i2];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  },
  _deactivateAction: function(action) {
    if (this._isActiveAction(action)) {
      var bindings = action._propertyBindings;
      for (var i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
        var binding = bindings[i2];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  },
  _initMemoryManager: function() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    var scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  },
  _isActiveAction: function(action) {
    var index2 = action._cacheIndex;
    return index2 !== null && index2 < this._nActiveActions;
  },
  _addInactiveAction: function(action, clipUuid, rootUuid) {
    var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      var knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  },
  _removeInactiveAction: function(action) {
    var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    var actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  },
  _removeInactiveBindingsForAction: function(action) {
    var bindings = action._propertyBindings;
    for (var i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
      var binding = bindings[i2];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  },
  _lendAction: function(action) {
    var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  },
  _takeBackAction: function(action) {
    var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  },
  _addInactiveBinding: function(binding, rootUuid, trackName) {
    var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  },
  _removeInactiveBinding: function(binding) {
    var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    remove_empty_map: {
      for (var _2 in bindingByName)
        break remove_empty_map;
      delete bindingsByRoot[rootUuid];
    }
  },
  _lendBinding: function(binding) {
    var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  },
  _takeBackBinding: function(binding) {
    var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  },
  _lendControlInterpolant: function() {
    var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  },
  _takeBackControlInterpolant: function(interpolant) {
    var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  },
  _controlInterpolantsResultBuffer: new Float32Array(1),
  clipAction: function(clip, optionalRoot) {
    var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
    if (actionsForClip !== void 0) {
      var existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null)
      return null;
    var newAction = new AnimationAction(this, clipObject, optionalRoot);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  },
  existingAction: function(clip, optionalRoot) {
    var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  },
  stopAllAction: function() {
    var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
    this._nActiveActions = 0;
    this._nActiveBindings = 0;
    for (var i2 = 0; i2 !== nActions; ++i2) {
      actions[i2].reset();
    }
    for (var i2 = 0; i2 !== nBindings; ++i2) {
      bindings[i2].useCount = 0;
    }
    return this;
  },
  update: function(deltaTime) {
    deltaTime *= this.timeScale;
    var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (var i2 = 0; i2 !== nActions; ++i2) {
      var action = actions[i2];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }
    var bindings = this._bindings, nBindings = this._nActiveBindings;
    for (var i2 = 0; i2 !== nBindings; ++i2) {
      bindings[i2].apply(accuIndex);
    }
    return this;
  },
  getRoot: function() {
    return this._root;
  },
  uncacheClip: function(clip) {
    var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      var actionsToRemove = actionsForClip.knownActions;
      for (var i2 = 0, n2 = actionsToRemove.length; i2 !== n2; ++i2) {
        var action = actionsToRemove[i2];
        this._deactivateAction(action);
        var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  },
  uncacheRoot: function(root) {
    var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (var clipUuid in actionsByClip) {
      var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (var trackName in bindingByName) {
        var binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  },
  uncacheAction: function(clip, optionalRoot) {
    var action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
});
function Uniform(value) {
  if (typeof value === "string") {
    console.warn("THREE.Uniform: Type parameter is no longer needed.");
    value = arguments[1];
  }
  this.value = value;
}
Uniform.prototype.clone = function() {
  return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
};
function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
  InterleavedBuffer.call(this, array, stride);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
  constructor: InstancedInterleavedBuffer,
  isInstancedInterleavedBuffer: true,
  copy: function(source) {
    InterleavedBuffer.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
});
function Raycaster(origin, direction, near, far) {
  this.ray = new Ray(origin, direction);
  this.near = near || 0;
  this.far = far || Infinity;
  this.params = {
    Mesh: {},
    Line: {},
    LOD: {},
    Points: { threshold: 1 },
    Sprite: {}
  };
  Object.defineProperties(this.params, {
    PointCloud: {
      get: function() {
        console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
        return this.Points;
      }
    }
  });
}
function ascSort(a2, b2) {
  return a2.distance - b2.distance;
}
function intersectObject(object, raycaster, intersects2, recursive) {
  if (object.visible === false)
    return;
  object.raycast(raycaster, intersects2);
  if (recursive === true) {
    var children2 = object.children;
    for (var i2 = 0, l2 = children2.length; i2 < l2; i2++) {
      intersectObject(children2[i2], raycaster, intersects2, true);
    }
  }
}
Object.assign(Raycaster.prototype, {
  linePrecision: 1,
  set: function(origin, direction) {
    this.ray.set(origin, direction);
  },
  setFromCamera: function(coords, camera) {
    if (camera && camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
    } else if (camera && camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
    } else {
      console.error("THREE.Raycaster: Unsupported camera type.");
    }
  },
  intersectObject: function(object, recursive, optionalTarget) {
    var intersects2 = optionalTarget || [];
    intersectObject(object, this, intersects2, recursive);
    intersects2.sort(ascSort);
    return intersects2;
  },
  intersectObjects: function(objects, recursive, optionalTarget) {
    var intersects2 = optionalTarget || [];
    if (Array.isArray(objects) === false) {
      console.warn("THREE.Raycaster.intersectObjects: objects is not an Array.");
      return intersects2;
    }
    for (var i2 = 0, l2 = objects.length; i2 < l2; i2++) {
      intersectObject(objects[i2], this, intersects2, recursive);
    }
    intersects2.sort(ascSort);
    return intersects2;
  }
});
function Spherical(radius, phi, theta) {
  this.radius = radius !== void 0 ? radius : 1;
  this.phi = phi !== void 0 ? phi : 0;
  this.theta = theta !== void 0 ? theta : 0;
  return this;
}
Object.assign(Spherical.prototype, {
  set: function(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  },
  makeSafe: function() {
    var EPS = 1e-6;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  },
  setFromVector3: function(v2) {
    return this.setFromCartesianCoords(v2.x, v2.y, v2.z);
  },
  setFromCartesianCoords: function(x2, y, z2) {
    this.radius = Math.sqrt(x2 * x2 + y * y + z2 * z2);
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x2, z2);
      this.phi = Math.acos(_Math.clamp(y / this.radius, -1, 1));
    }
    return this;
  }
});
function Cylindrical(radius, theta, y) {
  this.radius = radius !== void 0 ? radius : 1;
  this.theta = theta !== void 0 ? theta : 0;
  this.y = y !== void 0 ? y : 0;
  return this;
}
Object.assign(Cylindrical.prototype, {
  set: function(radius, theta, y) {
    this.radius = radius;
    this.theta = theta;
    this.y = y;
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(other) {
    this.radius = other.radius;
    this.theta = other.theta;
    this.y = other.y;
    return this;
  },
  setFromVector3: function(v2) {
    return this.setFromCartesianCoords(v2.x, v2.y, v2.z);
  },
  setFromCartesianCoords: function(x2, y, z2) {
    this.radius = Math.sqrt(x2 * x2 + z2 * z2);
    this.theta = Math.atan2(x2, z2);
    this.y = y;
    return this;
  }
});
function Box2(min, max) {
  this.min = min !== void 0 ? min : new Vector2(Infinity, Infinity);
  this.max = max !== void 0 ? max : new Vector2(-Infinity, -Infinity);
}
Object.assign(Box2.prototype, {
  set: function(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  },
  setFromPoints: function(points) {
    this.makeEmpty();
    for (var i2 = 0, il = points.length; i2 < il; i2++) {
      this.expandByPoint(points[i2]);
    }
    return this;
  },
  setFromCenterAndSize: function() {
    var v1 = new Vector2();
    return function setFromCenterAndSize(center, size) {
      var halfSize = v1.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    };
  }(),
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  },
  isEmpty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  getCenter: function(target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .getCenter() target is now required");
      target = new Vector2();
    }
    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function(target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .getSize() target is now required");
      target = new Vector2();
    }
    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
  },
  expandByPoint: function(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  },
  containsPoint: function(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
  },
  containsBox: function(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  },
  getParameter: function(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .getParameter() target is now required");
      target = new Vector2();
    }
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
  },
  intersectsBox: function(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
  },
  clampPoint: function(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .clampPoint() target is now required");
      target = new Vector2();
    }
    return target.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function() {
    var v1 = new Vector2();
    return function distanceToPoint(point) {
      var clampedPoint = v1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    };
  }(),
  intersect: function(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  },
  union: function(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  translate: function(offset2) {
    this.min.add(offset2);
    this.max.add(offset2);
    return this;
  },
  equals: function(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
});
function Line3(start, end) {
  this.start = start !== void 0 ? start : new Vector3();
  this.end = end !== void 0 ? end : new Vector3();
}
Object.assign(Line3.prototype, {
  set: function(start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  },
  getCenter: function(target) {
    if (target === void 0) {
      console.warn("THREE.Line3: .getCenter() target is now required");
      target = new Vector3();
    }
    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  },
  delta: function(target) {
    if (target === void 0) {
      console.warn("THREE.Line3: .delta() target is now required");
      target = new Vector3();
    }
    return target.subVectors(this.end, this.start);
  },
  distanceSq: function() {
    return this.start.distanceToSquared(this.end);
  },
  distance: function() {
    return this.start.distanceTo(this.end);
  },
  at: function(t2, target) {
    if (target === void 0) {
      console.warn("THREE.Line3: .at() target is now required");
      target = new Vector3();
    }
    return this.delta(target).multiplyScalar(t2).add(this.start);
  },
  closestPointToPointParameter: function() {
    var startP = new Vector3();
    var startEnd = new Vector3();
    return function closestPointToPointParameter(point, clampToLine) {
      startP.subVectors(point, this.start);
      startEnd.subVectors(this.end, this.start);
      var startEnd2 = startEnd.dot(startEnd);
      var startEnd_startP = startEnd.dot(startP);
      var t2 = startEnd_startP / startEnd2;
      if (clampToLine) {
        t2 = _Math.clamp(t2, 0, 1);
      }
      return t2;
    };
  }(),
  closestPointToPoint: function(point, clampToLine, target) {
    var t2 = this.closestPointToPointParameter(point, clampToLine);
    if (target === void 0) {
      console.warn("THREE.Line3: .closestPointToPoint() target is now required");
      target = new Vector3();
    }
    return this.delta(target).multiplyScalar(t2).add(this.start);
  },
  applyMatrix4: function(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  },
  equals: function(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
});
function ImmediateRenderObject(material) {
  Object3D.call(this);
  this.material = material;
  this.render = function() {
  };
}
ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
function VertexNormalsHelper(object, size, hex, linewidth) {
  this.object = object;
  this.size = size !== void 0 ? size : 1;
  var color = hex !== void 0 ? hex : 16711680;
  var width = linewidth !== void 0 ? linewidth : 1;
  var nNormals = 0;
  var objGeometry = this.object.geometry;
  if (objGeometry && objGeometry.isGeometry) {
    nNormals = objGeometry.faces.length * 3;
  } else if (objGeometry && objGeometry.isBufferGeometry) {
    nNormals = objGeometry.attributes.normal.count;
  }
  var geometry2 = new BufferGeometry();
  var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
  geometry2.addAttribute("position", positions);
  LineSegments.call(this, geometry2, new LineBasicMaterial({ color, linewidth: width }));
  this.matrixAutoUpdate = false;
  this.update();
}
VertexNormalsHelper.prototype = Object.create(LineSegments.prototype);
VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
VertexNormalsHelper.prototype.update = function() {
  var v1 = new Vector3();
  var v2 = new Vector3();
  var normalMatrix = new Matrix3();
  return function update3() {
    var keys = ["a", "b", "c"];
    this.object.updateMatrixWorld(true);
    normalMatrix.getNormalMatrix(this.object.matrixWorld);
    var matrixWorld = this.object.matrixWorld;
    var position = this.geometry.attributes.position;
    var objGeometry = this.object.geometry;
    if (objGeometry && objGeometry.isGeometry) {
      var vertices = objGeometry.vertices;
      var faces = objGeometry.faces;
      var idx = 0;
      for (var i2 = 0, l2 = faces.length; i2 < l2; i2++) {
        var face = faces[i2];
        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
          var vertex = vertices[face[keys[j]]];
          var normal = face.vertexNormals[j];
          v1.copy(vertex).applyMatrix4(matrixWorld);
          v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
          position.setXYZ(idx, v1.x, v1.y, v1.z);
          idx = idx + 1;
          position.setXYZ(idx, v2.x, v2.y, v2.z);
          idx = idx + 1;
        }
      }
    } else if (objGeometry && objGeometry.isBufferGeometry) {
      var objPos = objGeometry.attributes.position;
      var objNorm = objGeometry.attributes.normal;
      var idx = 0;
      for (var j = 0, jl = objPos.count; j < jl; j++) {
        v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
        v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
        v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
        position.setXYZ(idx, v1.x, v1.y, v1.z);
        idx = idx + 1;
        position.setXYZ(idx, v2.x, v2.y, v2.z);
        idx = idx + 1;
      }
    }
    position.needsUpdate = true;
  };
}();
function SpotLightHelper(light, color) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color;
  var geometry2 = new BufferGeometry();
  var positions = [
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    -1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    -1,
    1
  ];
  for (var i2 = 0, j = 1, l2 = 32; i2 < l2; i2++, j++) {
    var p1 = i2 / l2 * Math.PI * 2;
    var p2 = j / l2 * Math.PI * 2;
    positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
  }
  geometry2.addAttribute("position", new Float32BufferAttribute(positions, 3));
  var material = new LineBasicMaterial({ fog: false });
  this.cone = new LineSegments(geometry2, material);
  this.add(this.cone);
  this.update();
}
SpotLightHelper.prototype = Object.create(Object3D.prototype);
SpotLightHelper.prototype.constructor = SpotLightHelper;
SpotLightHelper.prototype.dispose = function() {
  this.cone.geometry.dispose();
  this.cone.material.dispose();
};
SpotLightHelper.prototype.update = function() {
  var vector = new Vector3();
  return function update3() {
    this.light.updateMatrixWorld();
    var coneLength = this.light.distance ? this.light.distance : 1e3;
    var coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);
    vector.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(vector);
    if (this.color !== void 0) {
      this.cone.material.color.set(this.color);
    } else {
      this.cone.material.color.copy(this.light.color);
    }
  };
}();
function getBoneList(object) {
  var boneList = [];
  if (object && object.isBone) {
    boneList.push(object);
  }
  for (var i2 = 0; i2 < object.children.length; i2++) {
    boneList.push.apply(boneList, getBoneList(object.children[i2]));
  }
  return boneList;
}
function SkeletonHelper(object) {
  var bones = getBoneList(object);
  var geometry2 = new BufferGeometry();
  var vertices = [];
  var colors = [];
  var color1 = new Color(0, 0, 1);
  var color2 = new Color(0, 1, 0);
  for (var i2 = 0; i2 < bones.length; i2++) {
    var bone = bones[i2];
    if (bone.parent && bone.parent.isBone) {
      vertices.push(0, 0, 0);
      vertices.push(0, 0, 0);
      colors.push(color1.r, color1.g, color1.b);
      colors.push(color2.r, color2.g, color2.b);
    }
  }
  geometry2.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry2.addAttribute("color", new Float32BufferAttribute(colors, 3));
  var material = new LineBasicMaterial({ vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true });
  LineSegments.call(this, geometry2, material);
  this.root = object;
  this.bones = bones;
  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;
}
SkeletonHelper.prototype = Object.create(LineSegments.prototype);
SkeletonHelper.prototype.constructor = SkeletonHelper;
SkeletonHelper.prototype.updateMatrixWorld = function() {
  var vector = new Vector3();
  var boneMatrix = new Matrix4();
  var matrixWorldInv = new Matrix4();
  return function updateMatrixWorld(force) {
    var bones = this.bones;
    var geometry2 = this.geometry;
    var position = geometry2.getAttribute("position");
    matrixWorldInv.getInverse(this.root.matrixWorld);
    for (var i2 = 0, j = 0; i2 < bones.length; i2++) {
      var bone = bones[i2];
      if (bone.parent && bone.parent.isBone) {
        boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
        vector.setFromMatrixPosition(boneMatrix);
        position.setXYZ(j, vector.x, vector.y, vector.z);
        boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
        vector.setFromMatrixPosition(boneMatrix);
        position.setXYZ(j + 1, vector.x, vector.y, vector.z);
        j += 2;
      }
    }
    geometry2.getAttribute("position").needsUpdate = true;
    Object3D.prototype.updateMatrixWorld.call(this, force);
  };
}();
function PointLightHelper(light, sphereSize, color) {
  this.light = light;
  this.light.updateMatrixWorld();
  this.color = color;
  var geometry2 = new SphereBufferGeometry(sphereSize, 4, 2);
  var material = new MeshBasicMaterial({ wireframe: true, fog: false });
  Mesh.call(this, geometry2, material);
  this.matrix = this.light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.update();
}
PointLightHelper.prototype = Object.create(Mesh.prototype);
PointLightHelper.prototype.constructor = PointLightHelper;
PointLightHelper.prototype.dispose = function() {
  this.geometry.dispose();
  this.material.dispose();
};
PointLightHelper.prototype.update = function() {
  if (this.color !== void 0) {
    this.material.color.set(this.color);
  } else {
    this.material.color.copy(this.light.color);
  }
};
function RectAreaLightHelper(light, color) {
  this.type = "RectAreaLightHelper";
  this.light = light;
  this.color = color;
  var positions = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
  var geometry2 = new BufferGeometry();
  geometry2.addAttribute("position", new Float32BufferAttribute(positions, 3));
  geometry2.computeBoundingSphere();
  var material = new LineBasicMaterial({ fog: false });
  Line.call(this, geometry2, material);
  var positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
  var geometry22 = new BufferGeometry();
  geometry22.addAttribute("position", new Float32BufferAttribute(positions2, 3));
  geometry22.computeBoundingSphere();
  this.add(new Mesh(geometry22, new MeshBasicMaterial({ side: BackSide, fog: false })));
  this.update();
}
RectAreaLightHelper.prototype = Object.create(Line.prototype);
RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;
RectAreaLightHelper.prototype.update = function() {
  this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1);
  if (this.color !== void 0) {
    this.material.color.set(this.color);
    this.children[0].material.color.set(this.color);
  } else {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    var c2 = this.material.color;
    var max = Math.max(c2.r, c2.g, c2.b);
    if (max > 1)
      c2.multiplyScalar(1 / max);
    this.children[0].material.color.copy(this.material.color);
  }
};
RectAreaLightHelper.prototype.dispose = function() {
  this.geometry.dispose();
  this.material.dispose();
  this.children[0].geometry.dispose();
  this.children[0].material.dispose();
};
function HemisphereLightHelper(light, size, color) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color;
  var geometry2 = new OctahedronBufferGeometry(size);
  geometry2.rotateY(Math.PI * 0.5);
  this.material = new MeshBasicMaterial({ wireframe: true, fog: false });
  if (this.color === void 0)
    this.material.vertexColors = VertexColors;
  var position = geometry2.getAttribute("position");
  var colors = new Float32Array(position.count * 3);
  geometry2.addAttribute("color", new BufferAttribute(colors, 3));
  this.add(new Mesh(geometry2, this.material));
  this.update();
}
HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
HemisphereLightHelper.prototype.dispose = function() {
  this.children[0].geometry.dispose();
  this.children[0].material.dispose();
};
HemisphereLightHelper.prototype.update = function() {
  var vector = new Vector3();
  var color1 = new Color();
  var color2 = new Color();
  return function update3() {
    var mesh = this.children[0];
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      var colors = mesh.geometry.getAttribute("color");
      color1.copy(this.light.color);
      color2.copy(this.light.groundColor);
      for (var i2 = 0, l2 = colors.count; i2 < l2; i2++) {
        var color = i2 < l2 / 2 ? color1 : color2;
        colors.setXYZ(i2, color.r, color.g, color.b);
      }
      colors.needsUpdate = true;
    }
    mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
  };
}();
function LightProbeHelper(lightProbe, size) {
  this.lightProbe = lightProbe;
  this.size = size;
  var defines = {};
  defines["GAMMA_OUTPUT"] = "";
  var material = new ShaderMaterial({
    defines,
    uniforms: {
      sh: { value: this.lightProbe.sh.coefficients },
      intensity: { value: this.lightProbe.intensity }
    },
    vertexShader: [
      "varying vec3 vNormal;",
      "void main() {",
      "	vNormal = normalize( normalMatrix * normal );",
      "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
      "}"
    ].join("\n"),
    fragmentShader: [
      "#define RECIPROCAL_PI 0.318309886",
      "vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {",
      "	// matrix is assumed to be orthogonal",
      "	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );",
      "}",
      "vec3 linearToOutput( in vec3 a ) {",
      "	#ifdef GAMMA_OUTPUT",
      "		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );",
      "	#else",
      "		return a;",
      "	#endif",
      "}",
      "// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf",
      "vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {",
      "	// normal is assumed to have unit length",
      "	float x = normal.x, y = normal.y, z = normal.z;",
      "	// band 0",
      "	vec3 result = shCoefficients[ 0 ] * 0.886227;",
      "	// band 1",
      "	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;",
      "	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;",
      "	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;",
      "	// band 2",
      "	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;",
      "	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;",
      "	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );",
      "	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;",
      "	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );",
      "	return result;",
      "}",
      "uniform vec3 sh[ 9 ]; // sh coefficients",
      "uniform float intensity; // light probe intensity",
      "varying vec3 vNormal;",
      "void main() {",
      "	vec3 normal = normalize( vNormal );",
      "	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );",
      "	vec3 irradiance = shGetIrradianceAt( worldNormal, sh );",
      "	vec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;",
      "	outgoingLight = linearToOutput( outgoingLight );",
      "	gl_FragColor = vec4( outgoingLight, 1.0 );",
      "}"
    ].join("\n")
  });
  var geometry2 = new SphereBufferGeometry(1, 32, 16);
  Mesh.call(this, geometry2, material);
  this.onBeforeRender();
}
LightProbeHelper.prototype = Object.create(Mesh.prototype);
LightProbeHelper.prototype.constructor = LightProbeHelper;
LightProbeHelper.prototype.dispose = function() {
  this.geometry.dispose();
  this.material.dispose();
};
LightProbeHelper.prototype.onBeforeRender = function() {
  return function update3() {
    this.position.copy(this.lightProbe.position);
    this.scale.set(1, 1, 1).multiplyScalar(this.size);
    this.material.uniforms.intensity.value = this.lightProbe.intensity;
  };
}();
function GridHelper(size, divisions, color1, color2) {
  size = size || 10;
  divisions = divisions || 10;
  color1 = new Color(color1 !== void 0 ? color1 : 4473924);
  color2 = new Color(color2 !== void 0 ? color2 : 8947848);
  var center = divisions / 2;
  var step = size / divisions;
  var halfSize = size / 2;
  var vertices = [], colors = [];
  for (var i2 = 0, j = 0, k2 = -halfSize; i2 <= divisions; i2++, k2 += step) {
    vertices.push(-halfSize, 0, k2, halfSize, 0, k2);
    vertices.push(k2, 0, -halfSize, k2, 0, halfSize);
    var color = i2 === center ? color1 : color2;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
  }
  var geometry2 = new BufferGeometry();
  geometry2.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry2.addAttribute("color", new Float32BufferAttribute(colors, 3));
  var material = new LineBasicMaterial({ vertexColors: VertexColors });
  LineSegments.call(this, geometry2, material);
}
GridHelper.prototype = Object.assign(Object.create(LineSegments.prototype), {
  constructor: GridHelper,
  copy: function(source) {
    LineSegments.prototype.copy.call(this, source);
    this.geometry.copy(source.geometry);
    this.material.copy(source.material);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
  radius = radius || 10;
  radials = radials || 16;
  circles = circles || 8;
  divisions = divisions || 64;
  color1 = new Color(color1 !== void 0 ? color1 : 4473924);
  color2 = new Color(color2 !== void 0 ? color2 : 8947848);
  var vertices = [];
  var colors = [];
  var x2, z2;
  var v2, i2, j, r2, color;
  for (i2 = 0; i2 <= radials; i2++) {
    v2 = i2 / radials * (Math.PI * 2);
    x2 = Math.sin(v2) * radius;
    z2 = Math.cos(v2) * radius;
    vertices.push(0, 0, 0);
    vertices.push(x2, 0, z2);
    color = i2 & 1 ? color1 : color2;
    colors.push(color.r, color.g, color.b);
    colors.push(color.r, color.g, color.b);
  }
  for (i2 = 0; i2 <= circles; i2++) {
    color = i2 & 1 ? color1 : color2;
    r2 = radius - radius / circles * i2;
    for (j = 0; j < divisions; j++) {
      v2 = j / divisions * (Math.PI * 2);
      x2 = Math.sin(v2) * r2;
      z2 = Math.cos(v2) * r2;
      vertices.push(x2, 0, z2);
      colors.push(color.r, color.g, color.b);
      v2 = (j + 1) / divisions * (Math.PI * 2);
      x2 = Math.sin(v2) * r2;
      z2 = Math.cos(v2) * r2;
      vertices.push(x2, 0, z2);
      colors.push(color.r, color.g, color.b);
    }
  }
  var geometry2 = new BufferGeometry();
  geometry2.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry2.addAttribute("color", new Float32BufferAttribute(colors, 3));
  var material = new LineBasicMaterial({ vertexColors: VertexColors });
  LineSegments.call(this, geometry2, material);
}
PolarGridHelper.prototype = Object.create(LineSegments.prototype);
PolarGridHelper.prototype.constructor = PolarGridHelper;
function PositionalAudioHelper(audio, range, divisionsInnerAngle, divisionsOuterAngle) {
  this.audio = audio;
  this.range = range || 1;
  this.divisionsInnerAngle = divisionsInnerAngle || 16;
  this.divisionsOuterAngle = divisionsOuterAngle || 2;
  var geometry2 = new BufferGeometry();
  var divisions = this.divisionsInnerAngle + this.divisionsOuterAngle * 2;
  var positions = new Float32Array((divisions * 3 + 3) * 3);
  geometry2.addAttribute("position", new BufferAttribute(positions, 3));
  var materialInnerAngle = new LineBasicMaterial({ color: 65280 });
  var materialOuterAngle = new LineBasicMaterial({ color: 16776960 });
  Line.call(this, geometry2, [materialOuterAngle, materialInnerAngle]);
  this.update();
}
PositionalAudioHelper.prototype = Object.create(Line.prototype);
PositionalAudioHelper.prototype.constructor = PositionalAudioHelper;
PositionalAudioHelper.prototype.update = function() {
  var audio = this.audio;
  var range = this.range;
  var divisionsInnerAngle = this.divisionsInnerAngle;
  var divisionsOuterAngle = this.divisionsOuterAngle;
  var coneInnerAngle = _Math.degToRad(audio.panner.coneInnerAngle);
  var coneOuterAngle = _Math.degToRad(audio.panner.coneOuterAngle);
  var halfConeInnerAngle = coneInnerAngle / 2;
  var halfConeOuterAngle = coneOuterAngle / 2;
  var start = 0;
  var count2 = 0;
  var i2, stride;
  var geometry2 = this.geometry;
  var positionAttribute = geometry2.attributes.position;
  geometry2.clearGroups();
  function generateSegment(from, to, divisions, materialIndex) {
    var step = (to - from) / divisions;
    positionAttribute.setXYZ(start, 0, 0, 0);
    count2++;
    for (i2 = from; i2 < to; i2 += step) {
      stride = start + count2;
      positionAttribute.setXYZ(stride, Math.sin(i2) * range, 0, Math.cos(i2) * range);
      positionAttribute.setXYZ(stride + 1, Math.sin(Math.min(i2 + step, to)) * range, 0, Math.cos(Math.min(i2 + step, to)) * range);
      positionAttribute.setXYZ(stride + 2, 0, 0, 0);
      count2 += 3;
    }
    geometry2.addGroup(start, count2, materialIndex);
    start += count2;
    count2 = 0;
  }
  generateSegment(-halfConeOuterAngle, -halfConeInnerAngle, divisionsOuterAngle, 0);
  generateSegment(-halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1);
  generateSegment(halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0);
  positionAttribute.needsUpdate = true;
  if (coneInnerAngle === coneOuterAngle)
    this.material[0].visible = false;
};
PositionalAudioHelper.prototype.dispose = function() {
  this.geometry.dispose();
  this.material[0].dispose();
  this.material[1].dispose();
};
function FaceNormalsHelper(object, size, hex, linewidth) {
  this.object = object;
  this.size = size !== void 0 ? size : 1;
  var color = hex !== void 0 ? hex : 16776960;
  var width = linewidth !== void 0 ? linewidth : 1;
  var nNormals = 0;
  var objGeometry = this.object.geometry;
  if (objGeometry && objGeometry.isGeometry) {
    nNormals = objGeometry.faces.length;
  } else {
    console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
  }
  var geometry2 = new BufferGeometry();
  var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
  geometry2.addAttribute("position", positions);
  LineSegments.call(this, geometry2, new LineBasicMaterial({ color, linewidth: width }));
  this.matrixAutoUpdate = false;
  this.update();
}
FaceNormalsHelper.prototype = Object.create(LineSegments.prototype);
FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
FaceNormalsHelper.prototype.update = function() {
  var v1 = new Vector3();
  var v2 = new Vector3();
  var normalMatrix = new Matrix3();
  return function update3() {
    this.object.updateMatrixWorld(true);
    normalMatrix.getNormalMatrix(this.object.matrixWorld);
    var matrixWorld = this.object.matrixWorld;
    var position = this.geometry.attributes.position;
    var objGeometry = this.object.geometry;
    var vertices = objGeometry.vertices;
    var faces = objGeometry.faces;
    var idx = 0;
    for (var i2 = 0, l2 = faces.length; i2 < l2; i2++) {
      var face = faces[i2];
      var normal = face.normal;
      v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);
      v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
      position.setXYZ(idx, v1.x, v1.y, v1.z);
      idx = idx + 1;
      position.setXYZ(idx, v2.x, v2.y, v2.z);
      idx = idx + 1;
    }
    position.needsUpdate = true;
  };
}();
function DirectionalLightHelper(light, size, color) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color;
  if (size === void 0)
    size = 1;
  var geometry2 = new BufferGeometry();
  geometry2.addAttribute("position", new Float32BufferAttribute([
    -size,
    size,
    0,
    size,
    size,
    0,
    size,
    -size,
    0,
    -size,
    -size,
    0,
    -size,
    size,
    0
  ], 3));
  var material = new LineBasicMaterial({ fog: false });
  this.lightPlane = new Line(geometry2, material);
  this.add(this.lightPlane);
  geometry2 = new BufferGeometry();
  geometry2.addAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
  this.targetLine = new Line(geometry2, material);
  this.add(this.targetLine);
  this.update();
}
DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
DirectionalLightHelper.prototype.dispose = function() {
  this.lightPlane.geometry.dispose();
  this.lightPlane.material.dispose();
  this.targetLine.geometry.dispose();
  this.targetLine.material.dispose();
};
DirectionalLightHelper.prototype.update = function() {
  var v1 = new Vector3();
  var v2 = new Vector3();
  var v3 = new Vector3();
  return function update3() {
    v1.setFromMatrixPosition(this.light.matrixWorld);
    v2.setFromMatrixPosition(this.light.target.matrixWorld);
    v3.subVectors(v2, v1);
    this.lightPlane.lookAt(v2);
    if (this.color !== void 0) {
      this.lightPlane.material.color.set(this.color);
      this.targetLine.material.color.set(this.color);
    } else {
      this.lightPlane.material.color.copy(this.light.color);
      this.targetLine.material.color.copy(this.light.color);
    }
    this.targetLine.lookAt(v2);
    this.targetLine.scale.z = v3.length();
  };
}();
function CameraHelper(camera) {
  var geometry2 = new BufferGeometry();
  var material = new LineBasicMaterial({ color: 16777215, vertexColors: FaceColors });
  var vertices = [];
  var colors = [];
  var pointMap = {};
  var colorFrustum = new Color(16755200);
  var colorCone = new Color(16711680);
  var colorUp = new Color(43775);
  var colorTarget = new Color(16777215);
  var colorCross = new Color(3355443);
  addLine("n1", "n2", colorFrustum);
  addLine("n2", "n4", colorFrustum);
  addLine("n4", "n3", colorFrustum);
  addLine("n3", "n1", colorFrustum);
  addLine("f1", "f2", colorFrustum);
  addLine("f2", "f4", colorFrustum);
  addLine("f4", "f3", colorFrustum);
  addLine("f3", "f1", colorFrustum);
  addLine("n1", "f1", colorFrustum);
  addLine("n2", "f2", colorFrustum);
  addLine("n3", "f3", colorFrustum);
  addLine("n4", "f4", colorFrustum);
  addLine("p", "n1", colorCone);
  addLine("p", "n2", colorCone);
  addLine("p", "n3", colorCone);
  addLine("p", "n4", colorCone);
  addLine("u1", "u2", colorUp);
  addLine("u2", "u3", colorUp);
  addLine("u3", "u1", colorUp);
  addLine("c", "t", colorTarget);
  addLine("p", "c", colorCross);
  addLine("cn1", "cn2", colorCross);
  addLine("cn3", "cn4", colorCross);
  addLine("cf1", "cf2", colorCross);
  addLine("cf3", "cf4", colorCross);
  function addLine(a2, b2, color) {
    addPoint(a2, color);
    addPoint(b2, color);
  }
  function addPoint(id, color) {
    vertices.push(0, 0, 0);
    colors.push(color.r, color.g, color.b);
    if (pointMap[id] === void 0) {
      pointMap[id] = [];
    }
    pointMap[id].push(vertices.length / 3 - 1);
  }
  geometry2.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry2.addAttribute("color", new Float32BufferAttribute(colors, 3));
  LineSegments.call(this, geometry2, material);
  this.camera = camera;
  if (this.camera.updateProjectionMatrix)
    this.camera.updateProjectionMatrix();
  this.matrix = camera.matrixWorld;
  this.matrixAutoUpdate = false;
  this.pointMap = pointMap;
  this.update();
}
CameraHelper.prototype = Object.create(LineSegments.prototype);
CameraHelper.prototype.constructor = CameraHelper;
CameraHelper.prototype.update = function() {
  var geometry2, pointMap;
  var vector = new Vector3();
  var camera = new Camera();
  function setPoint(point, x2, y, z2) {
    vector.set(x2, y, z2).unproject(camera);
    var points = pointMap[point];
    if (points !== void 0) {
      var position = geometry2.getAttribute("position");
      for (var i2 = 0, l2 = points.length; i2 < l2; i2++) {
        position.setXYZ(points[i2], vector.x, vector.y, vector.z);
      }
    }
  }
  return function update3() {
    geometry2 = this.geometry;
    pointMap = this.pointMap;
    var w2 = 1, h2 = 1;
    camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    setPoint("c", 0, 0, -1);
    setPoint("t", 0, 0, 1);
    setPoint("n1", -w2, -h2, -1);
    setPoint("n2", w2, -h2, -1);
    setPoint("n3", -w2, h2, -1);
    setPoint("n4", w2, h2, -1);
    setPoint("f1", -w2, -h2, 1);
    setPoint("f2", w2, -h2, 1);
    setPoint("f3", -w2, h2, 1);
    setPoint("f4", w2, h2, 1);
    setPoint("u1", w2 * 0.7, h2 * 1.1, -1);
    setPoint("u2", -w2 * 0.7, h2 * 1.1, -1);
    setPoint("u3", 0, h2 * 2, -1);
    setPoint("cf1", -w2, 0, 1);
    setPoint("cf2", w2, 0, 1);
    setPoint("cf3", 0, -h2, 1);
    setPoint("cf4", 0, h2, 1);
    setPoint("cn1", -w2, 0, -1);
    setPoint("cn2", w2, 0, -1);
    setPoint("cn3", 0, -h2, -1);
    setPoint("cn4", 0, h2, -1);
    geometry2.getAttribute("position").needsUpdate = true;
  };
}();
function BoxHelper(object, color) {
  this.object = object;
  if (color === void 0)
    color = 16776960;
  var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
  var positions = new Float32Array(8 * 3);
  var geometry2 = new BufferGeometry();
  geometry2.setIndex(new BufferAttribute(indices, 1));
  geometry2.addAttribute("position", new BufferAttribute(positions, 3));
  LineSegments.call(this, geometry2, new LineBasicMaterial({ color }));
  this.matrixAutoUpdate = false;
  this.update();
}
BoxHelper.prototype = Object.create(LineSegments.prototype);
BoxHelper.prototype.constructor = BoxHelper;
BoxHelper.prototype.update = function() {
  var box = new Box3();
  return function update3(object) {
    if (object !== void 0) {
      console.warn("THREE.BoxHelper: .update() has no longer arguments.");
    }
    if (this.object !== void 0) {
      box.setFromObject(this.object);
    }
    if (box.isEmpty())
      return;
    var min = box.min;
    var max = box.max;
    var position = this.geometry.attributes.position;
    var array = position.array;
    array[0] = max.x;
    array[1] = max.y;
    array[2] = max.z;
    array[3] = min.x;
    array[4] = max.y;
    array[5] = max.z;
    array[6] = min.x;
    array[7] = min.y;
    array[8] = max.z;
    array[9] = max.x;
    array[10] = min.y;
    array[11] = max.z;
    array[12] = max.x;
    array[13] = max.y;
    array[14] = min.z;
    array[15] = min.x;
    array[16] = max.y;
    array[17] = min.z;
    array[18] = min.x;
    array[19] = min.y;
    array[20] = min.z;
    array[21] = max.x;
    array[22] = min.y;
    array[23] = min.z;
    position.needsUpdate = true;
    this.geometry.computeBoundingSphere();
  };
}();
BoxHelper.prototype.setFromObject = function(object) {
  this.object = object;
  this.update();
  return this;
};
BoxHelper.prototype.copy = function(source) {
  LineSegments.prototype.copy.call(this, source);
  this.object = source.object;
  return this;
};
BoxHelper.prototype.clone = function() {
  return new this.constructor().copy(this);
};
function Box3Helper(box, hex) {
  this.type = "Box3Helper";
  this.box = box;
  var color = hex !== void 0 ? hex : 16776960;
  var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
  var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
  var geometry2 = new BufferGeometry();
  geometry2.setIndex(new BufferAttribute(indices, 1));
  geometry2.addAttribute("position", new Float32BufferAttribute(positions, 3));
  LineSegments.call(this, geometry2, new LineBasicMaterial({ color }));
  this.geometry.computeBoundingSphere();
}
Box3Helper.prototype = Object.create(LineSegments.prototype);
Box3Helper.prototype.constructor = Box3Helper;
Box3Helper.prototype.updateMatrixWorld = function(force) {
  var box = this.box;
  if (box.isEmpty())
    return;
  box.getCenter(this.position);
  box.getSize(this.scale);
  this.scale.multiplyScalar(0.5);
  Object3D.prototype.updateMatrixWorld.call(this, force);
};
function PlaneHelper(plane, size, hex) {
  this.type = "PlaneHelper";
  this.plane = plane;
  this.size = size === void 0 ? 1 : size;
  var color = hex !== void 0 ? hex : 16776960;
  var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
  var geometry2 = new BufferGeometry();
  geometry2.addAttribute("position", new Float32BufferAttribute(positions, 3));
  geometry2.computeBoundingSphere();
  Line.call(this, geometry2, new LineBasicMaterial({ color }));
  var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
  var geometry22 = new BufferGeometry();
  geometry22.addAttribute("position", new Float32BufferAttribute(positions2, 3));
  geometry22.computeBoundingSphere();
  this.add(new Mesh(geometry22, new MeshBasicMaterial({ color, opacity: 0.2, transparent: true, depthWrite: false })));
}
PlaneHelper.prototype = Object.create(Line.prototype);
PlaneHelper.prototype.constructor = PlaneHelper;
PlaneHelper.prototype.updateMatrixWorld = function(force) {
  var scale2 = -this.plane.constant;
  if (Math.abs(scale2) < 1e-8)
    scale2 = 1e-8;
  this.scale.set(0.5 * this.size, 0.5 * this.size, scale2);
  this.children[0].material.side = scale2 < 0 ? BackSide : FrontSide;
  this.lookAt(this.plane.normal);
  Object3D.prototype.updateMatrixWorld.call(this, force);
};
var lineGeometry, coneGeometry;
function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
  Object3D.call(this);
  if (dir === void 0)
    dir = new Vector3(0, 0, 1);
  if (origin === void 0)
    origin = new Vector3(0, 0, 0);
  if (length === void 0)
    length = 1;
  if (color === void 0)
    color = 16776960;
  if (headLength === void 0)
    headLength = 0.2 * length;
  if (headWidth === void 0)
    headWidth = 0.2 * headLength;
  if (lineGeometry === void 0) {
    lineGeometry = new BufferGeometry();
    lineGeometry.addAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
    coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
    coneGeometry.translate(0, -0.5, 0);
  }
  this.position.copy(origin);
  this.line = new Line(lineGeometry, new LineBasicMaterial({ color }));
  this.line.matrixAutoUpdate = false;
  this.add(this.line);
  this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({ color }));
  this.cone.matrixAutoUpdate = false;
  this.add(this.cone);
  this.setDirection(dir);
  this.setLength(length, headLength, headWidth);
}
ArrowHelper.prototype = Object.create(Object3D.prototype);
ArrowHelper.prototype.constructor = ArrowHelper;
ArrowHelper.prototype.setDirection = function() {
  var axis = new Vector3();
  var radians;
  return function setDirection(dir) {
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      axis.set(dir.z, 0, -dir.x).normalize();
      radians = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(axis, radians);
    }
  };
}();
ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
  if (headLength === void 0)
    headLength = 0.2 * length;
  if (headWidth === void 0)
    headWidth = 0.2 * headLength;
  this.line.scale.set(1, Math.max(0, length - headLength), 1);
  this.line.updateMatrix();
  this.cone.scale.set(headWidth, headLength, headWidth);
  this.cone.position.y = length;
  this.cone.updateMatrix();
};
ArrowHelper.prototype.setColor = function(color) {
  this.line.material.color.copy(color);
  this.cone.material.color.copy(color);
};
ArrowHelper.prototype.copy = function(source) {
  Object3D.prototype.copy.call(this, source, false);
  this.line.copy(source.line);
  this.cone.copy(source.cone);
  return this;
};
ArrowHelper.prototype.clone = function() {
  return new this.constructor().copy(this);
};
function AxesHelper(size) {
  size = size || 1;
  var vertices = [
    0,
    0,
    0,
    size,
    0,
    0,
    0,
    0,
    0,
    0,
    size,
    0,
    0,
    0,
    0,
    0,
    0,
    size
  ];
  var colors = [
    1,
    0,
    0,
    1,
    0.6,
    0,
    0,
    1,
    0,
    0.6,
    1,
    0,
    0,
    0,
    1,
    0,
    0.6,
    1
  ];
  var geometry2 = new BufferGeometry();
  geometry2.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry2.addAttribute("color", new Float32BufferAttribute(colors, 3));
  var material = new LineBasicMaterial({ vertexColors: VertexColors });
  LineSegments.call(this, geometry2, material);
}
AxesHelper.prototype = Object.create(LineSegments.prototype);
AxesHelper.prototype.constructor = AxesHelper;
Curve.create = function(construct, getPoint) {
  console.log("THREE.Curve.create() has been deprecated");
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
};
Object.assign(CurvePath.prototype, {
  createPointsGeometry: function(divisions) {
    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    var pts = this.getPoints(divisions);
    return this.createGeometry(pts);
  },
  createSpacedPointsGeometry: function(divisions) {
    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    var pts = this.getSpacedPoints(divisions);
    return this.createGeometry(pts);
  },
  createGeometry: function(points) {
    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    var geometry2 = new Geometry();
    for (var i2 = 0, l2 = points.length; i2 < l2; i2++) {
      var point = points[i2];
      geometry2.vertices.push(new Vector3(point.x, point.y, point.z || 0));
    }
    return geometry2;
  }
});
Object.assign(Path.prototype, {
  fromPoints: function(points) {
    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
    this.setFromPoints(points);
  }
});
function Spline(points) {
  console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
  CatmullRomCurve3.call(this, points);
  this.type = "catmullrom";
}
Spline.prototype = Object.create(CatmullRomCurve3.prototype);
Object.assign(Spline.prototype, {
  initFromArray: function() {
    console.error("THREE.Spline: .initFromArray() has been removed.");
  },
  getControlPointsArray: function() {
    console.error("THREE.Spline: .getControlPointsArray() has been removed.");
  },
  reparametrizeByArcLength: function() {
    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
  }
});
GridHelper.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
Object.assign(Loader.prototype, {
  extractUrlBase: function(url) {
    console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
    return LoaderUtils.extractUrlBase(url);
  }
});
Object.assign(ObjectLoader.prototype, {
  setTexturePath: function(value) {
    console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
    return this.setResourcePath(value);
  }
});
Object.assign(Box2.prototype, {
  center: function(optionalTarget) {
    console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
  },
  empty: function() {
    console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  },
  isIntersectionBox: function(box) {
    console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  },
  size: function(optionalTarget) {
    console.warn("THREE.Box2: .size() has been renamed to .getSize().");
    return this.getSize(optionalTarget);
  }
});
Object.assign(Box3.prototype, {
  center: function(optionalTarget) {
    console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
  },
  empty: function() {
    console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  },
  isIntersectionBox: function(box) {
    console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  },
  isIntersectionSphere: function(sphere) {
    console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(sphere);
  },
  size: function(optionalTarget) {
    console.warn("THREE.Box3: .size() has been renamed to .getSize().");
    return this.getSize(optionalTarget);
  }
});
Line3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Object.assign(_Math, {
  random16: function() {
    console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
    return Math.random();
  },
  nearestPowerOfTwo: function(value) {
    console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
    return _Math.floorPowerOfTwo(value);
  },
  nextPowerOfTwo: function(value) {
    console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
    return _Math.ceilPowerOfTwo(value);
  }
});
Object.assign(Matrix3.prototype, {
  flattenToArrayOffset: function(array, offset2) {
    console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset2);
  },
  multiplyVector3: function(vector) {
    console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
    return vector.applyMatrix3(this);
  },
  multiplyVector3Array: function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  },
  applyToBuffer: function(buffer) {
    console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
    return this.applyToBufferAttribute(buffer);
  },
  applyToVector3Array: function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  }
});
Object.assign(Matrix4.prototype, {
  extractPosition: function(m2) {
    console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
    return this.copyPosition(m2);
  },
  flattenToArrayOffset: function(array, offset2) {
    console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset2);
  },
  getPosition: function() {
    var v1;
    return function getPosition() {
      if (v1 === void 0)
        v1 = new Vector3();
      console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
      return v1.setFromMatrixColumn(this, 3);
    };
  }(),
  setRotationFromQuaternion: function(q) {
    console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
    return this.makeRotationFromQuaternion(q);
  },
  multiplyToArray: function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  },
  multiplyVector3: function(vector) {
    console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  },
  multiplyVector4: function(vector) {
    console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  },
  multiplyVector3Array: function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  },
  rotateAxis: function(v2) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
    v2.transformDirection(this);
  },
  crossVector: function(vector) {
    console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  },
  translate: function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  },
  rotateX: function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  },
  rotateY: function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  },
  rotateZ: function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  },
  rotateByAxis: function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  },
  applyToBuffer: function(buffer) {
    console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
    return this.applyToBufferAttribute(buffer);
  },
  applyToVector3Array: function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  },
  makeFrustum: function(left, right, bottom, top, near, far) {
    console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
    return this.makePerspective(left, right, top, bottom, near, far);
  }
});
Plane.prototype.isIntersectionLine = function(line) {
  console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
  return this.intersectsLine(line);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
  return vector.applyQuaternion(this);
};
Object.assign(Ray.prototype, {
  isIntersectionBox: function(box) {
    console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  },
  isIntersectionPlane: function(plane) {
    console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
    return this.intersectsPlane(plane);
  },
  isIntersectionSphere: function(sphere) {
    console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(sphere);
  }
});
Object.assign(Triangle.prototype, {
  area: function() {
    console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
    return this.getArea();
  },
  barycoordFromPoint: function(point, target) {
    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
    return this.getBarycoord(point, target);
  },
  midpoint: function(target) {
    console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
    return this.getMidpoint(target);
  },
  normal: function(target) {
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
    return this.getNormal(target);
  },
  plane: function(target) {
    console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
    return this.getPlane(target);
  }
});
Object.assign(Triangle, {
  barycoordFromPoint: function(point, a2, b2, c2, target) {
    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
    return Triangle.getBarycoord(point, a2, b2, c2, target);
  },
  normal: function(a2, b2, c2, target) {
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
    return Triangle.getNormal(a2, b2, c2, target);
  }
});
Object.assign(Shape.prototype, {
  extractAllPoints: function(divisions) {
    console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
    return this.extractPoints(divisions);
  },
  extrude: function(options) {
    console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
    return new ExtrudeGeometry(this, options);
  },
  makeGeometry: function(options) {
    console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
    return new ShapeGeometry(this, options);
  }
});
Object.assign(Vector2.prototype, {
  fromAttribute: function(attribute, index2, offset2) {
    console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index2, offset2);
  },
  distanceToManhattan: function(v2) {
    console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
    return this.manhattanDistanceTo(v2);
  },
  lengthManhattan: function() {
    console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  }
});
Object.assign(Vector3.prototype, {
  setEulerFromRotationMatrix: function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  },
  setEulerFromQuaternion: function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  },
  getPositionFromMatrix: function(m2) {
    console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
    return this.setFromMatrixPosition(m2);
  },
  getScaleFromMatrix: function(m2) {
    console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
    return this.setFromMatrixScale(m2);
  },
  getColumnFromMatrix: function(index2, matrix) {
    console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
    return this.setFromMatrixColumn(matrix, index2);
  },
  applyProjection: function(m2) {
    console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
    return this.applyMatrix4(m2);
  },
  fromAttribute: function(attribute, index2, offset2) {
    console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index2, offset2);
  },
  distanceToManhattan: function(v2) {
    console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
    return this.manhattanDistanceTo(v2);
  },
  lengthManhattan: function() {
    console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  }
});
Object.assign(Vector4.prototype, {
  fromAttribute: function(attribute, index2, offset2) {
    console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index2, offset2);
  },
  lengthManhattan: function() {
    console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  }
});
Object.assign(Geometry.prototype, {
  computeTangents: function() {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  },
  computeLineDistances: function() {
    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
  }
});
Object.assign(Object3D.prototype, {
  getChildByName: function(name) {
    console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
    return this.getObjectByName(name);
  },
  renderDepth: function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  },
  translate: function(distance, axis) {
    console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
    return this.translateOnAxis(axis, distance);
  },
  getWorldRotation: function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  }
});
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      return this.rotation.order;
    },
    set: function(value) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Object.defineProperties(LOD.prototype, {
  objects: {
    get: function() {
      console.warn("THREE.LOD: .objects has been renamed to .levels.");
      return this.levels;
    }
  }
});
Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
  get: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  },
  set: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
  get: function() {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    return this.arcLengthDivisions;
  },
  set: function(value) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    this.arcLengthDivisions = value;
  }
});
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== void 0)
    this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(value) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
      this.shadow.mapSize.height = value;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
      return this.array.length;
    }
  },
  copyIndicesArray: function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  }
});
Object.assign(BufferGeometry.prototype, {
  addIndex: function(index2) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
    this.setIndex(index2);
  },
  addDrawCall: function(start, count2, indexOffset) {
    if (indexOffset !== void 0) {
      console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
    }
    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
    this.addGroup(start, count2);
  },
  clearDrawCalls: function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
    this.clearGroups();
  },
  computeTangents: function() {
    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
  },
  computeOffsets: function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  }
});
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
      return this.groups;
    }
  },
  offsets: {
    get: function() {
      console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
      return this.groups;
    }
  }
});
Object.assign(ExtrudeBufferGeometry.prototype, {
  getArrays: function() {
    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
  },
  addShapeList: function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
  },
  addShape: function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
  }
});
Object.defineProperties(Uniform.prototype, {
  dynamic: {
    set: function() {
      console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
    }
  },
  onUpdate: {
    value: function() {
      console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
      return this;
    }
  }
});
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      console.warn("THREE.Material: .wrapRGB has been removed.");
      return new Color();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      this.flatShading = value === FlatShading;
    }
  }
});
Object.defineProperties(MeshPhongMaterial.prototype, {
  metal: {
    get: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      return this.extensions.derivatives;
    },
    set: function(value) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      this.extensions.derivatives = value;
    }
  }
});
Object.assign(WebGLRenderer.prototype, {
  clearTarget: function(renderTarget, color, depth, stencil) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
    this.setRenderTarget(renderTarget);
    this.clear(color, depth, stencil);
  },
  animate: function(callback) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
    this.setAnimationLoop(callback);
  },
  getCurrentRenderTarget: function() {
    console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
    return this.getRenderTarget();
  },
  getMaxAnisotropy: function() {
    console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
    return this.capabilities.getMaxAnisotropy();
  },
  getPrecision: function() {
    console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
    return this.capabilities.precision;
  },
  resetGLState: function() {
    console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
    return this.state.reset();
  },
  supportsFloatTextures: function() {
    console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
    return this.extensions.get("OES_texture_float");
  },
  supportsHalfFloatTextures: function() {
    console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
    return this.extensions.get("OES_texture_half_float");
  },
  supportsStandardDerivatives: function() {
    console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
    return this.extensions.get("OES_standard_derivatives");
  },
  supportsCompressedTextureS3TC: function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
    return this.extensions.get("WEBGL_compressed_texture_s3tc");
  },
  supportsCompressedTexturePVRTC: function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
    return this.extensions.get("WEBGL_compressed_texture_pvrtc");
  },
  supportsBlendMinMax: function() {
    console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
    return this.extensions.get("EXT_blend_minmax");
  },
  supportsVertexTextures: function() {
    console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
    return this.capabilities.vertexTextures;
  },
  supportsInstancedArrays: function() {
    console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
    return this.extensions.get("ANGLE_instanced_arrays");
  },
  enableScissorTest: function(boolean) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
    this.setScissorTest(boolean);
  },
  initMaterial: function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  },
  addPrePlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  },
  addPostPlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  },
  updateShadowMap: function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  },
  setFaceCulling: function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  },
  allocTextureUnit: function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
  },
  setTexture: function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
  },
  setTexture2D: function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
  },
  setTextureCube: function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
  }
});
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(WebGLRenderTargetCube.prototype, {
  activeCubeFace: {
    set: function() {
      console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().");
    }
  },
  activeMipMapLevel: {
    set: function() {
      console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().");
    }
  }
});
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      return this.texture.wrapS;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      return this.texture.wrapT;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      return this.texture.magFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      return this.texture.minFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      return this.texture.anisotropy;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      return this.texture.offset;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      return this.texture.repeat;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      this.texture.repeat = value;
    }
  },
  format: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      return this.texture.format;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      this.texture.format = value;
    }
  },
  type: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      return this.texture.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      return this.texture.generateMipmaps;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      this.texture.generateMipmaps = value;
    }
  }
});
Object.defineProperties(WebVRManager.prototype, {
  standing: {
    set: function() {
      console.warn("THREE.WebVRManager: .standing has been removed.");
    }
  },
  userHeight: {
    set: function() {
      console.warn("THREE.WebVRManager: .userHeight has been removed.");
    }
  }
});
Audio.prototype.load = function(file) {
  console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
  var scope = this;
  var audioLoader = new AudioLoader();
  audioLoader.load(file, function(buffer) {
    scope.setBuffer(buffer);
  });
  return this;
};
AudioAnalyser.prototype.getData = function() {
  console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
  return this.getFrequencyData();
};
CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
  console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
  return this.update(renderer, scene);
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  var loader = new TextureLoader$1();
  loader.setCrossOrigin(this.crossOrigin);
  var texture = loader.load(url, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  var loader = new CubeTextureLoader$1();
  loader.setCrossOrigin(this.crossOrigin);
  var texture = loader.load(urls, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
const exports = {};
const version = "0.12.0";
const dependencies = { three: "^0.105.2" };
const REVISION = version.split(".")[1];
const VERSION = version;
const THREE_REVISION = dependencies.three.split(".")[1];
const THREE_VERSION = dependencies.three.replace(/[^0-9.]/g, "");
const CONTROLS = { ORBIT: 0, DEVICEORIENTATION: 1 };
const MODES = { UNKNOWN: 0, NORMAL: 1, CARDBOARD: 2, STEREO: 3 };
const DataImage = {
  Info: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADBklEQVR42u2bP08UQRiHnzFaSYCI/xoksdBIqGwIiYWRUBISExpCQ0ej38FWOmlIKKhoMPEbaCxsrrHiYrQgOSlQEaICrT+LHSPZzNzt3s3c3Hn7lHvLzvv82L2dm30XKioqKgYY062BJF0HpoA7wARwBbhsPz4DjoEG8AnYNcZ8Sx1Op8IXJM1KWpdUV3nq9m9nJV1I7VNGfEzSM0mNNqR9NOwxx1L7NRMflbQm6SSgeJ4TO8Zoat+8/LKkg4jieQ4kLaf2RtKwpJ0uiufZkTScSn5S0l5C+b/sSZrstvyMpKPU5uc4kjTTjkvpeYCkaeA1/+7hvcIZMGuMqUULQNIU8Aa4ltrWwyHwyBizGzwASSPAe+B2assW7AH3jTE/i+xcZoa12Qfy2Bo3i+5cKABl99zF1GYlWFTBeULLS0DZrOsDcDNggTXgc27bLWA64BhfgHvGmB8dHUXZ1DM0S45xliKMs9bKr+klIOkqsBrwv9JtVq1DewEAT4Ch1BYdMGQdygeg7Df4SmqDAKyoyXpCszPgITCeuvoAjFuX0gE8jljUdv7bCtiOOJ7XpdUZ8L/gdXHOA5QtYH5NXXVgbrgWWn1nwFTqaiPgdPIFcDd1tRFwOl307DwRuZgXwLvctgfA04hjOp18AcReZ6sZY16e3yDpUuQxnU6+S2AkcjEpcDr1zxOXSPgCKLSa0mc4nXwB/EpdbQScTr4AGqmrjYDTyRfAx9TVRsDp5Aug8LJyH+F0cgZg58z11BUHpO5ruGh2G3ybuuqAeF2aBfAqddUB8bq0OgP2U1cegH3aOQOMMb+BrdTVB2DLupQLwLIOnKY26IBT6+ClaQDGmO/ARmqLDtiwDn7HVkcY+EdjNoTlCI+tYhO2iUppm6HKslPUq2qQKHpUe8AFsjaUXuUQWCgqXyoAG8IuME/WkNRrnAHzZfqDSgdgQ6gBc2Td3b3CMTBXtkOsIzTIjZLnQhjcVtlcEIPZLJ0LoVvt8s/Va+3yuSAG84UJRxB98cpM9dJURUVFxSDzBxKde4Lk3/h2AAAAAElFTkSuQmCC",
  Arrow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADPklEQVR42u2bMUscQRiG30/SRaJEI1ZKUiRErNIELRUbQYSAnX8hpVUgkDYp0wgWVjYW+QcJaQzYpLojJIXhtDDEKBpj65ti58ixmdmb2ZvZ7+T2AUHudmfmeXf2bnb3O6CmpqZmgJGqOiI5AWAWwEMA0wDuArht3r4CcAagBeAbgIaI/NQOp1fhIZKLJN+SbDKcptl3keSQtk+I+BjJVyRbJaRdtEybY9p+ReKjJN+QvIwonufS9DGq7ZuXXyd5nFA8zzHJdW1vkLxDcrdC8Ty7JO9oyc+QPFCUb3NAcqZq+TmSp9rmHZySnCvjErwOIPkUwHv8+w7vF64ALIrIfrIASM4C+ADgnratgxMACyLSiB4AyREAnwE80LbswgGAJyJy4bNxyApr6wbIw4xxy3djrwCYfeeuaZsFsEbPdULXU4DZqusLgMkEA21P05EEbf8A8FhEzos28pkBLxLKL5s/r/M1kEkz9vKQHGeatf05yfmOfubNa7G5JDle5NhtBjwHMBz5yFwAWBaRT+0XzP8pZsKwcQiH2fX8Ycojb+kzxUw4ZJn7CSQXqpRPHMKCq7+iZJ71Mvdy/DftXSQ6HcJdSDaqPPKW/mPOBO+lcbvzCU35RCFM2PpwnQKzZQfdgfe0dxH5dLA6uQJ4pC2fIASrkyuA6X6QjxyC1ckVQNn7bNHlI4ZgdXIFUObiJJl8pBCsTjGfuIwA2Cv4FN7xbYjkjqsRAHuIePXoCiDF1Zk2VidXAL+1R5sAq5MrgJb2aBNgdXIF8FV7tAmwOrkCCFs73wysTtYATHFCU3vEEWm6Ci6KvgY/ao86Ik6XogDeaY86Ik6XbjPgSHvkEThCwQy45XpDRK5JbgN4GWkgUyR9H65MRQxgW0SunZ5FezK7pfwd8e8MV8UfAPdF5Jdrg8JrAbPjprZFD2wWyQP6j8ZSEufRmGlgQ9umBBvd5IOgbjFUKLu+XnWBhG+rpsFVZGUo/coJgFVf+aAATAgNACvICpL6jSsAKyH1QcEBmBD2ASwhq+7uF84ALIVWiPUEB7lQsiOEwS2VzQUxmMXSuRCqKpd/zX4rl88FMZg/mLAEcSN+MlP/aKqmpqZmkPkL0hSjwOpNKxwAAAAASUVORK5CYII=",
  FullscreenEnter: "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz4KICAgIDxwYXRoIGQ9Ik03IDE0SDV2NWg1di0ySDd2LTN6bS0yLTRoMlY3aDNWNUg1djV6bTEyIDdoLTN2Mmg1di01aC0ydjN6TTE0IDV2MmgzdjNoMlY1aC01eiIvPgo8L3N2Zz4=",
  FullscreenLeave: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTE0LDE0SDE5VjE2SDE2VjE5SDE0VjE0TTUsMTRIMTBWMTlIOFYxNkg1VjE0TTgsNUgxMFYxMEg1VjhIOFY1TTE5LDhWMTBIMTRWNUgxNlY4SDE5WiIgLz48L3N2Zz4=",
  VideoPlay: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTgsNS4xNFYxOS4xNEwxOSwxMi4xNEw4LDUuMTRaIiAvPjwvc3ZnPg==",
  VideoPause: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTE0LDE5LjE0SDE4VjUuMTRIMTRNNiwxOS4xNEgxMFY1LjE0SDZWMTkuMTRaIiAvPjwvc3ZnPg==",
  WhiteTile: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIABAMAAAAGVsnJAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAB1WlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KAtiABQAAACRQTFRFAAAAAAAABgYGBwcHHh4eKysrx8fHy8vLzMzM7OzsAAAABgYG+q7SZgAAAAp0Uk5TAP7+/v7+/v7+/iJx/a8AAAOwSURBVHja7d0hbsNAEAVQo6SFI6XEcALDcgNLvUBvEBQVhpkWVYWlhSsVFS7t5QIshRt695lEASZP+8c7a1kzDL1fz+/zyuvzp6FbvoddrL6uDd1yGZ5eXldeb18N3fIx7A+58prmhm65DfvDcd0952lu6JabFbD/zVprZj1lzcys+fj9z8xTZtbT8rv8yWlu6BYAIgAAAAAAAAAAAABAM6QXEAEAAAAAAAAAgJ2gnaAIiIA3Q2qAGgAAAAAAAAAAAAAAAAAAAAAAAAAAQJsADkVFAAAAAAA8Bj0GRUAEREAEREAEREAEREAEAAAAAAAAAAB2gnaCIiACPplRA9QANUAERAAAAEVQERQBERCBVlfAcZ3aeZobusUKMGBhV6KUElHGKBERJR6/fxExRkQZl9/lT8S1oVsuhqyYMmPKjCkzvfcCpsxohrwY0Q06EAEAAAAAAAAAAACgGdILiAAAAAAAAAAAwE7QTlAERMCbITVADQAAAAAAAAAAAAAAAAAAAAAAAAAAwKmwQ1ERAAAAAACPQY9BERABERABERABERABERABAAAAAAAAAICdoJ2gCIiAT2bUADVADRABEQAAQBFUBEVABERgEyvAlJm+V4ApM6bMmDJjyowpM6bMdN0LmDKjGfJiRDfoQAQAAAAAAAAAAACAZkgvIAIAAAAAAAAAADtBO0EREAFvhtQANQAAAAAAAAAAAAAAAAAAAAAAAAAAAKfCDkVFAAAAAAA8Bj0GRUAEREAEREAEREAEREAEAAAAAAAAAAB2gnaCIiACPplRA9QANUAERAAAAEVQERQBERCBTawAU2b6XgGmzJgyY8qMKTOmzJgy03UvYMqMZsiLEd2gAxEAAAAAAAAAAAAAmiG9gAgAAAAAAAAAAOwE7QRFQAS8GVID1AAAAAAAAAAAAAAAAAAAAAAAAAAAAJwKOxQVAQAAAADwGPQYFAEREAEREAEREAEREAERAAAAAAAAAADYCdoJioAI+GRGDVAD1AAREAEAABRBRVAEREAENrECTJnpewWYMmPKjCkzpsyYMmPKTNe9gCkzmiEvRnSDDkQAAAAAAAAAAAAAaIb0AiIAAAAAAAAAALATtBMUARHwZkgNUAMAAAAAAAAAAAAAAAAAAAAAAAAAAHAq7FBUBAAAAADAY9BjUAREQAREQAREQAREQAREAAAAAAAAAABgJ2gnKAIi4JMZNUANUANEQAQAAFAEFUEREAER2MQKMGWm7xVgyowpM50PWen9ugNGXz1XaocAFgAAAABJRU5ErkJggg==",
  Setting: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADn0lEQVR42u2bzUsVURjGnyO6CPzAMnTjppAo3LTwH1CqTfaxbeOiRS37A0wXtROFVi1aRBs3LWohSIGbQAQXViBGRhG0UIRKUCpK7q/FnOB2uc6cOXNmRnGe3eW+H8/7zLln3vNxpQoVKlQ4wjBFJAFOSRqX1O7osivpvjHmU1nChBZglvSYLYJbS0EanCvIJzWK+gnsyH34/8OuMaYjb265jwCgz6N4SWq3vodbAEmnS/KtBDgoAgyU5BteAOAkMAPcBroc7PskDWfgN+wyDwBdltMMcDI3tYBnde/pHeARMNTErgd4APzweP834oeN1dMkz5DlsFNn/yyv4kdiSK4At4AO4CqwGaDwRmza2B0210qM7YhrXU59ANAq6bWkwQTTn5KO5fIE0uVYlXTeGLOXFMx1DrjlULwKKN41x6DlnIjEEQCckPRe0okCiguJr5LOGGO+xhm5jICJQ1i8LOeJJKPYEQAMKvrtt5ZdjSf2FM0Fq/sZJI2A6UNcvCz36TiDfUcAcE1SPu/U6Mm8k/TFfu6XdFb5iX3dGPM8lQfwNod3+TowBnQ3yddtv1vPIe+b1JIBiwEJ1IAJ208k5W21trWA+V/5CHAcmAtU/A2P/DcCiTAHHE8tgCVhgLvAXgYCk17Jo/yTGfLuWe7Zd72AC8CWB4n3OAz7mLytNkZabAEXMhfeQKYfWEpJZCxA3rGUOZeA/qDF15FpAz47EvlNk9neI2e3jeWCz0BbmvipNkSMMX8kuSZYM8Z8zyqAjbHmaN5mOeYjgIXrU93MWrxHrNQjrqiDkQMLHwG+OdqF3NN3jeXKzU8AoF1SzdH8XKhJUO7HZDXLMbwAwICkJUULFxe0SbqSVQAbw3Xi7Ze0ZLmGAzAKbHs0JGU1QtvAaIjCW4B7ZOvJy2qFa5a730RPtBiaz0CgnkiZi6F5fBZDVMvho7EhcuS3xJJ2hV9IupgTqaLw0hhzab8vq23xOG/r+LDsKjLgYVzxUnU0ltwK2wDezUyJmEwqXgp/PL4rvxthaeCSI+zxuA10J8ZkWdJNSb2SLkvayKHwDRu71+ZajrG941J8agALDQ3GU/a/IvMkYCPzmCbtLNEVmacNtgs5iP9fYVNEV1Q6Hez7yNZSL+J2SarTcpqiyV2iUkG0IvPFvbz5FbEn+KEk3wMjwMeSfCsBXFBdly9CAPk9ydyffpECuB5tZfVJjaKWueOSfinln6YK4lahQoUKRxd/AcRPGTcQCAUQAAAAAElFTkSuQmCC",
  ChevronRight: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTguNTksMTYuNThMMTMuMTcsMTJMOC41OSw3LjQxTDEwLDZMMTYsMTJMMTAsMThMOC41OSwxNi41OFoiIC8+PC9zdmc+",
  Check: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTIxLDdMOSwxOUwzLjUsMTMuNUw0LjkxLDEyLjA5TDksMTYuMTdMMTkuNTksNS41OUwyMSw3WiIgLz48L3N2Zz4=",
  ViewIndicator: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0idmlldy1pbmRpY2F0b3IiIGhlaWdodD0iMzAiIHdpZHRoPSIzMCIgdmlld0JveD0iLTIuNSAtMSAzMCAzMCI+Cgk8c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7ZmlsbDpub25lO30uc3Qxe3N0cm9rZS13aWR0aDo2O3N0cm9rZS1taXRlcmxpbWl0OjEwO30KCTwvc3R5bGU+Cgk8Zz4KCQk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNIDEyLjUgMCBBIDEyLjUgMTIuNSAwIDAgMCAtMTIuNSAwIEEgMTIuNSAxMi41IDAgMCAwIDEyLjUgMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMywxNS41KSI+PC9wYXRoPgoJCTxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik0gMTMgMCBMIDEwIDIgTCAxNiAyIFoiPjwvcGF0aD4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNIDIgMCBBIDIgMiAwIDAgMCAtMiAwIEEgMiAyIDAgMCAwIDIgMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMywxNS41KSI+PC9wYXRoPgoJCTxwYXRoIGNsYXNzPSJzdDEiIGlkPSJpbmRpY2F0b3IiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTMsMTUuNSkiPjwvcGF0aD4KCTwvZz4KPC9zdmc+"
};
const ImageLoader = {
  load: function(url, onLoad = () => {
  }, onProgress = () => {
  }, onError = () => {
  }) {
    Cache.enabled = true;
    let cached, request, arrayBufferView, blob, urlCreator, image, reference;
    for (let iconName in DataImage) {
      if (DataImage.hasOwnProperty(iconName) && url === DataImage[iconName]) {
        reference = iconName;
      }
    }
    cached = Cache.get(reference ? reference : url);
    if (cached !== void 0) {
      if (onLoad) {
        setTimeout(function() {
          onProgress({ loaded: 1, total: 1 });
          onLoad(cached);
        }, 0);
      }
      return cached;
    }
    urlCreator = window.URL || window.webkitURL;
    image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    Cache.add(reference ? reference : url, image);
    const onImageLoaded = () => {
      urlCreator.revokeObjectURL(image.src);
      onLoad(image);
    };
    if (url.indexOf("data:") === 0) {
      image.addEventListener("load", onImageLoaded, false);
      image.src = url;
      return image;
    }
    image.crossOrigin = this.crossOrigin !== void 0 ? this.crossOrigin : "";
    request = new window.XMLHttpRequest();
    request.open("GET", url, true);
    request.responseType = "arraybuffer";
    request.addEventListener("error", onError);
    request.addEventListener("progress", (event) => {
      if (!event)
        return;
      const { loaded, total, lengthComputable } = event;
      if (lengthComputable) {
        onProgress({ loaded, total });
      }
    });
    request.addEventListener("loadend", (event) => {
      if (!event)
        return;
      const { currentTarget: { response } } = event;
      arrayBufferView = new Uint8Array(response);
      blob = new window.Blob([arrayBufferView]);
      image.addEventListener("load", onImageLoaded, false);
      image.src = urlCreator.createObjectURL(blob);
    });
    request.send(null);
  }
};
const TextureLoader = {
  load: function(url, onLoad = () => {
  }, onProgress, onError) {
    var texture = new Texture();
    ImageLoader.load(url, function(image) {
      texture.image = image;
      const isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? RGBFormat : RGBAFormat;
      texture.needsUpdate = true;
      onLoad(texture);
    }, onProgress, onError);
    return texture;
  }
};
const CubeTextureLoader = {
  load: function(urls, onLoad = () => {
  }, onProgress = () => {
  }, onError) {
    var texture, loaded, progress, all, loadings;
    texture = new CubeTexture([]);
    loaded = 0;
    progress = {};
    all = {};
    urls.map(function(url, index2) {
      ImageLoader.load(url, function(image) {
        texture.images[index2] = image;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          onLoad(texture);
        }
      }, function(event) {
        progress[index2] = { loaded: event.loaded, total: event.total };
        all.loaded = 0;
        all.total = 0;
        loadings = 0;
        for (var i2 in progress) {
          loadings++;
          all.loaded += progress[i2].loaded;
          all.total += progress[i2].total;
        }
        if (loadings < 6) {
          all.total = all.total / loadings * 6;
        }
        onProgress(all);
      }, onError);
    });
    return texture;
  }
};
function Media(constraints) {
  const defaultConstraints = { video: { width: { ideal: 1920 }, height: { ideal: 1080 }, facingMode: { exact: "environment" } }, audio: false };
  this.constraints = Object.assign(defaultConstraints, constraints);
  this.container = null;
  this.scene = null;
  this.element = null;
  this.devices = [];
  this.stream = null;
  this.ratioScalar = 1;
  this.videoDeviceIndex = 0;
}
Media.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  setContainer: function(container) {
    this.container = container;
  },
  setScene: function(scene) {
    this.scene = scene;
  },
  enumerateDevices: function() {
    const devices = this.devices;
    const resolvedPromise = new Promise((resolve) => {
      resolve(devices);
    });
    return devices.length > 0 ? resolvedPromise : window.navigator.mediaDevices.enumerateDevices();
  },
  switchNextVideoDevice: function() {
    const stop2 = this.stop.bind(this);
    const start = this.start.bind(this);
    const setVideDeviceIndex = this.setVideDeviceIndex.bind(this);
    let index2 = this.videoDeviceIndex;
    this.getDevices("video").then((devices) => {
      stop2();
      index2++;
      if (index2 >= devices.length) {
        setVideDeviceIndex(0);
        index2--;
      } else {
        setVideDeviceIndex(index2);
      }
      start(devices[index2]);
    });
  },
  getDevices: function(type = "video") {
    const devices = this.devices;
    const validate = (_devices) => {
      return _devices.map((device) => {
        if (!devices.includes(device)) {
          devices.push(device);
        }
        return device;
      });
    };
    const filter2 = (_devices) => {
      const reg = new RegExp(type, "i");
      return _devices.filter((device) => reg.test(device.kind));
    };
    return this.enumerateDevices().then(validate).then(filter2);
  },
  getUserMedia: function(constraints) {
    const setMediaStream = this.setMediaStream.bind(this);
    const playVideo = this.playVideo.bind(this);
    const onCatchError = (error) => {
      console.warn(`PANOLENS.Media: ${error}`);
    };
    return window.navigator.mediaDevices.getUserMedia(constraints).then(setMediaStream).then(playVideo).catch(onCatchError);
  },
  setVideDeviceIndex: function(index2) {
    this.videoDeviceIndex = index2;
  },
  start: function(targetDevice) {
    const constraints = this.constraints;
    const getUserMedia = this.getUserMedia.bind(this);
    const onVideoDevices = (devices) => {
      if (!devices || devices.length === 0) {
        throw Error("no video device found");
      }
      const device = targetDevice || devices[0];
      constraints.video.deviceId = device.deviceId;
      return getUserMedia(constraints);
    };
    this.element = this.createVideoElement();
    return this.getDevices().then(onVideoDevices);
  },
  stop: function() {
    const stream = this.stream;
    if (stream && stream.active) {
      const track = stream.getTracks()[0];
      track.stop();
      window.removeEventListener("resize", this.onWindowResize.bind(this));
      this.element = null;
      this.stream = null;
    }
  },
  setMediaStream: function(stream) {
    this.stream = stream;
    this.element.srcObject = stream;
    if (this.scene) {
      this.scene.background = this.createVideoTexture();
    }
    window.addEventListener("resize", this.onWindowResize.bind(this));
  },
  playVideo: function() {
    const { element } = this;
    if (element) {
      element.play();
      this.dispatchEvent({ type: "play" });
    }
  },
  pauseVideo: function() {
    const { element } = this;
    if (element) {
      element.pause();
      this.dispatchEvent({ type: "pause" });
    }
  },
  createVideoTexture: function() {
    const video = this.element;
    const texture = new VideoTexture(video);
    texture.generateMipmaps = false;
    texture.minFilter = LinearFilter;
    texture.magFilter = LinearFilter;
    texture.format = RGBFormat;
    texture.center.set(0.5, 0.5);
    video.addEventListener("canplay", this.onWindowResize.bind(this));
    return texture;
  },
  createVideoElement: function() {
    const dispatchEvent2 = this.dispatchEvent.bind(this);
    const video = document.createElement("video");
    const canPlay = () => dispatchEvent2({ type: "canplay" });
    video.setAttribute("autoplay", "");
    video.setAttribute("muted", "");
    video.setAttribute("playsinline", "");
    video.style.position = "absolute";
    video.style.top = "0";
    video.style.left = "0";
    video.style.width = "100%";
    video.style.height = "100%";
    video.style.objectPosition = "center";
    video.style.objectFit = "cover";
    video.style.display = this.scene ? "none" : "";
    video.addEventListener("canplay", canPlay);
    return video;
  },
  onWindowResize: function() {
    if (this.element && this.element.videoWidth && this.element.videoHeight && this.scene) {
      const { clientWidth: width, clientHeight: height } = this.container;
      const texture = this.scene.background;
      const { videoWidth, videoHeight } = this.element;
      const cameraRatio = videoHeight / videoWidth;
      const viewportRatio = this.container ? width / height : 1;
      const ratio = cameraRatio * viewportRatio * this.ratioScalar;
      if (width > height) {
        texture.repeat.set(ratio, 1);
      } else {
        texture.repeat.set(1, 1 / ratio);
      }
    }
  }
});
function Reticle(color = 16777215, autoSelect = true, dwellTime = 1500) {
  this.dpr = window.devicePixelRatio;
  const { canvas, context: context2 } = this.createCanvas();
  const material = new SpriteMaterial({ color, map: this.createCanvasTexture(canvas) });
  Sprite.call(this, material);
  this.canvasWidth = canvas.width;
  this.canvasHeight = canvas.height;
  this.context = context2;
  this.color = color instanceof Color ? color : new Color(color);
  this.autoSelect = autoSelect;
  this.dwellTime = dwellTime;
  this.rippleDuration = 500;
  this.position.z = -10;
  this.center.set(0.5, 0.5);
  this.scale.set(0.5, 0.5, 1);
  this.startTimestamp = null;
  this.timerId = null;
  this.callback = null;
  this.frustumCulled = false;
  this.updateCanvasArcByProgress(0);
}
Reticle.prototype = Object.assign(Object.create(Sprite.prototype), {
  constructor: Reticle,
  setColor: function(color) {
    this.material.color.copy(color instanceof Color ? color : new Color(color));
  },
  createCanvasTexture: function(canvas) {
    const texture = new CanvasTexture(canvas);
    texture.minFilter = LinearFilter;
    texture.magFilter = LinearFilter;
    texture.generateMipmaps = false;
    return texture;
  },
  createCanvas: function() {
    const width = 32;
    const height = 32;
    const canvas = document.createElement("canvas");
    const context2 = canvas.getContext("2d");
    const dpr = this.dpr;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    context2.scale(dpr, dpr);
    context2.shadowBlur = 5;
    context2.shadowColor = "rgba(200,200,200,0.9)";
    return { canvas, context: context2 };
  },
  updateCanvasArcByProgress: function(progress) {
    const context2 = this.context;
    const { canvasWidth, canvasHeight, material } = this;
    const dpr = this.dpr;
    const degree = progress * Math.PI * 2;
    const color = this.color.getStyle();
    const x2 = canvasWidth * 0.5 / dpr;
    const y = canvasHeight * 0.5 / dpr;
    const lineWidth = 3;
    context2.clearRect(0, 0, canvasWidth, canvasHeight);
    context2.beginPath();
    if (progress === 0) {
      context2.arc(x2, y, canvasWidth / 16, 0, 2 * Math.PI);
      context2.fillStyle = color;
      context2.fill();
    } else {
      context2.arc(x2, y, canvasWidth / 4 - lineWidth, -Math.PI / 2, -Math.PI / 2 + degree);
      context2.strokeStyle = color;
      context2.lineWidth = lineWidth;
      context2.stroke();
    }
    context2.closePath();
    material.map.needsUpdate = true;
  },
  ripple: function() {
    const context2 = this.context;
    const { canvasWidth, canvasHeight, material } = this;
    const duration = this.rippleDuration;
    const timestamp = performance.now();
    const color = this.color;
    const dpr = this.dpr;
    const x2 = canvasWidth * 0.5 / dpr;
    const y = canvasHeight * 0.5 / dpr;
    const update3 = () => {
      const timerId = window.requestAnimationFrame(update3);
      const elapsed = performance.now() - timestamp;
      const progress = elapsed / duration;
      const opacity = 1 - progress > 0 ? 1 - progress : 0;
      const radius = progress * canvasWidth * 0.5 / dpr;
      context2.clearRect(0, 0, canvasWidth, canvasHeight);
      context2.beginPath();
      context2.arc(x2, y, radius, 0, Math.PI * 2);
      context2.fillStyle = `rgba(${color.r * 255}, ${color.g * 255}, ${color.b * 255}, ${opacity})`;
      context2.fill();
      context2.closePath();
      if (progress >= 1) {
        window.cancelAnimationFrame(timerId);
        this.updateCanvasArcByProgress(0);
        this.dispatchEvent({ type: "reticle-ripple-end" });
      }
      material.map.needsUpdate = true;
    };
    this.dispatchEvent({ type: "reticle-ripple-start" });
    update3();
  },
  show: function() {
    this.visible = true;
  },
  hide: function() {
    this.visible = false;
  },
  start: function(callback) {
    if (!this.autoSelect) {
      return;
    }
    this.dispatchEvent({ type: "reticle-start" });
    this.startTimestamp = performance.now();
    this.callback = callback;
    this.update();
  },
  end: function() {
    if (!this.startTimestamp) {
      return;
    }
    window.cancelAnimationFrame(this.timerId);
    this.updateCanvasArcByProgress(0);
    this.callback = null;
    this.timerId = null;
    this.startTimestamp = null;
    this.dispatchEvent({ type: "reticle-end" });
  },
  update: function() {
    this.timerId = window.requestAnimationFrame(this.update.bind(this));
    const elapsed = performance.now() - this.startTimestamp;
    const progress = elapsed / this.dwellTime;
    this.updateCanvasArcByProgress(progress);
    this.dispatchEvent({ type: "reticle-update", progress });
    if (progress >= 1) {
      window.cancelAnimationFrame(this.timerId);
      if (this.callback) {
        this.callback();
      }
      this.end();
      this.ripple();
    }
  }
});
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
var Tween = createCommonjsModule(function(module, exports2) {
  var _Group = function() {
    this._tweens = {};
    this._tweensAddedDuringUpdate = {};
  };
  _Group.prototype = {
    getAll: function() {
      return Object.keys(this._tweens).map(function(tweenId) {
        return this._tweens[tweenId];
      }.bind(this));
    },
    removeAll: function() {
      this._tweens = {};
    },
    add: function(tween) {
      this._tweens[tween.getId()] = tween;
      this._tweensAddedDuringUpdate[tween.getId()] = tween;
    },
    remove: function(tween) {
      delete this._tweens[tween.getId()];
      delete this._tweensAddedDuringUpdate[tween.getId()];
    },
    update: function(time, preserve) {
      var tweenIds = Object.keys(this._tweens);
      if (tweenIds.length === 0) {
        return false;
      }
      time = time !== void 0 ? time : TWEEN.now();
      while (tweenIds.length > 0) {
        this._tweensAddedDuringUpdate = {};
        for (var i2 = 0; i2 < tweenIds.length; i2++) {
          var tween = this._tweens[tweenIds[i2]];
          if (tween && tween.update(time) === false) {
            tween._isPlaying = false;
            if (!preserve) {
              delete this._tweens[tweenIds[i2]];
            }
          }
        }
        tweenIds = Object.keys(this._tweensAddedDuringUpdate);
      }
      return true;
    }
  };
  var TWEEN = new _Group();
  TWEEN.Group = _Group;
  TWEEN._nextId = 0;
  TWEEN.nextId = function() {
    return TWEEN._nextId++;
  };
  if (typeof self === "undefined" && typeof process !== "undefined" && process.hrtime) {
    TWEEN.now = function() {
      var time = process.hrtime();
      return time[0] * 1e3 + time[1] / 1e6;
    };
  } else if (typeof self !== "undefined" && self.performance !== void 0 && self.performance.now !== void 0) {
    TWEEN.now = self.performance.now.bind(self.performance);
  } else if (Date.now !== void 0) {
    TWEEN.now = Date.now;
  } else {
    TWEEN.now = function() {
      return new Date().getTime();
    };
  }
  TWEEN.Tween = function(object, group) {
    this._object = object;
    this._valuesStart = {};
    this._valuesEnd = {};
    this._valuesStartRepeat = {};
    this._duration = 1e3;
    this._repeat = 0;
    this._repeatDelayTime = void 0;
    this._yoyo = false;
    this._isPlaying = false;
    this._reversed = false;
    this._delayTime = 0;
    this._startTime = null;
    this._easingFunction = TWEEN.Easing.Linear.None;
    this._interpolationFunction = TWEEN.Interpolation.Linear;
    this._chainedTweens = [];
    this._onStartCallback = null;
    this._onStartCallbackFired = false;
    this._onUpdateCallback = null;
    this._onRepeatCallback = null;
    this._onCompleteCallback = null;
    this._onStopCallback = null;
    this._group = group || TWEEN;
    this._id = TWEEN.nextId();
  };
  TWEEN.Tween.prototype = {
    getId: function() {
      return this._id;
    },
    isPlaying: function() {
      return this._isPlaying;
    },
    to: function(properties, duration) {
      this._valuesEnd = Object.create(properties);
      if (duration !== void 0) {
        this._duration = duration;
      }
      return this;
    },
    duration: function duration(d2) {
      this._duration = d2;
      return this;
    },
    start: function(time) {
      this._group.add(this);
      this._isPlaying = true;
      this._onStartCallbackFired = false;
      this._startTime = time !== void 0 ? typeof time === "string" ? TWEEN.now() + parseFloat(time) : time : TWEEN.now();
      this._startTime += this._delayTime;
      for (var property in this._valuesEnd) {
        if (this._valuesEnd[property] instanceof Array) {
          if (this._valuesEnd[property].length === 0) {
            continue;
          }
          this._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);
        }
        if (this._object[property] === void 0) {
          continue;
        }
        this._valuesStart[property] = this._object[property];
        if (this._valuesStart[property] instanceof Array === false) {
          this._valuesStart[property] *= 1;
        }
        this._valuesStartRepeat[property] = this._valuesStart[property] || 0;
      }
      return this;
    },
    stop: function() {
      if (!this._isPlaying) {
        return this;
      }
      this._group.remove(this);
      this._isPlaying = false;
      if (this._onStopCallback !== null) {
        this._onStopCallback(this._object);
      }
      this.stopChainedTweens();
      return this;
    },
    end: function() {
      this.update(Infinity);
      return this;
    },
    stopChainedTweens: function() {
      for (var i2 = 0, numChainedTweens = this._chainedTweens.length; i2 < numChainedTweens; i2++) {
        this._chainedTweens[i2].stop();
      }
    },
    group: function(group) {
      this._group = group;
      return this;
    },
    delay: function(amount) {
      this._delayTime = amount;
      return this;
    },
    repeat: function(times) {
      this._repeat = times;
      return this;
    },
    repeatDelay: function(amount) {
      this._repeatDelayTime = amount;
      return this;
    },
    yoyo: function(yoyo) {
      this._yoyo = yoyo;
      return this;
    },
    easing: function(easingFunction) {
      this._easingFunction = easingFunction;
      return this;
    },
    interpolation: function(interpolationFunction) {
      this._interpolationFunction = interpolationFunction;
      return this;
    },
    chain: function() {
      this._chainedTweens = arguments;
      return this;
    },
    onStart: function(callback) {
      this._onStartCallback = callback;
      return this;
    },
    onUpdate: function(callback) {
      this._onUpdateCallback = callback;
      return this;
    },
    onRepeat: function onRepeat(callback) {
      this._onRepeatCallback = callback;
      return this;
    },
    onComplete: function(callback) {
      this._onCompleteCallback = callback;
      return this;
    },
    onStop: function(callback) {
      this._onStopCallback = callback;
      return this;
    },
    update: function(time) {
      var property;
      var elapsed;
      var value;
      if (time < this._startTime) {
        return true;
      }
      if (this._onStartCallbackFired === false) {
        if (this._onStartCallback !== null) {
          this._onStartCallback(this._object);
        }
        this._onStartCallbackFired = true;
      }
      elapsed = (time - this._startTime) / this._duration;
      elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
      value = this._easingFunction(elapsed);
      for (property in this._valuesEnd) {
        if (this._valuesStart[property] === void 0) {
          continue;
        }
        var start = this._valuesStart[property] || 0;
        var end = this._valuesEnd[property];
        if (end instanceof Array) {
          this._object[property] = this._interpolationFunction(end, value);
        } else {
          if (typeof end === "string") {
            if (end.charAt(0) === "+" || end.charAt(0) === "-") {
              end = start + parseFloat(end);
            } else {
              end = parseFloat(end);
            }
          }
          if (typeof end === "number") {
            this._object[property] = start + (end - start) * value;
          }
        }
      }
      if (this._onUpdateCallback !== null) {
        this._onUpdateCallback(this._object, elapsed);
      }
      if (elapsed === 1) {
        if (this._repeat > 0) {
          if (isFinite(this._repeat)) {
            this._repeat--;
          }
          for (property in this._valuesStartRepeat) {
            if (typeof this._valuesEnd[property] === "string") {
              this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
            }
            if (this._yoyo) {
              var tmp2 = this._valuesStartRepeat[property];
              this._valuesStartRepeat[property] = this._valuesEnd[property];
              this._valuesEnd[property] = tmp2;
            }
            this._valuesStart[property] = this._valuesStartRepeat[property];
          }
          if (this._yoyo) {
            this._reversed = !this._reversed;
          }
          if (this._repeatDelayTime !== void 0) {
            this._startTime = time + this._repeatDelayTime;
          } else {
            this._startTime = time + this._delayTime;
          }
          if (this._onRepeatCallback !== null) {
            this._onRepeatCallback(this._object);
          }
          return true;
        } else {
          if (this._onCompleteCallback !== null) {
            this._onCompleteCallback(this._object);
          }
          for (var i2 = 0, numChainedTweens = this._chainedTweens.length; i2 < numChainedTweens; i2++) {
            this._chainedTweens[i2].start(this._startTime + this._duration);
          }
          return false;
        }
      }
      return true;
    }
  };
  TWEEN.Easing = {
    Linear: {
      None: function(k2) {
        return k2;
      }
    },
    Quadratic: {
      In: function(k2) {
        return k2 * k2;
      },
      Out: function(k2) {
        return k2 * (2 - k2);
      },
      InOut: function(k2) {
        if ((k2 *= 2) < 1) {
          return 0.5 * k2 * k2;
        }
        return -0.5 * (--k2 * (k2 - 2) - 1);
      }
    },
    Cubic: {
      In: function(k2) {
        return k2 * k2 * k2;
      },
      Out: function(k2) {
        return --k2 * k2 * k2 + 1;
      },
      InOut: function(k2) {
        if ((k2 *= 2) < 1) {
          return 0.5 * k2 * k2 * k2;
        }
        return 0.5 * ((k2 -= 2) * k2 * k2 + 2);
      }
    },
    Quartic: {
      In: function(k2) {
        return k2 * k2 * k2 * k2;
      },
      Out: function(k2) {
        return 1 - --k2 * k2 * k2 * k2;
      },
      InOut: function(k2) {
        if ((k2 *= 2) < 1) {
          return 0.5 * k2 * k2 * k2 * k2;
        }
        return -0.5 * ((k2 -= 2) * k2 * k2 * k2 - 2);
      }
    },
    Quintic: {
      In: function(k2) {
        return k2 * k2 * k2 * k2 * k2;
      },
      Out: function(k2) {
        return --k2 * k2 * k2 * k2 * k2 + 1;
      },
      InOut: function(k2) {
        if ((k2 *= 2) < 1) {
          return 0.5 * k2 * k2 * k2 * k2 * k2;
        }
        return 0.5 * ((k2 -= 2) * k2 * k2 * k2 * k2 + 2);
      }
    },
    Sinusoidal: {
      In: function(k2) {
        return 1 - Math.cos(k2 * Math.PI / 2);
      },
      Out: function(k2) {
        return Math.sin(k2 * Math.PI / 2);
      },
      InOut: function(k2) {
        return 0.5 * (1 - Math.cos(Math.PI * k2));
      }
    },
    Exponential: {
      In: function(k2) {
        return k2 === 0 ? 0 : Math.pow(1024, k2 - 1);
      },
      Out: function(k2) {
        return k2 === 1 ? 1 : 1 - Math.pow(2, -10 * k2);
      },
      InOut: function(k2) {
        if (k2 === 0) {
          return 0;
        }
        if (k2 === 1) {
          return 1;
        }
        if ((k2 *= 2) < 1) {
          return 0.5 * Math.pow(1024, k2 - 1);
        }
        return 0.5 * (-Math.pow(2, -10 * (k2 - 1)) + 2);
      }
    },
    Circular: {
      In: function(k2) {
        return 1 - Math.sqrt(1 - k2 * k2);
      },
      Out: function(k2) {
        return Math.sqrt(1 - --k2 * k2);
      },
      InOut: function(k2) {
        if ((k2 *= 2) < 1) {
          return -0.5 * (Math.sqrt(1 - k2 * k2) - 1);
        }
        return 0.5 * (Math.sqrt(1 - (k2 -= 2) * k2) + 1);
      }
    },
    Elastic: {
      In: function(k2) {
        if (k2 === 0) {
          return 0;
        }
        if (k2 === 1) {
          return 1;
        }
        return -Math.pow(2, 10 * (k2 - 1)) * Math.sin((k2 - 1.1) * 5 * Math.PI);
      },
      Out: function(k2) {
        if (k2 === 0) {
          return 0;
        }
        if (k2 === 1) {
          return 1;
        }
        return Math.pow(2, -10 * k2) * Math.sin((k2 - 0.1) * 5 * Math.PI) + 1;
      },
      InOut: function(k2) {
        if (k2 === 0) {
          return 0;
        }
        if (k2 === 1) {
          return 1;
        }
        k2 *= 2;
        if (k2 < 1) {
          return -0.5 * Math.pow(2, 10 * (k2 - 1)) * Math.sin((k2 - 1.1) * 5 * Math.PI);
        }
        return 0.5 * Math.pow(2, -10 * (k2 - 1)) * Math.sin((k2 - 1.1) * 5 * Math.PI) + 1;
      }
    },
    Back: {
      In: function(k2) {
        var s2 = 1.70158;
        return k2 * k2 * ((s2 + 1) * k2 - s2);
      },
      Out: function(k2) {
        var s2 = 1.70158;
        return --k2 * k2 * ((s2 + 1) * k2 + s2) + 1;
      },
      InOut: function(k2) {
        var s2 = 1.70158 * 1.525;
        if ((k2 *= 2) < 1) {
          return 0.5 * (k2 * k2 * ((s2 + 1) * k2 - s2));
        }
        return 0.5 * ((k2 -= 2) * k2 * ((s2 + 1) * k2 + s2) + 2);
      }
    },
    Bounce: {
      In: function(k2) {
        return 1 - TWEEN.Easing.Bounce.Out(1 - k2);
      },
      Out: function(k2) {
        if (k2 < 1 / 2.75) {
          return 7.5625 * k2 * k2;
        } else if (k2 < 2 / 2.75) {
          return 7.5625 * (k2 -= 1.5 / 2.75) * k2 + 0.75;
        } else if (k2 < 2.5 / 2.75) {
          return 7.5625 * (k2 -= 2.25 / 2.75) * k2 + 0.9375;
        } else {
          return 7.5625 * (k2 -= 2.625 / 2.75) * k2 + 0.984375;
        }
      },
      InOut: function(k2) {
        if (k2 < 0.5) {
          return TWEEN.Easing.Bounce.In(k2 * 2) * 0.5;
        }
        return TWEEN.Easing.Bounce.Out(k2 * 2 - 1) * 0.5 + 0.5;
      }
    }
  };
  TWEEN.Interpolation = {
    Linear: function(v2, k2) {
      var m2 = v2.length - 1;
      var f2 = m2 * k2;
      var i2 = Math.floor(f2);
      var fn = TWEEN.Interpolation.Utils.Linear;
      if (k2 < 0) {
        return fn(v2[0], v2[1], f2);
      }
      if (k2 > 1) {
        return fn(v2[m2], v2[m2 - 1], m2 - f2);
      }
      return fn(v2[i2], v2[i2 + 1 > m2 ? m2 : i2 + 1], f2 - i2);
    },
    Bezier: function(v2, k2) {
      var b2 = 0;
      var n2 = v2.length - 1;
      var pw = Math.pow;
      var bn = TWEEN.Interpolation.Utils.Bernstein;
      for (var i2 = 0; i2 <= n2; i2++) {
        b2 += pw(1 - k2, n2 - i2) * pw(k2, i2) * v2[i2] * bn(n2, i2);
      }
      return b2;
    },
    CatmullRom: function(v2, k2) {
      var m2 = v2.length - 1;
      var f2 = m2 * k2;
      var i2 = Math.floor(f2);
      var fn = TWEEN.Interpolation.Utils.CatmullRom;
      if (v2[0] === v2[m2]) {
        if (k2 < 0) {
          i2 = Math.floor(f2 = m2 * (1 + k2));
        }
        return fn(v2[(i2 - 1 + m2) % m2], v2[i2], v2[(i2 + 1) % m2], v2[(i2 + 2) % m2], f2 - i2);
      } else {
        if (k2 < 0) {
          return v2[0] - (fn(v2[0], v2[0], v2[1], v2[1], -f2) - v2[0]);
        }
        if (k2 > 1) {
          return v2[m2] - (fn(v2[m2], v2[m2], v2[m2 - 1], v2[m2 - 1], f2 - m2) - v2[m2]);
        }
        return fn(v2[i2 ? i2 - 1 : 0], v2[i2], v2[m2 < i2 + 1 ? m2 : i2 + 1], v2[m2 < i2 + 2 ? m2 : i2 + 2], f2 - i2);
      }
    },
    Utils: {
      Linear: function(p0, p1, t2) {
        return (p1 - p0) * t2 + p0;
      },
      Bernstein: function(n2, i2) {
        var fc = TWEEN.Interpolation.Utils.Factorial;
        return fc(n2) / fc(i2) / fc(n2 - i2);
      },
      Factorial: function() {
        var a2 = [1];
        return function(n2) {
          var s2 = 1;
          if (a2[n2]) {
            return a2[n2];
          }
          for (var i2 = n2; i2 > 1; i2--) {
            s2 *= i2;
          }
          a2[n2] = s2;
          return s2;
        };
      }(),
      CatmullRom: function(p0, p1, p2, p3, t2) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t22 = t2 * t2;
        var t3 = t2 * t22;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t22 + v0 * t2 + p1;
      }
    }
  };
  (function(root) {
    {
      module.exports = TWEEN;
    }
  })();
});
function Infospot(scale2 = 300, imageSrc, animated) {
  const duration = 500, scaleFactor = 1.3;
  imageSrc = imageSrc || DataImage.Info;
  Sprite.call(this);
  this.type = "infospot";
  this.animated = animated !== void 0 ? animated : true;
  this.isHovering = false;
  this.frustumCulled = false;
  this.element = null;
  this.toPanorama = null;
  this.cursorStyle = null;
  this.mode = MODES.NORMAL;
  this.scale.set(scale2, scale2, 1);
  this.rotation.y = Math.PI;
  this.container = null;
  this.originalRaycast = this.raycast;
  this.HANDLER_FOCUS = null;
  this.material.side = DoubleSide;
  this.material.depthTest = false;
  this.material.transparent = true;
  this.material.opacity = 0;
  this.scaleUpAnimation = new Tween.Tween();
  this.scaleDownAnimation = new Tween.Tween();
  const postLoad = function(texture) {
    if (!this.material) {
      return;
    }
    const ratio = texture.image.width / texture.image.height;
    const textureScale = new Vector3();
    texture.image.width = texture.image.naturalWidth || 64;
    texture.image.height = texture.image.naturalHeight || 64;
    this.scale.set(ratio * scale2, scale2, 1);
    textureScale.copy(this.scale);
    this.scaleUpAnimation = new Tween.Tween(this.scale).to({ x: textureScale.x * scaleFactor, y: textureScale.y * scaleFactor }, duration).easing(Tween.Easing.Elastic.Out);
    this.scaleDownAnimation = new Tween.Tween(this.scale).to({ x: textureScale.x, y: textureScale.y }, duration).easing(Tween.Easing.Elastic.Out);
    this.material.map = texture;
    this.material.needsUpdate = true;
  }.bind(this);
  this.showAnimation = new Tween.Tween(this.material).to({ opacity: 1 }, duration).onStart(this.enableRaycast.bind(this, true)).easing(Tween.Easing.Quartic.Out);
  this.hideAnimation = new Tween.Tween(this.material).to({ opacity: 0 }, duration).onStart(this.enableRaycast.bind(this, false)).easing(Tween.Easing.Quartic.Out);
  this.addEventListener("click", this.onClick);
  this.addEventListener("hover", this.onHover);
  this.addEventListener("hoverenter", this.onHoverStart);
  this.addEventListener("hoverleave", this.onHoverEnd);
  this.addEventListener("panolens-dual-eye-effect", this.onDualEyeEffect);
  this.addEventListener("panolens-container", this.setContainer.bind(this));
  this.addEventListener("dismiss", this.onDismiss);
  this.addEventListener("panolens-infospot-focus", this.setFocusMethod);
  TextureLoader.load(imageSrc, postLoad);
}
Infospot.prototype = Object.assign(Object.create(Sprite.prototype), {
  constructor: Infospot,
  setContainer: function(data) {
    let container;
    if (data instanceof HTMLElement) {
      container = data;
    } else if (data && data.container) {
      container = data.container;
    }
    if (container && this.element) {
      container.appendChild(this.element);
    }
    this.container = container;
  },
  getContainer: function() {
    return this.container;
  },
  onClick: function(event) {
    if (this.element && this.getContainer()) {
      this.onHoverStart(event);
      this.lockHoverElement();
    }
  },
  onDismiss: function() {
    if (this.element) {
      this.unlockHoverElement();
      this.onHoverEnd();
    }
  },
  onHover: function() {
  },
  onHoverStart: function(event) {
    if (!this.getContainer()) {
      return;
    }
    const cursorStyle = this.cursorStyle || (this.mode === MODES.NORMAL ? "pointer" : "default");
    const { scaleDownAnimation, scaleUpAnimation, element } = this;
    this.isHovering = true;
    this.container.style.cursor = cursorStyle;
    if (this.animated) {
      scaleDownAnimation.stop();
      scaleUpAnimation.start();
    }
    if (element && event.mouseEvent.clientX >= 0 && event.mouseEvent.clientY >= 0) {
      const { left, right, style } = element;
      if (this.mode === MODES.CARDBOARD || this.mode === MODES.STEREO) {
        style.display = "none";
        left.style.display = "block";
        right.style.display = "block";
        element._width = left.clientWidth;
        element._height = left.clientHeight;
      } else {
        style.display = "block";
        if (left) {
          left.style.display = "none";
        }
        if (right) {
          right.style.display = "none";
        }
        element._width = element.clientWidth;
        element._height = element.clientHeight;
      }
    }
  },
  onHoverEnd: function() {
    if (!this.getContainer()) {
      return;
    }
    const { scaleDownAnimation, scaleUpAnimation, element } = this;
    this.isHovering = false;
    this.container.style.cursor = "default";
    if (this.animated) {
      scaleUpAnimation.stop();
      scaleDownAnimation.start();
    }
    if (element && !this.element.locked) {
      const { left, right, style } = element;
      style.display = "none";
      if (left) {
        left.style.display = "none";
      }
      if (right) {
        right.style.display = "none";
      }
      this.unlockHoverElement();
    }
  },
  onDualEyeEffect: function(event) {
    if (!this.getContainer()) {
      return;
    }
    let element, halfWidth, halfHeight;
    this.mode = event.mode;
    element = this.element;
    halfWidth = this.container.clientWidth / 2;
    halfHeight = this.container.clientHeight / 2;
    if (!element) {
      return;
    }
    if (!element.left && !element.right) {
      element.left = element.cloneNode(true);
      element.right = element.cloneNode(true);
    }
    if (this.mode === MODES.CARDBOARD || this.mode === MODES.STEREO) {
      element.left.style.display = element.style.display;
      element.right.style.display = element.style.display;
      element.style.display = "none";
    } else {
      element.style.display = element.left.style.display;
      element.left.style.display = "none";
      element.right.style.display = "none";
    }
    this.translateElement(halfWidth, halfHeight);
    this.container.appendChild(element.left);
    this.container.appendChild(element.right);
  },
  translateElement: function(x2, y) {
    if (!this.element._width || !this.element._height || !this.getContainer()) {
      return;
    }
    let left, top, element, width, height, delta, container;
    container = this.container;
    element = this.element;
    width = element._width / 2;
    height = element._height / 2;
    delta = element.verticalDelta !== void 0 ? element.verticalDelta : 40;
    left = x2 - width;
    top = y - height - delta;
    if ((this.mode === MODES.CARDBOARD || this.mode === MODES.STEREO) && element.left && element.right && !(x2 === container.clientWidth / 2 && y === container.clientHeight / 2)) {
      left = container.clientWidth / 4 - width + (x2 - container.clientWidth / 2);
      top = container.clientHeight / 2 - height - delta + (y - container.clientHeight / 2);
      this.setElementStyle("transform", element.left, "translate(" + left + "px, " + top + "px)");
      left += container.clientWidth / 2;
      this.setElementStyle("transform", element.right, "translate(" + left + "px, " + top + "px)");
    } else {
      this.setElementStyle("transform", element, "translate(" + left + "px, " + top + "px)");
    }
  },
  setElementStyle: function(type, element, value) {
    const style = element.style;
    if (type === "transform") {
      style.webkitTransform = style.msTransform = style.transform = value;
    }
  },
  setText: function(text2) {
    if (this.element) {
      this.element.textContent = text2;
    }
  },
  setCursorHoverStyle: function(style) {
    this.cursorStyle = style;
  },
  addHoverText: function(text2, delta = 40) {
    if (!this.element) {
      this.element = document.createElement("div");
      this.element.style.display = "none";
      this.element.style.color = "#fff";
      this.element.style.top = 0;
      this.element.style.maxWidth = "50%";
      this.element.style.maxHeight = "50%";
      this.element.style.textShadow = "0 0 3px #000000";
      this.element.style.fontFamily = '"Trebuchet MS", Helvetica, sans-serif';
      this.element.style.position = "absolute";
      this.element.classList.add("panolens-infospot");
      this.element.verticalDelta = delta;
    }
    this.setText(text2);
  },
  addHoverElement: function(el, delta = 40) {
    if (!this.element) {
      this.element = el.cloneNode(true);
      this.element.style.display = "none";
      this.element.style.top = 0;
      this.element.style.position = "absolute";
      this.element.classList.add("panolens-infospot");
      this.element.verticalDelta = delta;
    }
  },
  removeHoverElement: function() {
    if (this.element) {
      if (this.element.left) {
        this.container.removeChild(this.element.left);
        this.element.left = null;
      }
      if (this.element.right) {
        this.container.removeChild(this.element.right);
        this.element.right = null;
      }
      this.container.removeChild(this.element);
      this.element = null;
    }
  },
  lockHoverElement: function() {
    if (this.element) {
      this.element.locked = true;
    }
  },
  unlockHoverElement: function() {
    if (this.element) {
      this.element.locked = false;
    }
  },
  enableRaycast: function(enabled = true) {
    if (enabled) {
      this.raycast = this.originalRaycast;
    } else {
      this.raycast = () => {
      };
    }
  },
  show: function(delay = 0) {
    const { animated, hideAnimation, showAnimation, material } = this;
    if (animated) {
      hideAnimation.stop();
      showAnimation.delay(delay).start();
    } else {
      this.enableRaycast(true);
      material.opacity = 1;
    }
  },
  hide: function(delay = 0) {
    const { animated, hideAnimation, showAnimation, material, element } = this;
    if (element) {
      const { style } = element;
      style.display = "none";
    }
    if (animated) {
      showAnimation.stop();
      hideAnimation.delay(delay).start();
    } else {
      this.enableRaycast(false);
      material.opacity = 0;
    }
  },
  setFocusMethod: function(event) {
    if (event) {
      this.HANDLER_FOCUS = event.method;
    }
  },
  focus: function(duration, easing) {
    if (this.HANDLER_FOCUS) {
      this.HANDLER_FOCUS(this.position, duration, easing);
      this.onDismiss();
    }
  },
  dispose: function() {
    const { geometry: geometry2, material } = this;
    const { map } = material;
    this.removeHoverElement();
    if (this.parent) {
      this.parent.remove(this);
    }
    if (map) {
      map.dispose();
      material.map = null;
    }
    if (geometry2) {
      geometry2.dispose();
      this.geometry = null;
    }
    if (material) {
      material.dispose();
      this.material = null;
    }
  }
});
function Widget(container) {
  if (!container) {
    console.warn("PANOLENS.Widget: No container specified");
  }
  EventDispatcher.call(this);
  this.DEFAULT_TRANSITION = "all 0.27s ease";
  this.TOUCH_ENABLED = !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch);
  this.PREVENT_EVENT_HANDLER = function(event) {
    event.preventDefault();
    event.stopPropagation();
  };
  this.container = container;
  this.barElement = null;
  this.fullscreenElement = null;
  this.videoElement = null;
  this.settingElement = null;
  this.mainMenu = null;
  this.activeMainItem = null;
  this.activeSubMenu = null;
  this.mask = null;
}
Widget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Widget,
  addControlBar: function() {
    if (!this.container) {
      console.warn("Widget container not set");
      return;
    }
    var scope = this, bar, styleTranslate, styleOpacity, gradientStyle;
    gradientStyle = "linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))";
    bar = document.createElement("div");
    bar.style.width = "100%";
    bar.style.height = "44px";
    bar.style.float = "left";
    bar.style.transform = bar.style.webkitTransform = bar.style.msTransform = "translateY(-100%)";
    bar.style.background = "-webkit-" + gradientStyle;
    bar.style.background = "-moz-" + gradientStyle;
    bar.style.background = "-o-" + gradientStyle;
    bar.style.background = "-ms-" + gradientStyle;
    bar.style.background = gradientStyle;
    bar.style.transition = this.DEFAULT_TRANSITION;
    bar.style.pointerEvents = "none";
    bar.isHidden = false;
    bar.toggle = function() {
      bar.isHidden = !bar.isHidden;
      styleTranslate = bar.isHidden ? "translateY(0)" : "translateY(-100%)";
      styleOpacity = bar.isHidden ? 0 : 1;
      bar.style.transform = bar.style.webkitTransform = bar.style.msTransform = styleTranslate;
      bar.style.opacity = styleOpacity;
    };
    var menu = this.createDefaultMenu();
    this.mainMenu = this.createMainMenu(menu);
    bar.appendChild(this.mainMenu);
    var mask = this.createMask();
    this.mask = mask;
    this.container.appendChild(mask);
    bar.dispose = function() {
      if (scope.fullscreenElement) {
        bar.removeChild(scope.fullscreenElement);
        scope.fullscreenElement.dispose();
        scope.fullscreenElement = null;
      }
      if (scope.settingElement) {
        bar.removeChild(scope.settingElement);
        scope.settingElement.dispose();
        scope.settingElement = null;
      }
      if (scope.videoElement) {
        bar.removeChild(scope.videoElement);
        scope.videoElement.dispose();
        scope.videoElement = null;
      }
    };
    this.container.appendChild(bar);
    this.mask.addEventListener("mousemove", this.PREVENT_EVENT_HANDLER, true);
    this.mask.addEventListener("mouseup", this.PREVENT_EVENT_HANDLER, true);
    this.mask.addEventListener("mousedown", this.PREVENT_EVENT_HANDLER, true);
    this.mask.addEventListener(scope.TOUCH_ENABLED ? "touchend" : "click", function(event) {
      event.preventDefault();
      event.stopPropagation();
      scope.mask.hide();
      scope.settingElement.deactivate();
    }, false);
    this.addEventListener("control-bar-toggle", bar.toggle);
    this.barElement = bar;
  },
  createDefaultMenu: function() {
    var scope = this, handler;
    handler = function(method, data) {
      return function() {
        scope.dispatchEvent({
          type: "panolens-viewer-handler",
          method,
          data
        });
      };
    };
    return [
      {
        title: "Control",
        subMenu: [
          {
            title: this.TOUCH_ENABLED ? "Touch" : "Mouse",
            handler: handler("enableControl", CONTROLS.ORBIT)
          },
          {
            title: "Sensor",
            handler: handler("enableControl", CONTROLS.DEVICEORIENTATION)
          }
        ]
      },
      {
        title: "Mode",
        subMenu: [
          {
            title: "Normal",
            handler: handler("disableEffect")
          },
          {
            title: "Cardboard",
            handler: handler("enableEffect", MODES.CARDBOARD)
          },
          {
            title: "Stereoscopic",
            handler: handler("enableEffect", MODES.STEREO)
          }
        ]
      }
    ];
  },
  addControlButton: function(name) {
    let element;
    switch (name) {
      case "fullscreen":
        element = this.createFullscreenButton();
        this.fullscreenElement = element;
        break;
      case "setting":
        element = this.createSettingButton();
        this.settingElement = element;
        break;
      case "video":
        element = this.createVideoControl();
        this.videoElement = element;
        break;
      default:
        return;
    }
    if (!element) {
      return;
    }
    this.barElement.appendChild(element);
  },
  createMask: function() {
    const element = document.createElement("div");
    element.style.position = "absolute";
    element.style.top = 0;
    element.style.left = 0;
    element.style.width = "100%";
    element.style.height = "100%";
    element.style.background = "transparent";
    element.style.display = "none";
    element.show = function() {
      this.style.display = "block";
    };
    element.hide = function() {
      this.style.display = "none";
    };
    return element;
  },
  createSettingButton: function() {
    let scope = this, item;
    function onTap(event) {
      event.preventDefault();
      event.stopPropagation();
      scope.mainMenu.toggle();
      if (this.activated) {
        this.deactivate();
      } else {
        this.activate();
      }
    }
    item = this.createCustomItem({
      style: {
        backgroundImage: 'url("' + DataImage.Setting + '")',
        webkitTransition: this.DEFAULT_TRANSITION,
        transition: this.DEFAULT_TRANSITION
      },
      onTap
    });
    item.activate = function() {
      this.style.transform = "rotate3d(0,0,1,90deg)";
      this.activated = true;
      scope.mask.show();
    };
    item.deactivate = function() {
      this.style.transform = "rotate3d(0,0,0,0)";
      this.activated = false;
      scope.mask.hide();
      if (scope.mainMenu && scope.mainMenu.visible) {
        scope.mainMenu.hide();
      }
      if (scope.activeSubMenu && scope.activeSubMenu.visible) {
        scope.activeSubMenu.hide();
      }
      if (scope.mainMenu && scope.mainMenu._width) {
        scope.mainMenu.changeSize(scope.mainMenu._width);
        scope.mainMenu.unslideAll();
      }
    };
    item.activated = false;
    return item;
  },
  createFullscreenButton: function() {
    let scope = this, item, isFullscreen = false, tapSkipped = true, stylesheetId;
    const { container } = this;
    stylesheetId = "panolens-style-addon";
    if (!document.fullscreenEnabled && !document.webkitFullscreenEnabled && !document.mozFullScreenEnabled && !document.msFullscreenEnabled) {
      return;
    }
    function onTap(event) {
      event.preventDefault();
      event.stopPropagation();
      tapSkipped = false;
      if (!isFullscreen) {
        if (container.requestFullscreen) {
          container.requestFullscreen();
        }
        if (container.msRequestFullscreen) {
          container.msRequestFullscreen();
        }
        if (container.mozRequestFullScreen) {
          container.mozRequestFullScreen();
        }
        if (container.webkitRequestFullscreen) {
          container.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
        }
        isFullscreen = true;
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        }
        if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
        if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        }
        if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        }
        isFullscreen = false;
      }
      this.style.backgroundImage = isFullscreen ? 'url("' + DataImage.FullscreenLeave + '")' : 'url("' + DataImage.FullscreenEnter + '")';
    }
    function onFullScreenChange() {
      if (tapSkipped) {
        isFullscreen = !isFullscreen;
        item.style.backgroundImage = isFullscreen ? 'url("' + DataImage.FullscreenLeave + '")' : 'url("' + DataImage.FullscreenEnter + '")';
      }
      scope.dispatchEvent({ type: "panolens-viewer-handler", method: "onWindowResize" });
      tapSkipped = true;
    }
    document.addEventListener("fullscreenchange", onFullScreenChange, false);
    document.addEventListener("webkitfullscreenchange", onFullScreenChange, false);
    document.addEventListener("mozfullscreenchange", onFullScreenChange, false);
    document.addEventListener("MSFullscreenChange", onFullScreenChange, false);
    item = this.createCustomItem({
      style: {
        backgroundImage: 'url("' + DataImage.FullscreenEnter + '")'
      },
      onTap
    });
    if (!document.querySelector(stylesheetId)) {
      const sheet = document.createElement("style");
      sheet.id = stylesheetId;
      sheet.innerHTML = ":-webkit-full-screen { width: 100% !important; height: 100% !important }";
      document.body.appendChild(sheet);
    }
    return item;
  },
  createVideoControl: function() {
    const item = document.createElement("span");
    item.style.display = "none";
    item.show = function() {
      item.style.display = "";
    };
    item.hide = function() {
      item.style.display = "none";
      item.controlButton.paused = true;
      item.controlButton.update();
    };
    item.controlButton = this.createVideoControlButton();
    item.seekBar = this.createVideoControlSeekbar();
    item.appendChild(item.controlButton);
    item.appendChild(item.seekBar);
    item.dispose = function() {
      item.removeChild(item.controlButton);
      item.removeChild(item.seekBar);
      item.controlButton.dispose();
      item.controlButton = null;
      item.seekBar.dispose();
      item.seekBar = null;
    };
    this.addEventListener("video-control-show", item.show);
    this.addEventListener("video-control-hide", item.hide);
    return item;
  },
  createVideoControlButton: function() {
    const scope = this;
    function onTap(event) {
      event.preventDefault();
      event.stopPropagation();
      scope.dispatchEvent({ type: "panolens-viewer-handler", method: "toggleVideoPlay", data: !this.paused });
      this.paused = !this.paused;
      item.update();
    }
    const item = this.createCustomItem({
      style: {
        float: "left",
        backgroundImage: 'url("' + DataImage.VideoPlay + '")'
      },
      onTap
    });
    item.paused = true;
    item.update = function(paused) {
      this.paused = paused !== void 0 ? paused : this.paused;
      this.style.backgroundImage = 'url("' + (this.paused ? DataImage.VideoPlay : DataImage.VideoPause) + '")';
    };
    return item;
  },
  createVideoControlSeekbar: function() {
    let scope = this, item, progressElement, progressElementControl, isDragging = false, mouseX, percentageNow, percentageNext;
    progressElement = document.createElement("div");
    progressElement.style.width = "0%";
    progressElement.style.height = "100%";
    progressElement.style.backgroundColor = "#fff";
    progressElementControl = document.createElement("div");
    progressElementControl.style.float = "right";
    progressElementControl.style.width = "14px";
    progressElementControl.style.height = "14px";
    progressElementControl.style.transform = "translate(7px, -5px)";
    progressElementControl.style.borderRadius = "50%";
    progressElementControl.style.backgroundColor = "#ddd";
    progressElementControl.addEventListener("mousedown", onMouseDown, { passive: true });
    progressElementControl.addEventListener("touchstart", onMouseDown, { passive: true });
    function onMouseDown(event) {
      event.stopPropagation();
      isDragging = true;
      mouseX = event.clientX || event.changedTouches && event.changedTouches[0].clientX;
      percentageNow = parseInt(progressElement.style.width) / 100;
      addControlListeners();
    }
    function onVideoControlDrag(event) {
      if (isDragging) {
        const clientX = event.clientX || event.changedTouches && event.changedTouches[0].clientX;
        percentageNext = (clientX - mouseX) / item.clientWidth;
        percentageNext = percentageNow + percentageNext;
        percentageNext = percentageNext > 1 ? 1 : percentageNext < 0 ? 0 : percentageNext;
        item.setProgress(percentageNext);
        scope.dispatchEvent({ type: "panolens-viewer-handler", method: "setVideoCurrentTime", data: percentageNext });
      }
    }
    function onVideoControlStop(event) {
      event.stopPropagation();
      isDragging = false;
      removeControlListeners();
    }
    function addControlListeners() {
      scope.container.addEventListener("mousemove", onVideoControlDrag, { passive: true });
      scope.container.addEventListener("mouseup", onVideoControlStop, { passive: true });
      scope.container.addEventListener("touchmove", onVideoControlDrag, { passive: true });
      scope.container.addEventListener("touchend", onVideoControlStop, { passive: true });
    }
    function removeControlListeners() {
      scope.container.removeEventListener("mousemove", onVideoControlDrag, false);
      scope.container.removeEventListener("mouseup", onVideoControlStop, false);
      scope.container.removeEventListener("touchmove", onVideoControlDrag, false);
      scope.container.removeEventListener("touchend", onVideoControlStop, false);
    }
    function onTap(event) {
      event.preventDefault();
      event.stopPropagation();
      if (event.target === progressElementControl) {
        return;
      }
      const percentage = event.changedTouches && event.changedTouches.length > 0 ? (event.changedTouches[0].pageX - event.target.getBoundingClientRect().left) / this.clientWidth : event.offsetX / this.clientWidth;
      scope.dispatchEvent({ type: "panolens-viewer-handler", method: "setVideoCurrentTime", data: percentage });
      item.setProgress(event.offsetX / this.clientWidth);
    }
    function onDispose() {
      removeControlListeners();
      progressElement = null;
      progressElementControl = null;
    }
    progressElement.appendChild(progressElementControl);
    item = this.createCustomItem({
      style: {
        float: "left",
        width: "30%",
        height: "4px",
        marginTop: "20px",
        backgroundColor: "rgba(188,188,188,0.8)"
      },
      onTap,
      onDispose
    });
    item.appendChild(progressElement);
    item.setProgress = function(percentage) {
      progressElement.style.width = percentage * 100 + "%";
    };
    this.addEventListener("video-update", function(event) {
      item.setProgress(event.percentage);
    });
    item.progressElement = progressElement;
    item.progressElementControl = progressElementControl;
    return item;
  },
  createMenuItem: function(title) {
    const scope = this;
    const item = document.createElement("a");
    item.textContent = title;
    item.style.display = "block";
    item.style.padding = "10px";
    item.style.textDecoration = "none";
    item.style.cursor = "pointer";
    item.style.pointerEvents = "auto";
    item.style.transition = this.DEFAULT_TRANSITION;
    item.slide = function(right) {
      this.style.transform = "translateX(" + (right ? "" : "-") + "100%)";
    };
    item.unslide = function() {
      this.style.transform = "translateX(0)";
    };
    item.setIcon = function(url) {
      if (this.icon) {
        this.icon.style.backgroundImage = "url(" + url + ")";
      }
    };
    item.setSelectionTitle = function(title2) {
      if (this.selection) {
        this.selection.textContent = title2;
      }
    };
    item.addSelection = function(name) {
      const selection = document.createElement("span");
      selection.style.fontSize = "13px";
      selection.style.fontWeight = "300";
      selection.style.float = "right";
      this.selection = selection;
      this.setSelectionTitle(name);
      this.appendChild(selection);
      return this;
    };
    item.addIcon = function(url = DataImage.ChevronRight, left = false, flip = false) {
      const element = document.createElement("span");
      element.style.float = left ? "left" : "right";
      element.style.width = "17px";
      element.style.height = "17px";
      element.style["margin" + (left ? "Right" : "Left")] = "12px";
      element.style.backgroundSize = "cover";
      if (flip) {
        element.style.transform = "rotateZ(180deg)";
      }
      this.icon = element;
      this.setIcon(url);
      this.appendChild(element);
      return this;
    };
    item.addSubMenu = function(title2, items) {
      this.subMenu = scope.createSubMenu(title2, items);
      return this;
    };
    item.addEventListener("mouseenter", function() {
      this.style.backgroundColor = "#e0e0e0";
    }, false);
    item.addEventListener("mouseleave", function() {
      this.style.backgroundColor = "#fafafa";
    }, false);
    return item;
  },
  createMenuItemHeader: function(title) {
    const header = this.createMenuItem(title);
    header.style.borderBottom = "1px solid #333";
    header.style.paddingBottom = "15px";
    return header;
  },
  createMainMenu: function(menus) {
    let scope = this, menu = this.createMenu();
    menu._width = 200;
    menu.changeSize(menu._width);
    function onTap(event) {
      event.preventDefault();
      event.stopPropagation();
      let mainMenu = scope.mainMenu, subMenu = this.subMenu;
      function onNextTick() {
        mainMenu.changeSize(subMenu.clientWidth);
        subMenu.show();
        subMenu.unslideAll();
      }
      mainMenu.hide();
      mainMenu.slideAll();
      mainMenu.parentElement.appendChild(subMenu);
      scope.activeMainItem = this;
      scope.activeSubMenu = subMenu;
      window.requestAnimationFrame(onNextTick);
    }
    for (var i2 = 0; i2 < menus.length; i2++) {
      var item = menu.addItem(menus[i2].title);
      item.style.paddingLeft = "20px";
      item.addIcon().addEventListener(scope.TOUCH_ENABLED ? "touchend" : "click", onTap, false);
      if (menus[i2].subMenu && menus[i2].subMenu.length > 0) {
        var title = menus[i2].subMenu[0].title;
        item.addSelection(title).addSubMenu(menus[i2].title, menus[i2].subMenu);
      }
    }
    return menu;
  },
  createSubMenu: function(title, items) {
    let scope = this, menu, subMenu = this.createMenu();
    subMenu.items = items;
    subMenu.activeItem = null;
    function onTap(event) {
      event.preventDefault();
      event.stopPropagation();
      menu = scope.mainMenu;
      menu.changeSize(menu._width);
      menu.unslideAll();
      menu.show();
      subMenu.slideAll(true);
      subMenu.hide();
      if (this.type !== "header") {
        subMenu.setActiveItem(this);
        scope.activeMainItem.setSelectionTitle(this.textContent);
        if (this.handler) {
          this.handler();
        }
      }
    }
    subMenu.addHeader(title).addIcon(void 0, true, true).addEventListener(scope.TOUCH_ENABLED ? "touchend" : "click", onTap, false);
    for (let i2 = 0; i2 < items.length; i2++) {
      const item = subMenu.addItem(items[i2].title);
      item.style.fontWeight = 300;
      item.handler = items[i2].handler;
      item.addIcon(" ", true);
      item.addEventListener(scope.TOUCH_ENABLED ? "touchend" : "click", onTap, false);
      if (!subMenu.activeItem) {
        subMenu.setActiveItem(item);
      }
    }
    subMenu.slideAll(true);
    return subMenu;
  },
  createMenu: function() {
    const scope = this;
    const menu = document.createElement("span");
    const style = menu.style;
    style.padding = "5px 0";
    style.position = "fixed";
    style.bottom = "100%";
    style.right = "14px";
    style.backgroundColor = "#fafafa";
    style.fontFamily = "Helvetica Neue";
    style.fontSize = "14px";
    style.visibility = "hidden";
    style.opacity = 0;
    style.boxShadow = "0 0 12pt rgba(0,0,0,0.25)";
    style.borderRadius = "2px";
    style.overflow = "hidden";
    style.willChange = "width, height, opacity";
    style.pointerEvents = "auto";
    style.transition = this.DEFAULT_TRANSITION;
    menu.visible = false;
    menu.changeSize = function(width, height) {
      if (width) {
        this.style.width = width + "px";
      }
      if (height) {
        this.style.height = height + "px";
      }
    };
    menu.show = function() {
      this.style.opacity = 1;
      this.style.visibility = "visible";
      this.visible = true;
    };
    menu.hide = function() {
      this.style.opacity = 0;
      this.style.visibility = "hidden";
      this.visible = false;
    };
    menu.toggle = function() {
      if (this.visible) {
        this.hide();
      } else {
        this.show();
      }
    };
    menu.slideAll = function(right) {
      for (let i2 = 0; i2 < menu.children.length; i2++) {
        if (menu.children[i2].slide) {
          menu.children[i2].slide(right);
        }
      }
    };
    menu.unslideAll = function() {
      for (let i2 = 0; i2 < menu.children.length; i2++) {
        if (menu.children[i2].unslide) {
          menu.children[i2].unslide();
        }
      }
    };
    menu.addHeader = function(title) {
      const header = scope.createMenuItemHeader(title);
      header.type = "header";
      this.appendChild(header);
      return header;
    };
    menu.addItem = function(title) {
      const item = scope.createMenuItem(title);
      item.type = "item";
      this.appendChild(item);
      return item;
    };
    menu.setActiveItem = function(item) {
      if (this.activeItem) {
        this.activeItem.setIcon(" ");
      }
      item.setIcon(DataImage.Check);
      this.activeItem = item;
    };
    menu.addEventListener("mousemove", this.PREVENT_EVENT_HANDLER, true);
    menu.addEventListener("mouseup", this.PREVENT_EVENT_HANDLER, true);
    menu.addEventListener("mousedown", this.PREVENT_EVENT_HANDLER, true);
    return menu;
  },
  createCustomItem: function(options = {}) {
    const scope = this;
    const item = options.element || document.createElement("span");
    const { onDispose } = options;
    item.style.cursor = "pointer";
    item.style.float = "right";
    item.style.width = "44px";
    item.style.height = "100%";
    item.style.backgroundSize = "60%";
    item.style.backgroundRepeat = "no-repeat";
    item.style.backgroundPosition = "center";
    item.style.webkitUserSelect = item.style.MozUserSelect = item.style.userSelect = "none";
    item.style.position = "relative";
    item.style.pointerEvents = "auto";
    item.addEventListener(scope.TOUCH_ENABLED ? "touchstart" : "mouseenter", function() {
      item.style.filter = item.style.webkitFilter = "drop-shadow(0 0 5px rgba(255,255,255,1))";
    }, { passive: true });
    item.addEventListener(scope.TOUCH_ENABLED ? "touchend" : "mouseleave", function() {
      item.style.filter = item.style.webkitFilter = "";
    }, { passive: true });
    this.mergeStyleOptions(item, options.style);
    if (options.onTap) {
      item.addEventListener(scope.TOUCH_ENABLED ? "touchend" : "click", options.onTap, false);
    }
    item.dispose = function() {
      item.removeEventListener(scope.TOUCH_ENABLED ? "touchend" : "click", options.onTap, false);
      if (onDispose) {
        options.onDispose();
      }
    };
    return item;
  },
  mergeStyleOptions: function(element, options = {}) {
    for (let property in options) {
      if (options.hasOwnProperty(property)) {
        element.style[property] = options[property];
      }
    }
    return element;
  },
  dispose: function() {
    if (this.barElement) {
      this.container.removeChild(this.barElement);
      this.barElement.dispose();
      this.barElement = null;
    }
  }
});
function Panorama(geometry2, material) {
  Mesh.call(this, geometry2, material);
  this.type = "panorama";
  this.ImageQualityLow = 1;
  this.ImageQualityFair = 2;
  this.ImageQualityMedium = 3;
  this.ImageQualityHigh = 4;
  this.ImageQualitySuperHigh = 5;
  this.animationDuration = 1e3;
  this.defaultInfospotSize = 350;
  this.container = void 0;
  this.loaded = false;
  this.linkedSpots = [];
  this.isInfospotVisible = false;
  this.linkingImageURL = void 0;
  this.linkingImageScale = void 0;
  this.material.side = BackSide;
  this.material.opacity = 0;
  this.scale.x *= -1;
  this.renderOrder = -1;
  this.active = false;
  this.infospotAnimation = new Tween.Tween(this).to({}, this.animationDuration / 2);
  this.addEventListener("load", this.fadeIn.bind(this));
  this.addEventListener("panolens-container", this.setContainer.bind(this));
  this.addEventListener("click", this.onClick.bind(this));
  this.setupTransitions();
}
Panorama.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: Panorama,
  add: function(object) {
    let invertedObject;
    if (arguments.length > 1) {
      for (var i2 = 0; i2 < arguments.length; i2++) {
        this.add(arguments[i2]);
      }
      return this;
    }
    if (object instanceof Infospot) {
      invertedObject = object;
      if (object.dispatchEvent) {
        const { container } = this;
        if (container) {
          object.dispatchEvent({ type: "panolens-container", container });
        }
        object.dispatchEvent({ type: "panolens-infospot-focus", method: function(vector, duration, easing) {
          this.dispatchEvent({ type: "panolens-viewer-handler", method: "tweenControlCenter", data: [vector, duration, easing] });
        }.bind(this) });
      }
    } else {
      invertedObject = new Object3D();
      invertedObject.scale.x = -1;
      invertedObject.scalePlaceHolder = true;
      invertedObject.add(object);
    }
    Object3D.prototype.add.call(this, invertedObject);
  },
  load: function() {
    this.onLoad();
  },
  onClick: function(event) {
    if (event.intersects && event.intersects.length === 0) {
      this.traverse(function(object) {
        object.dispatchEvent({ type: "dismiss" });
      });
    }
  },
  setContainer: function(data) {
    let container;
    if (data instanceof HTMLElement) {
      container = data;
    } else if (data && data.container) {
      container = data.container;
    }
    if (container) {
      this.children.forEach(function(child) {
        if (child instanceof Infospot && child.dispatchEvent) {
          child.dispatchEvent({ type: "panolens-container", container });
        }
      });
      this.container = container;
    }
  },
  onLoad: function() {
    this.loaded = true;
    this.dispatchEvent({ type: "load" });
  },
  onProgress: function(progress) {
    this.dispatchEvent({ type: "progress", progress });
  },
  onError: function() {
    this.dispatchEvent({ type: "error" });
  },
  getZoomLevel: function() {
    let zoomLevel;
    if (window.innerWidth <= 800) {
      zoomLevel = this.ImageQualityFair;
    } else if (window.innerWidth > 800 && window.innerWidth <= 1280) {
      zoomLevel = this.ImageQualityMedium;
    } else if (window.innerWidth > 1280 && window.innerWidth <= 1920) {
      zoomLevel = this.ImageQualityHigh;
    } else if (window.innerWidth > 1920) {
      zoomLevel = this.ImageQualitySuperHigh;
    } else {
      zoomLevel = this.ImageQualityLow;
    }
    return zoomLevel;
  },
  updateTexture: function(texture) {
    this.material.map = texture;
    this.material.needsUpdate = true;
  },
  toggleInfospotVisibility: function(isVisible, delay) {
    delay = delay !== void 0 ? delay : 0;
    const visible = isVisible !== void 0 ? isVisible : this.isInfospotVisible ? false : true;
    this.traverse(function(object) {
      if (object instanceof Infospot) {
        if (visible) {
          object.show(delay);
        } else {
          object.hide(delay);
        }
      }
    });
    this.isInfospotVisible = visible;
    this.infospotAnimation.onComplete(function() {
      this.dispatchEvent({ type: "infospot-animation-complete", visible });
    }.bind(this)).delay(delay).start();
  },
  setLinkingImage: function(url, scale2) {
    this.linkingImageURL = url;
    this.linkingImageScale = scale2;
  },
  link: function(pano, position, imageScale, imageSrc) {
    let scale2, img;
    this.visible = true;
    if (!position) {
      console.warn("Please specify infospot position for linking");
      return;
    }
    if (imageScale !== void 0) {
      scale2 = imageScale;
    } else if (pano.linkingImageScale !== void 0) {
      scale2 = pano.linkingImageScale;
    } else {
      scale2 = 300;
    }
    if (imageSrc) {
      img = imageSrc;
    } else if (pano.linkingImageURL) {
      img = pano.linkingImageURL;
    } else {
      img = DataImage.Arrow;
    }
    const spot = new Infospot(scale2, img);
    spot.position.copy(position);
    spot.toPanorama = pano;
    spot.addEventListener("click", function() {
      this.dispatchEvent({ type: "panolens-viewer-handler", method: "setPanorama", data: pano });
    }.bind(this));
    this.linkedSpots.push(spot);
    this.add(spot);
    this.visible = false;
  },
  reset: function() {
    this.children.length = 0;
  },
  setupTransitions: function() {
    this.fadeInAnimation = new Tween.Tween(this.material).easing(Tween.Easing.Quartic.Out).onStart(function() {
      this.visible = true;
      this.dispatchEvent({ type: "enter-fade-start" });
    }.bind(this));
    this.fadeOutAnimation = new Tween.Tween(this.material).easing(Tween.Easing.Quartic.Out).onComplete(function() {
      this.visible = false;
      this.dispatchEvent({ type: "leave-complete" });
    }.bind(this));
    this.enterTransition = new Tween.Tween(this).easing(Tween.Easing.Quartic.Out).onComplete(function() {
      this.dispatchEvent({ type: "enter-complete" });
    }.bind(this)).start();
    this.leaveTransition = new Tween.Tween(this).easing(Tween.Easing.Quartic.Out);
  },
  onFadeAnimationUpdate: function() {
    const alpha = this.material.opacity;
    const { uniforms } = this.material;
    if (uniforms && uniforms.opacity) {
      uniforms.opacity.value = alpha;
    }
  },
  fadeIn: function(duration) {
    duration = duration >= 0 ? duration : this.animationDuration;
    this.fadeOutAnimation.stop();
    this.fadeInAnimation.to({ opacity: 1 }, duration).onUpdate(this.onFadeAnimationUpdate.bind(this)).onComplete(function() {
      this.toggleInfospotVisibility(true, duration / 2);
      this.dispatchEvent({ type: "enter-fade-complete" });
    }.bind(this)).start();
  },
  fadeOut: function(duration) {
    duration = duration >= 0 ? duration : this.animationDuration;
    this.fadeInAnimation.stop();
    this.fadeOutAnimation.to({ opacity: 0 }, duration).onUpdate(this.onFadeAnimationUpdate.bind(this)).start();
  },
  onEnter: function() {
    const duration = this.animationDuration;
    this.leaveTransition.stop();
    this.enterTransition.to({}, duration).onStart(function() {
      this.dispatchEvent({ type: "enter-start" });
      if (this.loaded) {
        this.fadeIn(duration);
      } else {
        this.load();
      }
    }.bind(this)).start();
    this.dispatchEvent({ type: "enter" });
    this.children.forEach((child) => {
      child.dispatchEvent({ type: "panorama-enter" });
    });
    this.active = true;
  },
  onLeave: function() {
    const duration = this.animationDuration;
    this.enterTransition.stop();
    this.leaveTransition.to({}, duration).onStart(function() {
      this.dispatchEvent({ type: "leave-start" });
      this.fadeOut(duration);
      this.toggleInfospotVisibility(false);
    }.bind(this)).start();
    this.dispatchEvent({ type: "leave" });
    this.children.forEach((child) => {
      child.dispatchEvent({ type: "panorama-leave" });
    });
    this.active = false;
  },
  dispose: function() {
    this.infospotAnimation.stop();
    this.fadeInAnimation.stop();
    this.fadeOutAnimation.stop();
    this.enterTransition.stop();
    this.leaveTransition.stop();
    this.dispatchEvent({ type: "panolens-viewer-handler", method: "onPanoramaDispose", data: this });
    function recursiveDispose(object) {
      const { geometry: geometry2, material } = object;
      for (var i2 = object.children.length - 1; i2 >= 0; i2--) {
        recursiveDispose(object.children[i2]);
        object.remove(object.children[i2]);
      }
      if (object instanceof Infospot) {
        object.dispose();
      }
      if (geometry2) {
        geometry2.dispose();
        object.geometry = null;
      }
      if (material) {
        material.dispose();
        object.material = null;
      }
    }
    recursiveDispose(this);
    if (this.parent) {
      this.parent.remove(this);
    }
  }
});
function ImagePanorama(image, _geometry, _material) {
  const radius = 5e3;
  const geometry2 = _geometry || new SphereBufferGeometry(radius, 60, 40);
  const material = _material || new MeshBasicMaterial({ opacity: 0, transparent: true });
  Panorama.call(this, geometry2, material);
  this.src = image;
  this.radius = radius;
}
ImagePanorama.prototype = Object.assign(Object.create(Panorama.prototype), {
  constructor: ImagePanorama,
  load: function(src) {
    src = src || this.src;
    if (!src) {
      console.warn("Image source undefined");
      return;
    } else if (typeof src === "string") {
      TextureLoader.load(src, this.onLoad.bind(this), this.onProgress.bind(this), this.onError.bind(this));
    } else if (src instanceof HTMLImageElement) {
      this.onLoad(new Texture(src));
    }
  },
  onLoad: function(texture) {
    texture.minFilter = texture.magFilter = LinearFilter;
    texture.needsUpdate = true;
    this.updateTexture(texture);
    window.requestAnimationFrame(Panorama.prototype.onLoad.bind(this));
  },
  reset: function() {
    Panorama.prototype.reset.call(this);
  },
  dispose: function() {
    const { material: { map } } = this;
    Cache.remove(this.src);
    if (map) {
      map.dispose();
    }
    Panorama.prototype.dispose.call(this);
  }
});
function EmptyPanorama() {
  const geometry2 = new BufferGeometry();
  const material = new MeshBasicMaterial({ color: 0, opacity: 0, transparent: true });
  geometry2.addAttribute("position", new BufferAttribute(new Float32Array(), 1));
  Panorama.call(this, geometry2, material);
}
EmptyPanorama.prototype = Object.assign(Object.create(Panorama.prototype), {
  constructor: EmptyPanorama
});
function CubePanorama(images2 = []) {
  const edgeLength = 1e4;
  const shader = Object.assign({}, ShaderLib["cube"]);
  const geometry2 = new BoxBufferGeometry(edgeLength, edgeLength, edgeLength);
  const material = new ShaderMaterial({
    fragmentShader: shader.fragmentShader,
    vertexShader: shader.vertexShader,
    uniforms: shader.uniforms,
    side: BackSide,
    transparent: true
  });
  Panorama.call(this, geometry2, material);
  this.images = images2;
  this.edgeLength = edgeLength;
  this.material.uniforms.opacity.value = 0;
}
CubePanorama.prototype = Object.assign(Object.create(Panorama.prototype), {
  constructor: CubePanorama,
  load: function() {
    CubeTextureLoader.load(this.images, this.onLoad.bind(this), this.onProgress.bind(this), this.onError.bind(this));
  },
  onLoad: function(texture) {
    this.material.uniforms["tCube"].value = texture;
    Panorama.prototype.onLoad.call(this);
  },
  dispose: function() {
    const { value } = this.material.uniforms.tCube;
    this.images.forEach((image) => {
      Cache.remove(image);
    });
    if (value instanceof CubeTexture) {
      value.dispose();
    }
    Panorama.prototype.dispose.call(this);
  }
});
function BasicPanorama() {
  const images2 = [];
  for (let i2 = 0; i2 < 6; i2++) {
    images2.push(DataImage.WhiteTile);
  }
  CubePanorama.call(this, images2);
}
BasicPanorama.prototype = Object.assign(Object.create(CubePanorama.prototype), {
  constructor: BasicPanorama
});
function VideoPanorama(src, options = {}) {
  const radius = 5e3;
  const geometry2 = new SphereBufferGeometry(radius, 60, 40);
  const material = new MeshBasicMaterial({ opacity: 0, transparent: true });
  Panorama.call(this, geometry2, material);
  this.src = src;
  this.options = {
    videoElement: document.createElement("video"),
    loop: true,
    muted: true,
    autoplay: false,
    playsinline: true,
    crossOrigin: "anonymous"
  };
  Object.assign(this.options, options);
  this.videoElement = this.options.videoElement;
  this.videoProgress = 0;
  this.radius = radius;
  this.addEventListener("leave", this.pauseVideo.bind(this));
  this.addEventListener("enter-fade-start", this.resumeVideoProgress.bind(this));
  this.addEventListener("video-toggle", this.toggleVideo.bind(this));
  this.addEventListener("video-time", this.setVideoCurrentTime.bind(this));
}
VideoPanorama.prototype = Object.assign(Object.create(Panorama.prototype), {
  constructor: VideoPanorama,
  isMobile: function() {
    let check = false;
    (function(a2) {
      if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a2) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a2.substr(0, 4)))
        check = true;
    })(window.navigator.userAgent || window.navigator.vendor || window.opera);
    return check;
  },
  load: function() {
    const { muted, loop: loop2, autoplay, playsinline, crossOrigin } = this.options;
    const video = this.videoElement;
    const material = this.material;
    const onProgress = this.onProgress.bind(this);
    const onLoad = this.onLoad.bind(this);
    video.loop = loop2;
    video.autoplay = autoplay;
    video.playsinline = playsinline;
    video.crossOrigin = crossOrigin;
    video.muted = muted;
    if (playsinline) {
      video.setAttribute("playsinline", "");
      video.setAttribute("webkit-playsinline", "");
    }
    const onloadeddata = function() {
      this.setVideoTexture(video);
      if (autoplay) {
        this.dispatchEvent({ type: "panolens-viewer-handler", method: "updateVideoPlayButton", data: false });
      }
      if (this.isMobile()) {
        video.pause();
        if (autoplay && muted) {
          this.dispatchEvent({ type: "panolens-viewer-handler", method: "updateVideoPlayButton", data: false });
        } else {
          this.dispatchEvent({ type: "panolens-viewer-handler", method: "updateVideoPlayButton", data: true });
        }
      }
      const loaded = () => {
        material.map.needsUpdate = true;
        onProgress({ loaded: 1, total: 1 });
        onLoad();
      };
      window.requestAnimationFrame(loaded);
    };
    if (video.readyState > 2) {
      onloadeddata.call(this);
    } else {
      if (video.querySelectorAll("source").length === 0) {
        const source = document.createElement("source");
        source.src = this.src;
        video.appendChild(source);
      }
      video.load();
    }
    video.addEventListener("loadeddata", onloadeddata.bind(this));
    video.addEventListener("timeupdate", function() {
      this.videoProgress = video.duration >= 0 ? video.currentTime / video.duration : 0;
      this.dispatchEvent({ type: "panolens-viewer-handler", method: "onVideoUpdate", data: this.videoProgress });
    }.bind(this));
    video.addEventListener("ended", function() {
      if (!loop2) {
        this.resetVideo();
        this.dispatchEvent({ type: "panolens-viewer-handler", method: "updateVideoPlayButton", data: true });
      }
    }.bind(this), false);
  },
  setVideoTexture: function(video) {
    if (!video)
      return;
    const videoTexture = new VideoTexture(video);
    videoTexture.minFilter = LinearFilter;
    videoTexture.magFilter = LinearFilter;
    videoTexture.format = RGBFormat;
    this.updateTexture(videoTexture);
  },
  reset: function() {
    this.videoElement = void 0;
    Panorama.prototype.reset.call(this);
  },
  isVideoPaused: function() {
    return this.videoElement.paused;
  },
  toggleVideo: function() {
    const video = this.videoElement;
    if (!video) {
      return;
    }
    video[video.paused ? "play" : "pause"]();
  },
  setVideoCurrentTime: function({ percentage }) {
    const video = this.videoElement;
    if (video && !Number.isNaN(percentage) && percentage !== 1) {
      video.currentTime = video.duration * percentage;
      this.dispatchEvent({ type: "panolens-viewer-handler", method: "onVideoUpdate", data: percentage });
    }
  },
  playVideo: function() {
    const video = this.videoElement;
    const playVideo = this.playVideo.bind(this);
    const dispatchEvent2 = this.dispatchEvent.bind(this);
    const onSuccess = () => {
      dispatchEvent2({ type: "play" });
    };
    const onError = (error) => {
      window.requestAnimationFrame(playVideo);
      dispatchEvent2({ type: "play-error", error });
    };
    if (video && video.paused) {
      video.play().then(onSuccess).catch(onError);
    }
  },
  pauseVideo: function() {
    const video = this.videoElement;
    if (video && !video.paused) {
      video.pause();
    }
    this.dispatchEvent({ type: "pause" });
  },
  resumeVideoProgress: function() {
    const video = this.videoElement;
    if (video.readyState >= 4 && video.autoplay && !this.isMobile()) {
      this.playVideo();
      this.dispatchEvent({ type: "panolens-viewer-handler", method: "updateVideoPlayButton", data: false });
    } else {
      this.pauseVideo();
      this.dispatchEvent({ type: "panolens-viewer-handler", method: "updateVideoPlayButton", data: true });
    }
    this.setVideoCurrentTime({ percentage: this.videoProgress });
  },
  resetVideo: function() {
    const video = this.videoElement;
    if (video) {
      this.setVideoCurrentTime({ percentage: 0 });
    }
  },
  isVideoMuted: function() {
    return this.videoElement.muted;
  },
  muteVideo: function() {
    const video = this.videoElement;
    if (video && !video.muted) {
      video.muted = true;
    }
    this.dispatchEvent({ type: "volumechange" });
  },
  unmuteVideo: function() {
    const video = this.videoElement;
    if (video && this.isVideoMuted()) {
      video.muted = false;
    }
    this.dispatchEvent({ type: "volumechange" });
  },
  getVideoElement: function() {
    return this.videoElement;
  },
  dispose: function() {
    const { material: { map } } = this;
    this.pauseVideo();
    this.removeEventListener("leave", this.pauseVideo.bind(this));
    this.removeEventListener("enter-fade-start", this.resumeVideoProgress.bind(this));
    this.removeEventListener("video-toggle", this.toggleVideo.bind(this));
    this.removeEventListener("video-time", this.setVideoCurrentTime.bind(this));
    if (map) {
      map.dispose();
    }
    Panorama.prototype.dispose.call(this);
  }
});
function GoogleStreetviewLoader(parameters = {}) {
  this._parameters = parameters;
  this._zoom = null;
  this._panoId = null;
  this._panoClient = new google.maps.StreetViewService();
  this._count = 0;
  this._total = 0;
  this._canvas = [];
  this._ctx = [];
  this._wc = 0;
  this._hc = 0;
  this.result = null;
  this.rotation = 0;
  this.copyright = "";
  this.onSizeChange = null;
  this.onPanoramaLoad = null;
  this.levelsW = [1, 2, 4, 7, 13, 26];
  this.levelsH = [1, 1, 2, 4, 7, 13];
  this.widths = [416, 832, 1664, 3328, 6656, 13312];
  this.heights = [416, 416, 832, 1664, 3328, 6656];
  this.maxW = 6656;
  this.maxH = 6656;
  let gl;
  try {
    const canvas = document.createElement("canvas");
    gl = canvas.getContext("experimental-webgl");
    if (!gl) {
      gl = canvas.getContext("webgl");
    }
  } catch (error) {
  }
  this.maxW = Math.max(gl.getParameter(gl.MAX_TEXTURE_SIZE), this.maxW);
  this.maxH = Math.max(gl.getParameter(gl.MAX_TEXTURE_SIZE), this.maxH);
}
Object.assign(GoogleStreetviewLoader.prototype, {
  constructor: GoogleStreetviewLoader,
  setProgress: function(loaded, total) {
    if (this.onProgress) {
      this.onProgress({ loaded, total });
    }
  },
  adaptTextureToZoom: function() {
    const w2 = this.widths[this._zoom];
    const h2 = this.heights[this._zoom];
    const maxW = this.maxW;
    const maxH = this.maxH;
    this._wc = Math.ceil(w2 / maxW);
    this._hc = Math.ceil(h2 / maxH);
    for (let y = 0; y < this._hc; y++) {
      for (let x2 = 0; x2 < this._wc; x2++) {
        const c2 = document.createElement("canvas");
        if (x2 < this._wc - 1)
          c2.width = maxW;
        else
          c2.width = w2 - maxW * x2;
        if (y < this._hc - 1)
          c2.height = maxH;
        else
          c2.height = h2 - maxH * y;
        this._canvas.push(c2);
        this._ctx.push(c2.getContext("2d"));
      }
    }
  },
  composeFromTile: function(x2, y, texture) {
    const maxW = this.maxW;
    const maxH = this.maxH;
    x2 *= 512;
    y *= 512;
    const px2 = Math.floor(x2 / maxW);
    const py2 = Math.floor(y / maxH);
    x2 -= px2 * maxW;
    y -= py2 * maxH;
    this._ctx[py2 * this._wc + px2].drawImage(texture, 0, 0, texture.width, texture.height, x2, y, 512, 512);
    this.progress();
  },
  progress: function() {
    this._count++;
    this.setProgress(this._count, this._total);
    if (this._count === this._total) {
      this.canvas = this._canvas;
      this.panoId = this._panoId;
      this.zoom = this._zoom;
      if (this.onPanoramaLoad) {
        this.onPanoramaLoad(this._canvas[0]);
      }
    }
  },
  composePanorama: function() {
    this.setProgress(0, 1);
    const w2 = this.levelsW[this._zoom];
    const h2 = this.levelsH[this._zoom];
    const self2 = this;
    this._count = 0;
    this._total = w2 * h2;
    const { useWebGL } = this._parameters;
    for (let y = 0; y < h2; y++) {
      for (let x2 = 0; x2 < w2; x2++) {
        const url = "https://geo0.ggpht.com/cbk?cb_client=maps_sv.tactile&authuser=0&hl=en&output=tile&zoom=" + this._zoom + "&x=" + x2 + "&y=" + y + "&panoid=" + this._panoId + "&nbt&fover=2";
        (function(x3, y2) {
          if (useWebGL) {
            const texture = TextureLoader.load(url, null, function() {
              self2.composeFromTile(x3, y2, texture);
            });
          } else {
            const img = new Image();
            img.addEventListener("load", function() {
              self2.composeFromTile(x3, y2, this);
            });
            img.crossOrigin = "";
            img.src = url;
          }
        })(x2, y);
      }
    }
  },
  load: function(panoid) {
    this.loadPano(panoid);
  },
  loadPano: function(id) {
    const self2 = this;
    this._panoClient.getPanoramaById(id, function(result, status) {
      if (status === google.maps.StreetViewStatus.OK) {
        self2.result = result;
        self2.copyright = result.copyright;
        self2._panoId = result.location.pano;
        self2.composePanorama();
      }
    });
  },
  setZoom: function(z2) {
    this._zoom = z2;
    this.adaptTextureToZoom();
  }
});
function GoogleStreetviewPanorama(panoId, apiKey) {
  ImagePanorama.call(this);
  this.panoId = panoId;
  this.gsvLoader = null;
  this.loadRequested = false;
  this.setupGoogleMapAPI(apiKey);
}
GoogleStreetviewPanorama.prototype = Object.assign(Object.create(ImagePanorama.prototype), {
  constructor: GoogleStreetviewPanorama,
  load: function(panoId) {
    this.loadRequested = true;
    panoId = panoId || this.panoId || {};
    if (panoId && this.gsvLoader) {
      this.loadGSVLoader(panoId);
    }
  },
  setupGoogleMapAPI: function(apiKey) {
    const script = document.createElement("script");
    script.src = "https://maps.googleapis.com/maps/api/js?";
    script.src += apiKey ? "key=" + apiKey : "";
    script.onreadystatechange = this.setGSVLoader.bind(this);
    script.onload = this.setGSVLoader.bind(this);
    document.querySelector("head").appendChild(script);
  },
  setGSVLoader: function() {
    this.gsvLoader = new GoogleStreetviewLoader();
    if (this.loadRequested) {
      this.load();
    }
  },
  getGSVLoader: function() {
    return this.gsvLoader;
  },
  loadGSVLoader: function(panoId) {
    this.loadRequested = false;
    this.gsvLoader.onProgress = this.onProgress.bind(this);
    this.gsvLoader.onPanoramaLoad = this.onLoad.bind(this);
    this.gsvLoader.setZoom(this.getZoomLevel());
    this.gsvLoader.load(panoId);
    this.gsvLoader.loaded = true;
  },
  onLoad: function(canvas) {
    ImagePanorama.prototype.onLoad.call(this, new Texture(canvas));
  },
  reset: function() {
    this.gsvLoader = void 0;
    ImagePanorama.prototype.reset.call(this);
  }
});
const StereographicShader = {
  uniforms: {
    "tDiffuse": { value: new Texture() },
    "resolution": { value: 1 },
    "transform": { value: new Matrix4() },
    "zoom": { value: 1 },
    "opacity": { value: 1 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "vUv = uv;",
    "gl_Position = vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform float resolution;",
    "uniform mat4 transform;",
    "uniform float zoom;",
    "uniform float opacity;",
    "varying vec2 vUv;",
    "const float PI = 3.141592653589793;",
    "void main(){",
    "vec2 position = -1.0 +  2.0 * vUv;",
    "position *= vec2( zoom * resolution, zoom * 0.5 );",
    "float x2y2 = position.x * position.x + position.y * position.y;",
    "vec3 sphere_pnt = vec3( 2. * position, x2y2 - 1. ) / ( x2y2 + 1. );",
    "sphere_pnt = vec3( transform * vec4( sphere_pnt, 1.0 ) );",
    "vec2 sampleUV = vec2(",
    "(atan(sphere_pnt.y, sphere_pnt.x) / PI + 1.0) * 0.5,",
    "(asin(sphere_pnt.z) / PI + 0.5)",
    ");",
    "gl_FragColor = texture2D( tDiffuse, sampleUV );",
    "gl_FragColor.a *= opacity;",
    "}"
  ].join("\n")
};
function LittlePlanet(type = "image", source, size = 1e4, ratio = 0.5) {
  if (type === "image") {
    ImagePanorama.call(this, source, this.createGeometry(size, ratio), this.createMaterial(size));
  }
  this.size = size;
  this.ratio = ratio;
  this.EPS = 1e-6;
  this.frameId = null;
  this.dragging = false;
  this.userMouse = new Vector2();
  this.quatA = new Quaternion();
  this.quatB = new Quaternion();
  this.quatCur = new Quaternion();
  this.quatSlerp = new Quaternion();
  this.vectorX = new Vector3(1, 0, 0);
  this.vectorY = new Vector3(0, 1, 0);
  this.addEventListener("window-resize", this.onWindowResize);
}
LittlePlanet.prototype = Object.assign(Object.create(ImagePanorama.prototype), {
  constructor: LittlePlanet,
  add: function(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.add(arguments[i2]);
      }
      return this;
    }
    if (object instanceof Infospot) {
      object.material.depthTest = false;
    }
    ImagePanorama.prototype.add.call(this, object);
  },
  createGeometry: function(size, ratio) {
    return new PlaneBufferGeometry(size, size * ratio);
  },
  createMaterial: function(size) {
    const shader = Object.assign({}, StereographicShader), uniforms = shader.uniforms;
    uniforms.zoom.value = size;
    uniforms.opacity.value = 0;
    return new ShaderMaterial({
      uniforms,
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      transparent: true
    });
  },
  registerMouseEvents: function() {
    this.container.addEventListener("mousedown", this.onMouseDown.bind(this), { passive: true });
    this.container.addEventListener("mousemove", this.onMouseMove.bind(this), { passive: true });
    this.container.addEventListener("mouseup", this.onMouseUp.bind(this), { passive: true });
    this.container.addEventListener("touchstart", this.onMouseDown.bind(this), { passive: true });
    this.container.addEventListener("touchmove", this.onMouseMove.bind(this), { passive: true });
    this.container.addEventListener("touchend", this.onMouseUp.bind(this), { passive: true });
    this.container.addEventListener("mousewheel", this.onMouseWheel.bind(this), { passive: false });
    this.container.addEventListener("DOMMouseScroll", this.onMouseWheel.bind(this), { passive: false });
    this.container.addEventListener("contextmenu", this.onContextMenu.bind(this), { passive: true });
  },
  unregisterMouseEvents: function() {
    this.container.removeEventListener("mousedown", this.onMouseDown.bind(this), false);
    this.container.removeEventListener("mousemove", this.onMouseMove.bind(this), false);
    this.container.removeEventListener("mouseup", this.onMouseUp.bind(this), false);
    this.container.removeEventListener("touchstart", this.onMouseDown.bind(this), false);
    this.container.removeEventListener("touchmove", this.onMouseMove.bind(this), false);
    this.container.removeEventListener("touchend", this.onMouseUp.bind(this), false);
    this.container.removeEventListener("mousewheel", this.onMouseWheel.bind(this), false);
    this.container.removeEventListener("DOMMouseScroll", this.onMouseWheel.bind(this), false);
    this.container.removeEventListener("contextmenu", this.onContextMenu.bind(this), false);
  },
  onMouseDown: function(event) {
    const inputCount = event.touches && event.touches.length || 1;
    switch (inputCount) {
      case 1:
        const x2 = event.clientX >= 0 ? event.clientX : event.touches[0].clientX;
        const y = event.clientY >= 0 ? event.clientY : event.touches[0].clientY;
        this.dragging = true;
        this.userMouse.set(x2, y);
        break;
      case 2:
        const dx = event.touches[0].pageX - event.touches[1].pageX;
        const dy = event.touches[0].pageY - event.touches[1].pageY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        this.userMouse.pinchDistance = distance;
        break;
    }
    this.onUpdateCallback();
  },
  onMouseMove: function(event) {
    const inputCount = event.touches && event.touches.length || 1;
    switch (inputCount) {
      case 1:
        const x2 = event.clientX >= 0 ? event.clientX : event.touches[0].clientX;
        const y = event.clientY >= 0 ? event.clientY : event.touches[0].clientY;
        const angleX = _Math.degToRad(x2 - this.userMouse.x) * 0.4;
        const angleY = _Math.degToRad(y - this.userMouse.y) * 0.4;
        if (this.dragging) {
          this.quatA.setFromAxisAngle(this.vectorY, angleX);
          this.quatB.setFromAxisAngle(this.vectorX, angleY);
          this.quatCur.multiply(this.quatA).multiply(this.quatB);
          this.userMouse.set(x2, y);
        }
        break;
      case 2:
        const dx = event.touches[0].pageX - event.touches[1].pageX;
        const dy = event.touches[0].pageY - event.touches[1].pageY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        this.addZoomDelta(this.userMouse.pinchDistance - distance);
        break;
    }
  },
  onMouseUp: function() {
    this.dragging = false;
  },
  onMouseWheel: function(event) {
    event.preventDefault();
    event.stopPropagation();
    let delta = 0;
    if (event.wheelDelta !== void 0) {
      delta = event.wheelDelta;
    } else if (event.detail !== void 0) {
      delta = -event.detail;
    }
    this.addZoomDelta(delta);
    this.onUpdateCallback();
  },
  addZoomDelta: function(delta) {
    const uniforms = this.material.uniforms;
    const lowerBound = this.size * 0.1;
    const upperBound = this.size * 10;
    uniforms.zoom.value += delta;
    if (uniforms.zoom.value <= lowerBound) {
      uniforms.zoom.value = lowerBound;
    } else if (uniforms.zoom.value >= upperBound) {
      uniforms.zoom.value = upperBound;
    }
  },
  onUpdateCallback: function() {
    this.frameId = window.requestAnimationFrame(this.onUpdateCallback.bind(this));
    this.quatSlerp.slerp(this.quatCur, 0.1);
    if (this.material) {
      this.material.uniforms.transform.value.makeRotationFromQuaternion(this.quatSlerp);
    }
    if (!this.dragging && 1 - this.quatSlerp.clone().dot(this.quatCur) < this.EPS) {
      window.cancelAnimationFrame(this.frameId);
    }
  },
  reset: function() {
    this.quatCur.set(0, 0, 0, 1);
    this.quatSlerp.set(0, 0, 0, 1);
    this.onUpdateCallback();
  },
  onLoad: function(texture) {
    this.material.uniforms.resolution.value = this.container.clientWidth / this.container.clientHeight;
    this.registerMouseEvents();
    this.onUpdateCallback();
    this.dispatchEvent({ type: "panolens-viewer-handler", method: "disableControl" });
    ImagePanorama.prototype.onLoad.call(this, texture);
  },
  onLeave: function() {
    this.unregisterMouseEvents();
    this.dispatchEvent({ type: "panolens-viewer-handler", method: "enableControl", data: CONTROLS.ORBIT });
    window.cancelAnimationFrame(this.frameId);
    ImagePanorama.prototype.onLeave.call(this);
  },
  onWindowResize: function() {
    this.material.uniforms.resolution.value = this.container.clientWidth / this.container.clientHeight;
  },
  onContextMenu: function() {
    this.dragging = false;
  },
  dispose: function() {
    this.unregisterMouseEvents();
    ImagePanorama.prototype.dispose.call(this);
  }
});
function ImageLittlePlanet(source, size, ratio) {
  LittlePlanet.call(this, "image", source, size, ratio);
}
ImageLittlePlanet.prototype = Object.assign(Object.create(LittlePlanet.prototype), {
  constructor: ImageLittlePlanet,
  onLoad: function(texture) {
    this.updateTexture(texture);
    LittlePlanet.prototype.onLoad.call(this, texture);
  },
  updateTexture: function(texture) {
    texture.minFilter = texture.magFilter = LinearFilter;
    this.material.uniforms["tDiffuse"].value = texture;
  },
  dispose: function() {
    const tDiffuse = this.material.uniforms["tDiffuse"];
    if (tDiffuse && tDiffuse.value) {
      tDiffuse.value.dispose();
    }
    LittlePlanet.prototype.dispose.call(this);
  }
});
function CameraPanorama(constraints) {
  const radius = 5e3;
  const geometry2 = new SphereBufferGeometry(radius, 60, 40);
  const material = new MeshBasicMaterial({ visible: false });
  Panorama.call(this, geometry2, material);
  this.media = new Media(constraints);
  this.radius = radius;
  this.addEventListener("enter", this.start.bind(this));
  this.addEventListener("leave", this.stop.bind(this));
  this.addEventListener("panolens-container", this.onPanolensContainer.bind(this));
  this.addEventListener("panolens-scene", this.onPanolensScene.bind(this));
}
CameraPanorama.prototype = Object.assign(Object.create(Panorama.prototype), {
  constructor: CameraPanorama,
  onPanolensContainer: function({ container }) {
    this.media.setContainer(container);
  },
  onPanolensScene: function({ scene }) {
    this.media.setScene(scene);
  },
  start: function() {
    return this.media.start();
  },
  stop: function() {
    this.media.stop();
  }
});
function OrbitControls(object, domElement) {
  this.object = object;
  this.domElement = domElement !== void 0 ? domElement : document;
  this.frameId = null;
  this.enabled = true;
  this.target = new Vector3();
  this.center = this.target;
  this.noZoom = false;
  this.zoomSpeed = 1;
  this.minDistance = 0;
  this.maxDistance = Infinity;
  this.minZoom = 0;
  this.maxZoom = Infinity;
  this.noRotate = false;
  this.rotateSpeed = -0.15;
  this.noPan = true;
  this.keyPanSpeed = 7;
  this.autoRotate = false;
  this.autoRotateSpeed = 2;
  this.minPolarAngle = 0;
  this.maxPolarAngle = Math.PI;
  this.momentumDampingFactor = 0.9;
  this.momentumScalingFactor = -5e-3;
  this.momentumKeydownFactor = 20;
  this.minFov = 30;
  this.maxFov = 120;
  this.minAzimuthAngle = -Infinity;
  this.maxAzimuthAngle = Infinity;
  this.noKeys = false;
  this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };
  this.mouseButtons = { ORBIT: MOUSE.LEFT, ZOOM: MOUSE.MIDDLE, PAN: MOUSE.RIGHT };
  var scope = this;
  var EPS = 1e-7;
  var MEPS = 1e-4;
  var rotateStart = new Vector2();
  var rotateEnd = new Vector2();
  var rotateDelta = new Vector2();
  var panStart = new Vector2();
  var panEnd = new Vector2();
  var panDelta = new Vector2();
  var panOffset = new Vector3();
  var offset2 = new Vector3();
  var dollyStart = new Vector2();
  var dollyEnd = new Vector2();
  var dollyDelta = new Vector2();
  var theta = 0;
  var phi = 0;
  var phiDelta = 0;
  var thetaDelta = 0;
  var scale2 = 1;
  var pan = new Vector3();
  var lastPosition = new Vector3();
  var lastQuaternion = new Quaternion();
  var momentumLeft = 0, momentumUp = 0;
  var eventPrevious;
  var momentumOn = false;
  var keyUp, keyBottom, keyLeft, keyRight;
  var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };
  var state = STATE.NONE;
  this.target0 = this.target.clone();
  this.position0 = this.object.position.clone();
  this.zoom0 = this.object.zoom;
  var quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
  var quatInverse = quat.clone().inverse();
  var changeEvent = { type: "change" };
  var startEvent = { type: "start" };
  var endEvent = { type: "end" };
  this.setLastQuaternion = function(quaternion) {
    lastQuaternion.copy(quaternion);
    scope.object.quaternion.copy(quaternion);
  };
  this.getLastPosition = function() {
    return lastPosition;
  };
  this.rotateLeft = function(angle) {
    if (angle === void 0) {
      angle = getAutoRotationAngle();
    }
    thetaDelta -= angle;
  };
  this.rotateUp = function(angle) {
    if (angle === void 0) {
      angle = getAutoRotationAngle();
    }
    phiDelta -= angle;
  };
  this.panLeft = function(distance) {
    var te = this.object.matrix.elements;
    panOffset.set(te[0], te[1], te[2]);
    panOffset.multiplyScalar(-distance);
    pan.add(panOffset);
  };
  this.panUp = function(distance) {
    var te = this.object.matrix.elements;
    panOffset.set(te[4], te[5], te[6]);
    panOffset.multiplyScalar(distance);
    pan.add(panOffset);
  };
  this.pan = function(deltaX, deltaY) {
    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
    if (scope.object instanceof PerspectiveCamera) {
      var position = scope.object.position;
      var offset3 = position.clone().sub(scope.target);
      var targetDistance = offset3.length();
      targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
      scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);
      scope.panUp(2 * deltaY * targetDistance / element.clientHeight);
    } else if (scope.object instanceof OrthographicCamera) {
      scope.panLeft(deltaX * (scope.object.right - scope.object.left) / element.clientWidth);
      scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight);
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
    }
  };
  this.momentum = function() {
    if (!momentumOn)
      return;
    if (Math.abs(momentumLeft) < MEPS && Math.abs(momentumUp) < MEPS) {
      momentumOn = false;
      return;
    }
    momentumUp *= this.momentumDampingFactor;
    momentumLeft *= this.momentumDampingFactor;
    thetaDelta -= this.momentumScalingFactor * momentumLeft;
    phiDelta -= this.momentumScalingFactor * momentumUp;
  };
  this.dollyIn = function(dollyScale) {
    if (dollyScale === void 0) {
      dollyScale = getZoomScale();
    }
    if (scope.object instanceof PerspectiveCamera) {
      scale2 /= dollyScale;
    } else if (scope.object instanceof OrthographicCamera) {
      scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * dollyScale));
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(changeEvent);
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
    }
  };
  this.dollyOut = function(dollyScale) {
    if (dollyScale === void 0) {
      dollyScale = getZoomScale();
    }
    if (scope.object instanceof PerspectiveCamera) {
      scale2 *= dollyScale;
    } else if (scope.object instanceof OrthographicCamera) {
      scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / dollyScale));
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(changeEvent);
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
    }
  };
  this.update = function(ignoreUpdate) {
    var position = this.object.position;
    offset2.copy(position).sub(this.target);
    offset2.applyQuaternion(quat);
    theta = Math.atan2(offset2.x, offset2.z);
    phi = Math.atan2(Math.sqrt(offset2.x * offset2.x + offset2.z * offset2.z), offset2.y);
    if (this.autoRotate && state === STATE.NONE) {
      this.rotateLeft(getAutoRotationAngle());
    }
    this.momentum();
    theta += thetaDelta;
    phi += phiDelta;
    theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));
    phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));
    phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));
    var radius = offset2.length() * scale2;
    radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));
    this.target.add(pan);
    offset2.x = radius * Math.sin(phi) * Math.sin(theta);
    offset2.y = radius * Math.cos(phi);
    offset2.z = radius * Math.sin(phi) * Math.cos(theta);
    offset2.applyQuaternion(quatInverse);
    position.copy(this.target).add(offset2);
    this.object.lookAt(this.target);
    thetaDelta = 0;
    phiDelta = 0;
    scale2 = 1;
    pan.set(0, 0, 0);
    if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {
      if (ignoreUpdate !== true) {
        this.dispatchEvent(changeEvent);
      }
      lastPosition.copy(this.object.position);
      lastQuaternion.copy(this.object.quaternion);
    }
  };
  this.reset = function() {
    state = STATE.NONE;
    this.target.copy(this.target0);
    this.object.position.copy(this.position0);
    this.object.zoom = this.zoom0;
    this.object.updateProjectionMatrix();
    this.dispatchEvent(changeEvent);
    this.update();
  };
  this.getPolarAngle = function() {
    return phi;
  };
  this.getAzimuthalAngle = function() {
    return theta;
  };
  function getAutoRotationAngle() {
    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
  }
  function getZoomScale() {
    return Math.pow(0.95, scope.zoomSpeed);
  }
  function onMouseDown(event) {
    momentumOn = false;
    momentumLeft = momentumUp = 0;
    if (scope.enabled === false)
      return;
    event.preventDefault();
    if (event.button === scope.mouseButtons.ORBIT) {
      if (scope.noRotate === true)
        return;
      state = STATE.ROTATE;
      rotateStart.set(event.clientX, event.clientY);
    } else if (event.button === scope.mouseButtons.ZOOM) {
      if (scope.noZoom === true)
        return;
      state = STATE.DOLLY;
      dollyStart.set(event.clientX, event.clientY);
    } else if (event.button === scope.mouseButtons.PAN) {
      if (scope.noPan === true)
        return;
      state = STATE.PAN;
      panStart.set(event.clientX, event.clientY);
    }
    if (state !== STATE.NONE) {
      document.addEventListener("mousemove", onMouseMove, false);
      document.addEventListener("mouseup", onMouseUp, false);
      scope.dispatchEvent(startEvent);
    }
    scope.update();
  }
  function onMouseMove(event) {
    if (scope.enabled === false)
      return;
    event.preventDefault();
    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
    if (state === STATE.ROTATE) {
      if (scope.noRotate === true)
        return;
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart);
      scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
      scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);
      rotateStart.copy(rotateEnd);
      if (eventPrevious) {
        momentumLeft = event.clientX - eventPrevious.clientX;
        momentumUp = event.clientY - eventPrevious.clientY;
      }
      eventPrevious = event;
    } else if (state === STATE.DOLLY) {
      if (scope.noZoom === true)
        return;
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        scope.dollyIn();
      } else if (dollyDelta.y < 0) {
        scope.dollyOut();
      }
      dollyStart.copy(dollyEnd);
    } else if (state === STATE.PAN) {
      if (scope.noPan === true)
        return;
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart);
      scope.pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    if (state !== STATE.NONE)
      scope.update();
  }
  function onMouseUp() {
    momentumOn = true;
    eventPrevious = void 0;
    if (scope.enabled === false)
      return;
    document.removeEventListener("mousemove", onMouseMove, false);
    document.removeEventListener("mouseup", onMouseUp, false);
    scope.dispatchEvent(endEvent);
    state = STATE.NONE;
  }
  function onMouseWheel(event) {
    if (scope.enabled === false || scope.noZoom === true || state !== STATE.NONE)
      return;
    event.preventDefault();
    event.stopPropagation();
    var delta = 0;
    if (event.wheelDelta !== void 0) {
      delta = event.wheelDelta;
    } else if (event.detail !== void 0) {
      delta = -event.detail;
    }
    if (delta < 0) {
      scope.object.fov = scope.object.fov < scope.maxFov ? scope.object.fov + 2 : scope.maxFov;
      scope.object.updateProjectionMatrix();
    } else if (delta > 0) {
      scope.object.fov = scope.object.fov > scope.minFov ? scope.object.fov - 2 : scope.minFov;
      scope.object.updateProjectionMatrix();
    }
    scope.update();
    scope.dispatchEvent(changeEvent);
    scope.dispatchEvent(startEvent);
    scope.dispatchEvent(endEvent);
  }
  function onKeyUp(event) {
    switch (event.keyCode) {
      case scope.keys.UP:
        keyUp = false;
        break;
      case scope.keys.BOTTOM:
        keyBottom = false;
        break;
      case scope.keys.LEFT:
        keyLeft = false;
        break;
      case scope.keys.RIGHT:
        keyRight = false;
        break;
    }
  }
  function onKeyDown(event) {
    if (scope.enabled === false || scope.noKeys === true || scope.noRotate === true)
      return;
    switch (event.keyCode) {
      case scope.keys.UP:
        keyUp = true;
        break;
      case scope.keys.BOTTOM:
        keyBottom = true;
        break;
      case scope.keys.LEFT:
        keyLeft = true;
        break;
      case scope.keys.RIGHT:
        keyRight = true;
        break;
    }
    if (keyUp || keyBottom || keyLeft || keyRight) {
      momentumOn = true;
      if (keyUp)
        momentumUp = -scope.rotateSpeed * scope.momentumKeydownFactor;
      if (keyBottom)
        momentumUp = scope.rotateSpeed * scope.momentumKeydownFactor;
      if (keyLeft)
        momentumLeft = -scope.rotateSpeed * scope.momentumKeydownFactor;
      if (keyRight)
        momentumLeft = scope.rotateSpeed * scope.momentumKeydownFactor;
    }
  }
  function touchstart(event) {
    momentumOn = false;
    momentumLeft = momentumUp = 0;
    if (scope.enabled === false)
      return;
    switch (event.touches.length) {
      case 1:
        if (scope.noRotate === true)
          return;
        state = STATE.TOUCH_ROTATE;
        rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
        break;
      case 2:
        if (scope.noZoom === true)
          return;
        state = STATE.TOUCH_DOLLY;
        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;
        var distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
        break;
      case 3:
        if (scope.noPan === true)
          return;
        state = STATE.TOUCH_PAN;
        panStart.set(event.touches[0].pageX, event.touches[0].pageY);
        break;
      default:
        state = STATE.NONE;
    }
    if (state !== STATE.NONE)
      scope.dispatchEvent(startEvent);
  }
  function touchmove(event) {
    if (scope.enabled === false)
      return;
    event.preventDefault();
    event.stopPropagation();
    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
    switch (event.touches.length) {
      case 1:
        if (scope.noRotate === true)
          return;
        if (state !== STATE.TOUCH_ROTATE)
          return;
        rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
        rotateDelta.subVectors(rotateEnd, rotateStart);
        scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
        scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);
        rotateStart.copy(rotateEnd);
        if (eventPrevious) {
          momentumLeft = event.touches[0].pageX - eventPrevious.pageX;
          momentumUp = event.touches[0].pageY - eventPrevious.pageY;
        }
        eventPrevious = {
          pageX: event.touches[0].pageX,
          pageY: event.touches[0].pageY
        };
        scope.update();
        break;
      case 2:
        if (scope.noZoom === true)
          return;
        if (state !== STATE.TOUCH_DOLLY)
          return;
        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;
        var distance = Math.sqrt(dx * dx + dy * dy);
        dollyEnd.set(0, distance);
        dollyDelta.subVectors(dollyEnd, dollyStart);
        if (dollyDelta.y < 0) {
          scope.object.fov = scope.object.fov < scope.maxFov ? scope.object.fov + 1 : scope.maxFov;
          scope.object.updateProjectionMatrix();
        } else if (dollyDelta.y > 0) {
          scope.object.fov = scope.object.fov > scope.minFov ? scope.object.fov - 1 : scope.minFov;
          scope.object.updateProjectionMatrix();
        }
        dollyStart.copy(dollyEnd);
        scope.update();
        scope.dispatchEvent(changeEvent);
        break;
      case 3:
        if (scope.noPan === true)
          return;
        if (state !== STATE.TOUCH_PAN)
          return;
        panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
        panDelta.subVectors(panEnd, panStart);
        scope.pan(panDelta.x, panDelta.y);
        panStart.copy(panEnd);
        scope.update();
        break;
      default:
        state = STATE.NONE;
    }
  }
  function touchend() {
    momentumOn = true;
    eventPrevious = void 0;
    if (scope.enabled === false)
      return;
    scope.dispatchEvent(endEvent);
    state = STATE.NONE;
  }
  this.dispose = function() {
    this.domElement.removeEventListener("mousedown", onMouseDown);
    this.domElement.removeEventListener("mousewheel", onMouseWheel);
    this.domElement.removeEventListener("DOMMouseScroll", onMouseWheel);
    this.domElement.removeEventListener("touchstart", touchstart);
    this.domElement.removeEventListener("touchend", touchend);
    this.domElement.removeEventListener("touchmove", touchmove);
    window.removeEventListener("keyup", onKeyUp);
    window.removeEventListener("keydown", onKeyDown);
  };
  this.domElement.addEventListener("mousedown", onMouseDown, { passive: false });
  this.domElement.addEventListener("mousewheel", onMouseWheel, { passive: false });
  this.domElement.addEventListener("DOMMouseScroll", onMouseWheel, { passive: false });
  this.domElement.addEventListener("touchstart", touchstart, { passive: false });
  this.domElement.addEventListener("touchend", touchend, { passive: false });
  this.domElement.addEventListener("touchmove", touchmove, { passive: false });
  window.addEventListener("keyup", onKeyUp, { passive: false });
  window.addEventListener("keydown", onKeyDown, { passive: false });
  this.update();
}
OrbitControls.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: OrbitControls
});
function DeviceOrientationControls(camera, domElement) {
  var scope = this;
  var changeEvent = { type: "change" };
  var rotY = 0;
  var rotX = 0;
  var tempX = 0;
  var tempY = 0;
  this.camera = camera;
  this.camera.rotation.reorder("YXZ");
  this.domElement = domElement !== void 0 ? domElement : document;
  this.enabled = true;
  this.deviceOrientation = {};
  this.screenOrientation = 0;
  this.alpha = 0;
  this.alphaOffsetAngle = 0;
  var onDeviceOrientationChangeEvent = function(event) {
    scope.deviceOrientation = event;
  };
  var onScreenOrientationChangeEvent = function() {
    scope.screenOrientation = window.orientation || 0;
  };
  var onTouchStartEvent = function(event) {
    event.preventDefault();
    event.stopPropagation();
    tempX = event.touches[0].pageX;
    tempY = event.touches[0].pageY;
  };
  var onTouchMoveEvent = function(event) {
    event.preventDefault();
    event.stopPropagation();
    rotY += _Math.degToRad((event.touches[0].pageX - tempX) / 4);
    rotX += _Math.degToRad((tempY - event.touches[0].pageY) / 4);
    scope.updateAlphaOffsetAngle(rotY);
    tempX = event.touches[0].pageX;
    tempY = event.touches[0].pageY;
  };
  var setCameraQuaternion = function(quaternion, alpha, beta, gamma, orient) {
    var zee = new Vector3(0, 0, 1);
    var euler = new Euler();
    var q0 = new Quaternion();
    var q1 = new Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
    var vectorFingerY;
    var fingerQY = new Quaternion();
    var fingerQX = new Quaternion();
    if (scope.screenOrientation == 0) {
      vectorFingerY = new Vector3(1, 0, 0);
      fingerQY.setFromAxisAngle(vectorFingerY, -rotX);
    } else if (scope.screenOrientation == 180) {
      vectorFingerY = new Vector3(1, 0, 0);
      fingerQY.setFromAxisAngle(vectorFingerY, rotX);
    } else if (scope.screenOrientation == 90) {
      vectorFingerY = new Vector3(0, 1, 0);
      fingerQY.setFromAxisAngle(vectorFingerY, rotX);
    } else if (scope.screenOrientation == -90) {
      vectorFingerY = new Vector3(0, 1, 0);
      fingerQY.setFromAxisAngle(vectorFingerY, -rotX);
    }
    q1.multiply(fingerQY);
    q1.multiply(fingerQX);
    euler.set(beta, alpha, -gamma, "YXZ");
    quaternion.setFromEuler(euler);
    quaternion.multiply(q1);
    quaternion.multiply(q0.setFromAxisAngle(zee, -orient));
  };
  this.connect = function() {
    onScreenOrientationChangeEvent();
    window.addEventListener("orientationchange", onScreenOrientationChangeEvent, { passive: true });
    window.addEventListener("deviceorientation", onDeviceOrientationChangeEvent, { passive: true });
    window.addEventListener("deviceorientation", this.update.bind(this), { passive: true });
    scope.domElement.addEventListener("touchstart", onTouchStartEvent, { passive: false });
    scope.domElement.addEventListener("touchmove", onTouchMoveEvent, { passive: false });
    scope.enabled = true;
  };
  this.disconnect = function() {
    window.removeEventListener("orientationchange", onScreenOrientationChangeEvent, false);
    window.removeEventListener("deviceorientation", onDeviceOrientationChangeEvent, false);
    window.removeEventListener("deviceorientation", this.update.bind(this), false);
    scope.domElement.removeEventListener("touchstart", onTouchStartEvent, false);
    scope.domElement.removeEventListener("touchmove", onTouchMoveEvent, false);
    scope.enabled = false;
  };
  this.update = function(ignoreUpdate) {
    if (scope.enabled === false)
      return;
    var alpha = scope.deviceOrientation.alpha ? _Math.degToRad(scope.deviceOrientation.alpha) + scope.alphaOffsetAngle : 0;
    var beta = scope.deviceOrientation.beta ? _Math.degToRad(scope.deviceOrientation.beta) : 0;
    var gamma = scope.deviceOrientation.gamma ? _Math.degToRad(scope.deviceOrientation.gamma) : 0;
    var orient = scope.screenOrientation ? _Math.degToRad(scope.screenOrientation) : 0;
    setCameraQuaternion(scope.camera.quaternion, alpha, beta, gamma, orient);
    scope.alpha = alpha;
    if (ignoreUpdate !== true) {
      scope.dispatchEvent(changeEvent);
    }
  };
  this.updateAlphaOffsetAngle = function(angle) {
    this.alphaOffsetAngle = angle;
    this.update();
  };
  this.dispose = function() {
    this.disconnect();
  };
  this.connect();
}
DeviceOrientationControls.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: DeviceOrientationControls
});
function CardboardEffect(renderer) {
  var _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
  var _scene = new Scene();
  var _stereo = new StereoCamera();
  _stereo.aspect = 0.5;
  var _params = { minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat };
  var _renderTarget = new WebGLRenderTarget(512, 512, _params);
  _renderTarget.scissorTest = true;
  _renderTarget.texture.generateMipmaps = false;
  var distortion = new Vector2(0.441, 0.156);
  var geometry2 = new PlaneBufferGeometry(1, 1, 10, 20).removeAttribute("normal").toNonIndexed();
  var positions = geometry2.attributes.position.array;
  var uvs = geometry2.attributes.uv.array;
  geometry2.attributes.position.count *= 2;
  geometry2.attributes.uv.count *= 2;
  var positions2 = new Float32Array(positions.length * 2);
  positions2.set(positions);
  positions2.set(positions, positions.length);
  var uvs2 = new Float32Array(uvs.length * 2);
  uvs2.set(uvs);
  uvs2.set(uvs, uvs.length);
  var vector = new Vector2();
  var length = positions.length / 3;
  for (var i2 = 0, l2 = positions2.length / 3; i2 < l2; i2++) {
    vector.x = positions2[i2 * 3 + 0];
    vector.y = positions2[i2 * 3 + 1];
    var dot = vector.dot(vector);
    var scalar = 1.5 + (distortion.x + distortion.y * dot) * dot;
    var offset2 = i2 < length ? 0 : 1;
    positions2[i2 * 3 + 0] = vector.x / scalar * 1.5 - 0.5 + offset2;
    positions2[i2 * 3 + 1] = vector.y / scalar * 3;
    uvs2[i2 * 2] = (uvs2[i2 * 2] + offset2) * 0.5;
  }
  geometry2.attributes.position.array = positions2;
  geometry2.attributes.uv.array = uvs2;
  var material = new MeshBasicMaterial({ map: _renderTarget.texture });
  var mesh = new Mesh(geometry2, material);
  _scene.add(mesh);
  this.setSize = function(width, height) {
    renderer.setSize(width, height);
    var pixelRatio = renderer.getPixelRatio();
    _renderTarget.setSize(width * pixelRatio, height * pixelRatio);
  };
  this.render = function(scene, camera) {
    scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    _stereo.update(camera);
    var width = _renderTarget.width / 2;
    var height = _renderTarget.height;
    if (renderer.autoClear)
      renderer.clear();
    _renderTarget.scissor.set(0, 0, width, height);
    _renderTarget.viewport.set(0, 0, width, height);
    renderer.setRenderTarget(_renderTarget);
    renderer.render(scene, _stereo.cameraL);
    renderer.clearDepth();
    _renderTarget.scissor.set(width, 0, width, height);
    _renderTarget.viewport.set(width, 0, width, height);
    renderer.setRenderTarget(_renderTarget);
    renderer.render(scene, _stereo.cameraR);
    renderer.clearDepth();
    renderer.setRenderTarget(null);
    renderer.render(_scene, _camera);
  };
}
const StereoEffect = function(renderer) {
  var _stereo = new StereoCamera();
  _stereo.aspect = 0.5;
  var size = new Vector2();
  this.setEyeSeparation = function(eyeSep) {
    _stereo.eyeSep = eyeSep;
  };
  this.setSize = function(width, height) {
    renderer.setSize(width, height);
  };
  this.render = function(scene, camera) {
    scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    _stereo.update(camera);
    renderer.getSize(size);
    if (renderer.autoClear)
      renderer.clear();
    renderer.setScissorTest(true);
    renderer.setScissor(0, 0, size.width / 2, size.height);
    renderer.setViewport(0, 0, size.width / 2, size.height);
    renderer.render(scene, _stereo.cameraL);
    renderer.setScissor(size.width / 2, 0, size.width / 2, size.height);
    renderer.setViewport(size.width / 2, 0, size.width / 2, size.height);
    renderer.render(scene, _stereo.cameraR);
    renderer.setScissorTest(false);
  };
};
function Viewer(options) {
  let container;
  options = options || {};
  options.controlBar = options.controlBar !== void 0 ? options.controlBar : true;
  options.controlButtons = options.controlButtons || ["fullscreen", "setting", "video"];
  options.autoHideControlBar = options.autoHideControlBar !== void 0 ? options.autoHideControlBar : false;
  options.autoHideInfospot = options.autoHideInfospot !== void 0 ? options.autoHideInfospot : true;
  options.horizontalView = options.horizontalView !== void 0 ? options.horizontalView : false;
  options.clickTolerance = options.clickTolerance || 10;
  options.cameraFov = options.cameraFov || 60;
  options.reverseDragging = options.reverseDragging || false;
  options.enableReticle = options.enableReticle || false;
  options.dwellTime = options.dwellTime || 1500;
  options.autoReticleSelect = options.autoReticleSelect !== void 0 ? options.autoReticleSelect : true;
  options.viewIndicator = options.viewIndicator !== void 0 ? options.viewIndicator : false;
  options.indicatorSize = options.indicatorSize || 30;
  options.output = options.output ? options.output : "none";
  options.autoRotate = options.autoRotate || false;
  options.autoRotateSpeed = options.autoRotateSpeed || 2;
  options.autoRotateActivationDuration = options.autoRotateActivationDuration || 5e3;
  this.options = options;
  if (options.container) {
    container = options.container;
    container._width = container.clientWidth;
    container._height = container.clientHeight;
  } else {
    container = document.createElement("div");
    container.classList.add("panolens-container");
    container.style.width = "100%";
    container.style.height = "100%";
    container._width = window.innerWidth;
    container._height = window.innerHeight;
    document.body.appendChild(container);
  }
  this.container = container;
  this.camera = options.camera || new PerspectiveCamera(this.options.cameraFov, this.container.clientWidth / this.container.clientHeight, 1, 1e4);
  this.scene = options.scene || new Scene();
  this.renderer = options.renderer || new WebGLRenderer({ alpha: true, antialias: false });
  this.sceneReticle = new Scene();
  this.viewIndicatorSize = this.options.indicatorSize;
  this.reticle = {};
  this.tempEnableReticle = this.options.enableReticle;
  this.mode = MODES.NORMAL;
  this.panorama = null;
  this.widget = null;
  this.hoverObject = null;
  this.infospot = null;
  this.pressEntityObject = null;
  this.pressObject = null;
  this.raycaster = new Raycaster();
  this.raycasterPoint = new Vector2();
  this.userMouse = new Vector2();
  this.updateCallbacks = [];
  this.requestAnimationId = null;
  this.cameraFrustum = new Frustum();
  this.cameraViewProjectionMatrix = new Matrix4();
  this.autoRotateRequestId = null;
  this.outputDivElement = null;
  this.touchSupported = "ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch;
  this.HANDLER_MOUSE_DOWN = this.onMouseDown.bind(this);
  this.HANDLER_MOUSE_UP = this.onMouseUp.bind(this);
  this.HANDLER_MOUSE_MOVE = this.onMouseMove.bind(this);
  this.HANDLER_WINDOW_RESIZE = this.onWindowResize.bind(this);
  this.HANDLER_KEY_DOWN = this.onKeyDown.bind(this);
  this.HANDLER_KEY_UP = this.onKeyUp.bind(this);
  this.HANDLER_TAP = this.onTap.bind(this, {
    clientX: this.container.clientWidth / 2,
    clientY: this.container.clientHeight / 2
  });
  this.OUTPUT_INFOSPOT = false;
  this.tweenLeftAnimation = new Tween.Tween();
  this.tweenUpAnimation = new Tween.Tween();
  this.renderer.setPixelRatio(window.devicePixelRatio);
  this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
  this.renderer.setClearColor(0, 0);
  this.renderer.autoClear = false;
  this.renderer.domElement.classList.add("panolens-canvas");
  this.renderer.domElement.style.display = "block";
  this.container.style.backgroundColor = "#000";
  this.container.appendChild(this.renderer.domElement);
  this.OrbitControls = new OrbitControls(this.camera, this.container);
  this.OrbitControls.id = "orbit";
  this.OrbitControls.minDistance = 1;
  this.OrbitControls.noPan = true;
  this.OrbitControls.autoRotate = this.options.autoRotate;
  this.OrbitControls.autoRotateSpeed = this.options.autoRotateSpeed;
  this.DeviceOrientationControls = new DeviceOrientationControls(this.camera, this.container);
  this.DeviceOrientationControls.id = "device-orientation";
  this.DeviceOrientationControls.enabled = false;
  this.camera.position.z = 1;
  if (this.options.passiveRendering) {
    console.warn("passiveRendering is now deprecated");
  }
  this.controls = [this.OrbitControls, this.DeviceOrientationControls];
  this.control = this.OrbitControls;
  this.CardboardEffect = new CardboardEffect(this.renderer);
  this.CardboardEffect.setSize(this.container.clientWidth, this.container.clientHeight);
  this.StereoEffect = new StereoEffect(this.renderer);
  this.StereoEffect.setSize(this.container.clientWidth, this.container.clientHeight);
  this.effect = this.CardboardEffect;
  this.addReticle();
  if (this.options.horizontalView) {
    this.OrbitControls.minPolarAngle = Math.PI / 2;
    this.OrbitControls.maxPolarAngle = Math.PI / 2;
  }
  if (this.options.controlBar !== false) {
    this.addDefaultControlBar(this.options.controlButtons);
  }
  if (this.options.viewIndicator) {
    this.addViewIndicator();
  }
  if (this.options.reverseDragging) {
    this.reverseDraggingDirection();
  }
  if (this.options.enableReticle) {
    this.enableReticleControl();
  } else {
    this.registerMouseAndTouchEvents();
  }
  if (this.options.output === "overlay") {
    this.addOutputElement();
  }
  this.registerEventListeners();
  this.animate.call(this);
}
Viewer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Viewer,
  add: function(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.add(arguments[i2]);
      }
      return this;
    }
    this.scene.add(object);
    if (object.addEventListener) {
      object.addEventListener("panolens-viewer-handler", this.eventHandler.bind(this));
    }
    if (object instanceof Panorama && object.dispatchEvent) {
      object.dispatchEvent({ type: "panolens-container", container: this.container });
    }
    if (object instanceof CameraPanorama) {
      object.dispatchEvent({ type: "panolens-scene", scene: this.scene });
    }
    if (object.type === "panorama") {
      this.addPanoramaEventListener(object);
      if (!this.panorama) {
        this.setPanorama(object);
      }
    }
  },
  remove: function(object) {
    if (object.removeEventListener) {
      object.removeEventListener("panolens-viewer-handler", this.eventHandler.bind(this));
    }
    this.scene.remove(object);
  },
  addDefaultControlBar: function(array) {
    if (this.widget) {
      console.warn("Default control bar exists");
      return;
    }
    const widget = new Widget(this.container);
    widget.addEventListener("panolens-viewer-handler", this.eventHandler.bind(this));
    widget.addControlBar();
    array.forEach((buttonName) => {
      widget.addControlButton(buttonName);
    });
    this.widget = widget;
  },
  setPanorama: function(pano) {
    const leavingPanorama = this.panorama;
    if (pano.type === "panorama" && leavingPanorama !== pano) {
      this.hideInfospot();
      const afterEnterComplete = function() {
        if (leavingPanorama) {
          leavingPanorama.onLeave();
        }
        pano.removeEventListener("enter-fade-start", afterEnterComplete);
      };
      pano.addEventListener("enter-fade-start", afterEnterComplete);
      (this.panorama = pano).onEnter();
    }
  },
  eventHandler: function(event) {
    if (event.method && this[event.method]) {
      this[event.method](event.data);
    }
  },
  dispatchEventToChildren: function(event) {
    this.scene.traverse(function(object) {
      if (object.dispatchEvent) {
        object.dispatchEvent(event);
      }
    });
  },
  activateWidgetItem: function(controlIndex, mode) {
    const mainMenu = this.widget.mainMenu;
    const ControlMenuItem = mainMenu.children[0];
    const ModeMenuItem = mainMenu.children[1];
    let item;
    if (controlIndex !== void 0) {
      switch (controlIndex) {
        case 0:
          item = ControlMenuItem.subMenu.children[1];
          break;
        case 1:
          item = ControlMenuItem.subMenu.children[2];
          break;
        default:
          item = ControlMenuItem.subMenu.children[1];
          break;
      }
      ControlMenuItem.subMenu.setActiveItem(item);
      ControlMenuItem.setSelectionTitle(item.textContent);
    }
    if (mode !== void 0) {
      switch (mode) {
        case MODES.CARDBOARD:
          item = ModeMenuItem.subMenu.children[2];
          break;
        case MODES.STEREO:
          item = ModeMenuItem.subMenu.children[3];
          break;
        default:
          item = ModeMenuItem.subMenu.children[1];
          break;
      }
      ModeMenuItem.subMenu.setActiveItem(item);
      ModeMenuItem.setSelectionTitle(item.textContent);
    }
  },
  enableEffect: function(mode) {
    if (this.mode === mode) {
      return;
    }
    if (mode === MODES.NORMAL) {
      this.disableEffect();
      return;
    } else {
      this.mode = mode;
    }
    const fov2 = this.camera.fov;
    switch (mode) {
      case MODES.CARDBOARD:
        this.effect = this.CardboardEffect;
        this.enableReticleControl();
        break;
      case MODES.STEREO:
        this.effect = this.StereoEffect;
        this.enableReticleControl();
        break;
      default:
        this.effect = null;
        this.disableReticleControl();
        break;
    }
    this.activateWidgetItem(void 0, this.mode);
    this.dispatchEventToChildren({ type: "panolens-dual-eye-effect", mode: this.mode });
    this.camera.fov = fov2 + 0.01;
    this.effect.setSize(this.container.clientWidth, this.container.clientHeight);
    this.render();
    this.camera.fov = fov2;
    this.dispatchEvent({ type: "mode-change", mode: this.mode });
  },
  disableEffect: function() {
    if (this.mode === MODES.NORMAL) {
      return;
    }
    this.mode = MODES.NORMAL;
    this.disableReticleControl();
    this.activateWidgetItem(void 0, this.mode);
    this.dispatchEventToChildren({ type: "panolens-dual-eye-effect", mode: this.mode });
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    this.render();
    this.dispatchEvent({ type: "mode-change", mode: this.mode });
  },
  enableReticleControl: function() {
    if (this.reticle.visible) {
      return;
    }
    this.tempEnableReticle = true;
    this.unregisterMouseAndTouchEvents();
    this.reticle.show();
    this.registerReticleEvent();
    this.updateReticleEvent();
  },
  disableReticleControl: function() {
    this.tempEnableReticle = false;
    if (!this.options.enableReticle) {
      this.reticle.hide();
      this.unregisterReticleEvent();
      this.registerMouseAndTouchEvents();
    } else {
      this.updateReticleEvent();
    }
  },
  enableAutoRate: function() {
    this.options.autoRotate = true;
    this.OrbitControls.autoRotate = true;
  },
  disableAutoRate: function() {
    clearTimeout(this.autoRotateRequestId);
    this.options.autoRotate = false;
    this.OrbitControls.autoRotate = false;
  },
  toggleVideoPlay: function(pause) {
    if (this.panorama instanceof VideoPanorama) {
      this.panorama.dispatchEvent({ type: "video-toggle", pause });
    }
  },
  setVideoCurrentTime: function(percentage) {
    if (this.panorama instanceof VideoPanorama) {
      this.panorama.dispatchEvent({ type: "video-time", percentage });
    }
  },
  onVideoUpdate: function(percentage) {
    const { widget } = this;
    if (widget) {
      widget.dispatchEvent({ type: "video-update", percentage });
    }
  },
  addUpdateCallback: function(fn) {
    if (fn) {
      this.updateCallbacks.push(fn);
    }
  },
  removeUpdateCallback: function(fn) {
    const index2 = this.updateCallbacks.indexOf(fn);
    if (fn && index2 >= 0) {
      this.updateCallbacks.splice(index2, 1);
    }
  },
  showVideoWidget: function() {
    const { widget } = this;
    if (widget) {
      widget.dispatchEvent({ type: "video-control-show" });
    }
  },
  hideVideoWidget: function() {
    const { widget } = this;
    if (widget) {
      widget.dispatchEvent({ type: "video-control-hide" });
    }
  },
  updateVideoPlayButton: function(paused) {
    const { widget } = this;
    if (widget && widget.videoElement && widget.videoElement.controlButton) {
      widget.videoElement.controlButton.update(paused);
    }
  },
  addPanoramaEventListener: function(pano) {
    pano.addEventListener("enter-fade-start", this.setCameraControl.bind(this));
    if (pano instanceof VideoPanorama) {
      pano.addEventListener("enter-fade-start", this.showVideoWidget.bind(this));
      pano.addEventListener("leave", function() {
        if (!(this.panorama instanceof VideoPanorama)) {
          this.hideVideoWidget.call(this);
        }
      }.bind(this));
    }
  },
  setCameraControl: function() {
    this.OrbitControls.target.copy(this.panorama.position);
  },
  getControl: function() {
    return this.control;
  },
  getScene: function() {
    return this.scene;
  },
  getCamera: function() {
    return this.camera;
  },
  getRenderer: function() {
    return this.renderer;
  },
  getContainer: function() {
    return this.container;
  },
  getControlId: function() {
    return this.control.id;
  },
  getNextControlId: function() {
    return this.controls[this.getNextControlIndex()].id;
  },
  getNextControlIndex: function() {
    const controls = this.controls;
    const control = this.control;
    const nextIndex = controls.indexOf(control) + 1;
    return nextIndex >= controls.length ? 0 : nextIndex;
  },
  setCameraFov: function(fov2) {
    this.camera.fov = fov2;
    this.camera.updateProjectionMatrix();
  },
  enableControl: function(index2) {
    index2 = index2 >= 0 && index2 < this.controls.length ? index2 : 0;
    this.control.enabled = false;
    this.control = this.controls[index2];
    this.control.enabled = true;
    switch (index2) {
      case CONTROLS.ORBIT:
        this.camera.position.copy(this.panorama.position);
        this.camera.position.z += 1;
        break;
      case CONTROLS.DEVICEORIENTATION:
        this.camera.position.copy(this.panorama.position);
        break;
    }
    this.control.update();
    this.activateWidgetItem(index2, void 0);
  },
  disableControl: function() {
    this.control.enabled = false;
  },
  toggleNextControl: function() {
    this.enableControl(this.getNextControlIndex());
  },
  getScreenVector: function(worldVector) {
    const vector = worldVector.clone();
    const widthHalf = this.container.clientWidth / 2;
    const heightHalf = this.container.clientHeight / 2;
    vector.project(this.camera);
    vector.x = vector.x * widthHalf + widthHalf;
    vector.y = -(vector.y * heightHalf) + heightHalf;
    vector.z = 0;
    return vector;
  },
  checkSpriteInViewport: function(sprite) {
    this.camera.matrixWorldInverse.getInverse(this.camera.matrixWorld);
    this.cameraViewProjectionMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse);
    this.cameraFrustum.setFromMatrix(this.cameraViewProjectionMatrix);
    return sprite.visible && this.cameraFrustum.intersectsSprite(sprite);
  },
  reverseDraggingDirection: function() {
    this.OrbitControls.rotateSpeed *= -1;
    this.OrbitControls.momentumScalingFactor *= -1;
  },
  addReticle: function() {
    this.reticle = new Reticle(16777215, true, this.options.dwellTime);
    this.reticle.hide();
    this.camera.add(this.reticle);
    this.sceneReticle.add(this.camera);
  },
  tweenControlCenter: function(vector, duration, easing) {
    if (this.control !== this.OrbitControls) {
      return;
    }
    if (vector instanceof Array) {
      duration = vector[1];
      easing = vector[2];
      vector = vector[0];
    }
    duration = duration !== void 0 ? duration : 1e3;
    easing = easing || Tween.Easing.Exponential.Out;
    let scope, ha, va, chv, cvv, hv, vv, vptc, ov, nv;
    scope = this;
    chv = this.camera.getWorldDirection(new Vector3());
    cvv = chv.clone();
    vptc = this.panorama.getWorldPosition(new Vector3()).sub(this.camera.getWorldPosition(new Vector3()));
    hv = vector.clone();
    hv.x *= -1;
    hv.add(vptc).normalize();
    vv = hv.clone();
    chv.y = 0;
    hv.y = 0;
    ha = Math.atan2(hv.z, hv.x) - Math.atan2(chv.z, chv.x);
    ha = ha > Math.PI ? ha - 2 * Math.PI : ha;
    ha = ha < -Math.PI ? ha + 2 * Math.PI : ha;
    va = Math.abs(cvv.angleTo(chv) + (cvv.y * vv.y <= 0 ? vv.angleTo(hv) : -vv.angleTo(hv)));
    va *= vv.y < cvv.y ? 1 : -1;
    ov = { left: 0, up: 0 };
    nv = { left: 0, up: 0 };
    this.tweenLeftAnimation.stop();
    this.tweenUpAnimation.stop();
    this.tweenLeftAnimation = new Tween.Tween(ov).to({ left: ha }, duration).easing(easing).onUpdate(function(ov2) {
      scope.control.rotateLeft(ov2.left - nv.left);
      nv.left = ov2.left;
    }).start();
    this.tweenUpAnimation = new Tween.Tween(ov).to({ up: va }, duration).easing(easing).onUpdate(function(ov2) {
      scope.control.rotateUp(ov2.up - nv.up);
      nv.up = ov2.up;
    }).start();
  },
  tweenControlCenterByObject: function(object, duration, easing) {
    let isUnderScalePlaceHolder = false;
    object.traverseAncestors(function(ancestor) {
      if (ancestor.scalePlaceHolder) {
        isUnderScalePlaceHolder = true;
      }
    });
    if (isUnderScalePlaceHolder) {
      const invertXVector = new Vector3(-1, 1, 1);
      this.tweenControlCenter(object.getWorldPosition(new Vector3()).multiply(invertXVector), duration, easing);
    } else {
      this.tweenControlCenter(object.getWorldPosition(new Vector3()), duration, easing);
    }
  },
  onWindowResize: function(windowWidth, windowHeight) {
    let width, height;
    const expand = this.container.classList.contains("panolens-container") || this.container.isFullscreen;
    if (windowWidth !== void 0 && windowHeight !== void 0) {
      width = windowWidth;
      height = windowHeight;
      this.container._width = windowWidth;
      this.container._height = windowHeight;
    } else {
      const isAndroid = /(android)/i.test(window.navigator.userAgent);
      const adjustWidth = isAndroid ? Math.min(document.documentElement.clientWidth, window.innerWidth || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      const adjustHeight = isAndroid ? Math.min(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      width = expand ? adjustWidth : this.container.clientWidth;
      height = expand ? adjustHeight : this.container.clientHeight;
      this.container._width = width;
      this.container._height = height;
    }
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(width, height);
    if (this.options.enableReticle || this.tempEnableReticle) {
      this.updateReticleEvent();
    }
    this.dispatchEvent({ type: "window-resize", width, height });
    this.scene.traverse(function(object) {
      if (object.dispatchEvent) {
        object.dispatchEvent({ type: "window-resize", width, height });
      }
    });
  },
  addOutputElement: function() {
    const element = document.createElement("div");
    element.style.position = "absolute";
    element.style.right = "10px";
    element.style.top = "10px";
    element.style.color = "#fff";
    this.container.appendChild(element);
    this.outputDivElement = element;
  },
  outputPosition: function() {
    const intersects2 = this.raycaster.intersectObject(this.panorama, true);
    if (intersects2.length > 0) {
      const point = intersects2[0].point.clone();
      const converter = new Vector3(-1, 1, 1);
      const world = this.panorama.getWorldPosition(new Vector3());
      point.sub(world).multiply(converter);
      const message = `${point.x.toFixed(2)}, ${point.y.toFixed(2)}, ${point.z.toFixed(2)}`;
      if (point.length() === 0) {
        return;
      }
      switch (this.options.output) {
        case "console":
          console.info(message);
          break;
        case "overlay":
          this.outputDivElement.textContent = message;
          break;
      }
    }
  },
  onMouseDown: function(event) {
    event.preventDefault();
    this.userMouse.x = event.clientX >= 0 ? event.clientX : event.touches[0].clientX;
    this.userMouse.y = event.clientY >= 0 ? event.clientY : event.touches[0].clientY;
    this.userMouse.type = "mousedown";
    this.onTap(event);
  },
  onMouseMove: function(event) {
    event.preventDefault();
    this.userMouse.type = "mousemove";
    this.onTap(event);
  },
  onMouseUp: function(event) {
    let onTarget = false;
    this.userMouse.type = "mouseup";
    const type = this.userMouse.x >= event.clientX - this.options.clickTolerance && this.userMouse.x <= event.clientX + this.options.clickTolerance && this.userMouse.y >= event.clientY - this.options.clickTolerance && this.userMouse.y <= event.clientY + this.options.clickTolerance || event.changedTouches && this.userMouse.x >= event.changedTouches[0].clientX - this.options.clickTolerance && this.userMouse.x <= event.changedTouches[0].clientX + this.options.clickTolerance && this.userMouse.y >= event.changedTouches[0].clientY - this.options.clickTolerance && this.userMouse.y <= event.changedTouches[0].clientY + this.options.clickTolerance ? "click" : void 0;
    if (event && event.target && !event.target.classList.contains("panolens-canvas")) {
      return;
    }
    event.preventDefault();
    if (event.changedTouches && event.changedTouches.length === 1) {
      onTarget = this.onTap({ clientX: event.changedTouches[0].clientX, clientY: event.changedTouches[0].clientY }, type);
    } else {
      onTarget = this.onTap(event, type);
    }
    this.userMouse.type = "none";
    if (onTarget) {
      return;
    }
    if (type === "click") {
      const { options: { autoHideInfospot, autoHideControlBar }, panorama, toggleControlBar } = this;
      if (autoHideInfospot && panorama) {
        panorama.toggleInfospotVisibility();
      }
      if (autoHideControlBar) {
        toggleControlBar();
      }
    }
  },
  onTap: function(event, type) {
    const { left, top } = this.container.getBoundingClientRect();
    const { clientWidth, clientHeight } = this.container;
    this.raycasterPoint.x = (event.clientX - left) / clientWidth * 2 - 1;
    this.raycasterPoint.y = -((event.clientY - top) / clientHeight) * 2 + 1;
    this.raycaster.setFromCamera(this.raycasterPoint, this.camera);
    if (!this.panorama) {
      return;
    }
    if (event.type !== "mousedown" && this.touchSupported || this.OUTPUT_INFOSPOT) {
      this.outputPosition();
    }
    const intersects2 = this.raycaster.intersectObjects(this.panorama.children, true);
    const intersect_entity = this.getConvertedIntersect(intersects2);
    const intersect = intersects2.length > 0 ? intersects2[0].object : void 0;
    if (this.userMouse.type === "mouseup") {
      if (intersect_entity && this.pressEntityObject === intersect_entity && this.pressEntityObject.dispatchEvent) {
        this.pressEntityObject.dispatchEvent({ type: "pressstop-entity", mouseEvent: event });
      }
      this.pressEntityObject = void 0;
    }
    if (this.userMouse.type === "mouseup") {
      if (intersect && this.pressObject === intersect && this.pressObject.dispatchEvent) {
        this.pressObject.dispatchEvent({ type: "pressstop", mouseEvent: event });
      }
      this.pressObject = void 0;
    }
    if (type === "click") {
      this.panorama.dispatchEvent({ type: "click", intersects: intersects2, mouseEvent: event });
      if (intersect_entity && intersect_entity.dispatchEvent) {
        intersect_entity.dispatchEvent({ type: "click-entity", mouseEvent: event });
      }
      if (intersect && intersect.dispatchEvent) {
        intersect.dispatchEvent({ type: "click", mouseEvent: event });
      }
    } else {
      this.panorama.dispatchEvent({ type: "hover", intersects: intersects2, mouseEvent: event });
      if (this.hoverObject && intersects2.length > 0 && this.hoverObject !== intersect_entity || this.hoverObject && intersects2.length === 0) {
        if (this.hoverObject.dispatchEvent) {
          this.hoverObject.dispatchEvent({ type: "hoverleave", mouseEvent: event });
          this.reticle.end();
        }
        this.hoverObject = void 0;
      }
      if (intersect_entity && intersects2.length > 0) {
        if (this.hoverObject !== intersect_entity) {
          this.hoverObject = intersect_entity;
          if (this.hoverObject.dispatchEvent) {
            this.hoverObject.dispatchEvent({ type: "hoverenter", mouseEvent: event });
            if (this.options.autoReticleSelect && this.options.enableReticle || this.tempEnableReticle) {
              this.reticle.start(this.onTap.bind(this, event, "click"));
            }
          }
        }
        if (this.userMouse.type === "mousedown" && this.pressEntityObject != intersect_entity) {
          this.pressEntityObject = intersect_entity;
          if (this.pressEntityObject.dispatchEvent) {
            this.pressEntityObject.dispatchEvent({ type: "pressstart-entity", mouseEvent: event });
          }
        }
        if (this.userMouse.type === "mousedown" && this.pressObject != intersect) {
          this.pressObject = intersect;
          if (this.pressObject.dispatchEvent) {
            this.pressObject.dispatchEvent({ type: "pressstart", mouseEvent: event });
          }
        }
        if (this.userMouse.type === "mousemove" || this.options.enableReticle) {
          if (intersect && intersect.dispatchEvent) {
            intersect.dispatchEvent({ type: "hover", mouseEvent: event });
          }
          if (this.pressEntityObject && this.pressEntityObject.dispatchEvent) {
            this.pressEntityObject.dispatchEvent({ type: "pressmove-entity", mouseEvent: event });
          }
          if (this.pressObject && this.pressObject.dispatchEvent) {
            this.pressObject.dispatchEvent({ type: "pressmove", mouseEvent: event });
          }
        }
      }
      if (!intersect_entity && this.pressEntityObject && this.pressEntityObject.dispatchEvent) {
        this.pressEntityObject.dispatchEvent({ type: "pressstop-entity", mouseEvent: event });
        this.pressEntityObject = void 0;
      }
      if (!intersect && this.pressObject && this.pressObject.dispatchEvent) {
        this.pressObject.dispatchEvent({ type: "pressstop", mouseEvent: event });
        this.pressObject = void 0;
      }
    }
    if (intersect && intersect instanceof Infospot) {
      this.infospot = intersect;
      if (type === "click") {
        return true;
      }
    } else if (this.infospot) {
      this.hideInfospot();
    }
    if (this.options.autoRotate && this.userMouse.type !== "mousemove") {
      clearTimeout(this.autoRotateRequestId);
      if (this.control === this.OrbitControls) {
        this.OrbitControls.autoRotate = false;
        this.autoRotateRequestId = window.setTimeout(this.enableAutoRate.bind(this), this.options.autoRotateActivationDuration);
      }
    }
  },
  getConvertedIntersect: function(intersects2) {
    let intersect;
    for (let i2 = 0; i2 < intersects2.length; i2++) {
      if (intersects2[i2].distance >= 0 && intersects2[i2].object && !intersects2[i2].object.passThrough) {
        if (intersects2[i2].object.entity && intersects2[i2].object.entity.passThrough) {
          continue;
        } else if (intersects2[i2].object.entity && !intersects2[i2].object.entity.passThrough) {
          intersect = intersects2[i2].object.entity;
          break;
        } else {
          intersect = intersects2[i2].object;
          break;
        }
      }
    }
    return intersect;
  },
  hideInfospot: function() {
    if (this.infospot) {
      this.infospot.onHoverEnd();
      this.infospot = void 0;
    }
  },
  toggleControlBar: function() {
    const { widget } = this;
    if (widget) {
      widget.dispatchEvent({ type: "control-bar-toggle" });
    }
  },
  onKeyDown: function(event) {
    if (this.options.output && this.options.output !== "none" && event.key === "Control") {
      this.OUTPUT_INFOSPOT = true;
    }
  },
  onKeyUp: function() {
    this.OUTPUT_INFOSPOT = false;
  },
  update: function() {
    Tween.update();
    this.updateCallbacks.forEach(function(callback) {
      callback();
    });
    this.control.update();
    this.scene.traverse(function(child) {
      if (child instanceof Infospot && child.element && (this.hoverObject === child || child.element.style.display !== "none" || child.element.left && child.element.left.style.display !== "none" || child.element.right && child.element.right.style.display !== "none")) {
        if (this.checkSpriteInViewport(child)) {
          const { x: x2, y } = this.getScreenVector(child.getWorldPosition(new Vector3()));
          child.translateElement(x2, y);
        } else {
          child.onDismiss();
        }
      }
    }.bind(this));
  },
  render: function() {
    if (this.mode === MODES.CARDBOARD || this.mode === MODES.STEREO) {
      this.renderer.clear();
      this.effect.render(this.scene, this.camera);
      this.effect.render(this.sceneReticle, this.camera);
    } else {
      this.renderer.clear();
      this.renderer.render(this.scene, this.camera);
      this.renderer.clearDepth();
      this.renderer.render(this.sceneReticle, this.camera);
    }
  },
  animate: function() {
    this.requestAnimationId = window.requestAnimationFrame(this.animate.bind(this));
    this.onChange();
  },
  onChange: function() {
    this.update();
    this.render();
  },
  registerMouseAndTouchEvents: function() {
    const options = { passive: false };
    this.container.addEventListener("mousedown", this.HANDLER_MOUSE_DOWN, options);
    this.container.addEventListener("mousemove", this.HANDLER_MOUSE_MOVE, options);
    this.container.addEventListener("mouseup", this.HANDLER_MOUSE_UP, options);
    this.container.addEventListener("touchstart", this.HANDLER_MOUSE_DOWN, options);
    this.container.addEventListener("touchend", this.HANDLER_MOUSE_UP, options);
  },
  unregisterMouseAndTouchEvents: function() {
    this.container.removeEventListener("mousedown", this.HANDLER_MOUSE_DOWN, false);
    this.container.removeEventListener("mousemove", this.HANDLER_MOUSE_MOVE, false);
    this.container.removeEventListener("mouseup", this.HANDLER_MOUSE_UP, false);
    this.container.removeEventListener("touchstart", this.HANDLER_MOUSE_DOWN, false);
    this.container.removeEventListener("touchend", this.HANDLER_MOUSE_UP, false);
  },
  registerReticleEvent: function() {
    this.addUpdateCallback(this.HANDLER_TAP);
  },
  unregisterReticleEvent: function() {
    this.removeUpdateCallback(this.HANDLER_TAP);
  },
  updateReticleEvent: function() {
    const clientX = this.container.clientWidth / 2 + this.container.offsetLeft;
    const clientY = this.container.clientHeight / 2;
    this.removeUpdateCallback(this.HANDLER_TAP);
    this.HANDLER_TAP = this.onTap.bind(this, { clientX, clientY });
    this.addUpdateCallback(this.HANDLER_TAP);
  },
  registerEventListeners: function() {
    window.addEventListener("resize", this.HANDLER_WINDOW_RESIZE, true);
    window.addEventListener("keydown", this.HANDLER_KEY_DOWN, true);
    window.addEventListener("keyup", this.HANDLER_KEY_UP, true);
  },
  unregisterEventListeners: function() {
    window.removeEventListener("resize", this.HANDLER_WINDOW_RESIZE, true);
    window.removeEventListener("keydown", this.HANDLER_KEY_DOWN, true);
    window.removeEventListener("keyup", this.HANDLER_KEY_UP, true);
  },
  dispose: function() {
    this.tweenLeftAnimation.stop();
    this.tweenUpAnimation.stop();
    this.unregisterEventListeners();
    function recursiveDispose(object) {
      for (let i2 = object.children.length - 1; i2 >= 0; i2--) {
        recursiveDispose(object.children[i2]);
        object.remove(object.children[i2]);
      }
      if (object instanceof Panorama || object instanceof Infospot) {
        object.dispose();
        object = null;
      } else if (object.dispatchEvent) {
        object.dispatchEvent("dispose");
      }
    }
    recursiveDispose(this.scene);
    if (this.widget) {
      this.widget.dispose();
      this.widget = null;
    }
    if (Cache && Cache.enabled) {
      Cache.clear();
    }
  },
  destroy: function() {
    this.dispose();
    this.render();
    window.cancelAnimationFrame(this.requestAnimationId);
  },
  onPanoramaDispose: function(panorama) {
    if (panorama instanceof VideoPanorama) {
      this.hideVideoWidget();
    }
    if (panorama === this.panorama) {
      this.panorama = null;
    }
  },
  loadAsyncRequest: function(url, callback = () => {
  }) {
    const request = new window.XMLHttpRequest();
    request.onloadend = function(event) {
      callback(event);
    };
    request.open("GET", url, true);
    request.send(null);
  },
  addViewIndicator: function() {
    const scope = this;
    function loadViewIndicator(asyncEvent) {
      if (asyncEvent.loaded === 0)
        return;
      const viewIndicatorDiv = asyncEvent.target.responseXML.documentElement;
      viewIndicatorDiv.style.width = scope.viewIndicatorSize + "px";
      viewIndicatorDiv.style.height = scope.viewIndicatorSize + "px";
      viewIndicatorDiv.style.position = "absolute";
      viewIndicatorDiv.style.top = "10px";
      viewIndicatorDiv.style.left = "10px";
      viewIndicatorDiv.style.opacity = "0.5";
      viewIndicatorDiv.style.cursor = "pointer";
      viewIndicatorDiv.id = "panolens-view-indicator-container";
      scope.container.appendChild(viewIndicatorDiv);
      const indicator = viewIndicatorDiv.querySelector("#indicator");
      const setIndicatorD = function() {
        scope.radius = scope.viewIndicatorSize * 0.225;
        scope.currentPanoAngle = scope.camera.rotation.y - _Math.degToRad(90);
        scope.fovAngle = _Math.degToRad(scope.camera.fov);
        scope.leftAngle = -scope.currentPanoAngle - scope.fovAngle / 2;
        scope.rightAngle = -scope.currentPanoAngle + scope.fovAngle / 2;
        scope.leftX = scope.radius * Math.cos(scope.leftAngle);
        scope.leftY = scope.radius * Math.sin(scope.leftAngle);
        scope.rightX = scope.radius * Math.cos(scope.rightAngle);
        scope.rightY = scope.radius * Math.sin(scope.rightAngle);
        scope.indicatorD = "M " + scope.leftX + " " + scope.leftY + " A " + scope.radius + " " + scope.radius + " 0 0 1 " + scope.rightX + " " + scope.rightY;
        if (scope.leftX && scope.leftY && scope.rightX && scope.rightY && scope.radius) {
          indicator.setAttribute("d", scope.indicatorD);
        }
      };
      scope.addUpdateCallback(setIndicatorD);
      const indicatorOnMouseEnter = function() {
        this.style.opacity = "1";
      };
      const indicatorOnMouseLeave = function() {
        this.style.opacity = "0.5";
      };
      viewIndicatorDiv.addEventListener("mouseenter", indicatorOnMouseEnter);
      viewIndicatorDiv.addEventListener("mouseleave", indicatorOnMouseLeave);
    }
    this.loadAsyncRequest(DataImage.ViewIndicator, loadViewIndicator);
  },
  appendControlItem: function(option) {
    const item = this.widget.createCustomItem(option);
    if (option.group === "video") {
      this.widget.videoElement.appendChild(item);
    } else {
      this.widget.barElement.appendChild(item);
    }
    return item;
  },
  clearAllCache: function() {
    Cache.clear();
  }
});
if (REVISION$1 != THREE_REVISION) {
  console.warn(`three.js version is not matched. Please consider use the target revision ${THREE_REVISION}`);
}
window.TWEEN = Tween;
exports.BasicPanorama = BasicPanorama;
exports.CONTROLS = CONTROLS;
exports.CameraPanorama = CameraPanorama;
exports.CubePanorama = CubePanorama;
exports.CubeTextureLoader = CubeTextureLoader;
exports.DataImage = DataImage;
exports.EmptyPanorama = EmptyPanorama;
exports.GoogleStreetviewPanorama = GoogleStreetviewPanorama;
exports.ImageLittlePlanet = ImageLittlePlanet;
exports.ImageLoader = ImageLoader;
exports.ImagePanorama = ImagePanorama;
exports.Infospot = Infospot;
exports.LittlePlanet = LittlePlanet;
exports.MODES = MODES;
exports.Media = Media;
exports.Panorama = Panorama;
exports.REVISION = REVISION;
exports.Reticle = Reticle;
exports.THREE_REVISION = THREE_REVISION;
exports.THREE_VERSION = THREE_VERSION;
exports.TextureLoader = TextureLoader;
exports.VERSION = VERSION;
exports.VideoPanorama = VideoPanorama;
exports.Viewer = Viewer;
exports.Widget = Widget;
Object.defineProperty(exports, "__esModule", { value: true });
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __getProtoOf$1 = Object.getPrototypeOf;
var __reflectGet$1 = Reflect.get;
var __decorateClass$2 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$2(target, key, result);
  return result;
};
var __superStaticGet$1 = (obj, member) => __reflectGet$1(__getProtoOf$1(obj), member, obj);
let QyViewerPanorama = class extends QyViewerBase {
  constructor() {
    super(...arguments);
    this.viewer = null;
    this.panorama = null;
  }
  open(imgUrl) {
    if (!this.viewer) {
      const viewerEl = this.shadowRoot.querySelector(".viewer");
      this.viewer = new exports.Viewer({ container: viewerEl });
    }
    this.panorama = new exports.ImagePanorama(imgUrl);
    this.viewer.add(this.panorama);
    this.viewer.setPanorama(this.panorama);
    super.open(imgUrl);
  }
  close() {
    this.panorama.dispose();
    this.viewer.remove(this.panorama);
    this.panorama = null;
    super.close();
  }
};
QyViewerPanorama.styles = r$2`
    ${__superStaticGet$1(QyViewerPanorama, "styles")}

    .img_template {
      display: none;
    }
  `;
__decorateClass$2([
  e()
], QyViewerPanorama.prototype, "viewer", 2);
__decorateClass$2([
  e()
], QyViewerPanorama.prototype, "panorama", 2);
QyViewerPanorama = __decorateClass$2([
  n$1("qy-viewer-panorama")
], QyViewerPanorama);
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getProtoOf = Object.getPrototypeOf;
var __reflectGet = Reflect.get;
var __decorateClass$1 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$1(target, key, result);
  return result;
};
var __superStaticGet = (obj, member) => __reflectGet(__getProtoOf(obj), member, obj);
let QyViewerYoutube = class extends QyViewerBase {
  open(imgUrl) {
    const iframeEl = this.shadowRoot.querySelector(".iframe");
    iframeEl.src = imgUrl;
    super.open(imgUrl);
  }
  close() {
    const iframeEl = this.shadowRoot.querySelector(".iframe");
    iframeEl.src = "";
    super.close();
  }
  renderViewer() {
    return $$1`<iframe class="iframe">`;
  }
};
QyViewerYoutube.styles = r$2`
    ${__superStaticGet(QyViewerYoutube, "styles")}

    .iframe{
      position: relative;
      width: 100%;
      height: 100%;
      border: 0;
    }
  `;
QyViewerYoutube = __decorateClass$1([
  n$1("qy-viewer-youtube")
], QyViewerYoutube);
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp2(target, key, result);
  return result;
};
const typeHashes = {
  image: "qy-viewer-image",
  panorama: "qy-viewer-panorama",
  youtube: "qy-viewer-youtube"
};
let QyViewer = class extends s {
  open(imgUrl, type) {
    const targetTag = typeHashes[type];
    const handler = this.shadowRoot.querySelector(targetTag);
    handler.open(imgUrl);
  }
  firstUpdated() {
    const event = new CustomEvent("load");
    this.dispatchEvent(event);
  }
  render() {
    return $$1`
      <style>
        :host {
          --qy-viewer-z-index: 1000;
        }
        
        qy-viewer-panorama, qy-viewer-image, qy-viewer-youtube {
          --qy-viewer-z-index-each: var(--qy-viewer-z-index);
        }
      </style>
      <qy-viewer-image></qy-viewer-image>
      <qy-viewer-youtube></qy-viewer-youtube>
      <qy-viewer-panorama></qy-viewer-panorama>
    `;
  }
};
QyViewer = __decorateClass([
  n$1("qy-viewer")
], QyViewer);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var nunjucks$1 = { exports: {} };
/*! Browser bundle of nunjucks 3.2.3  */
(function(module, exports2) {
  (function webpackUniversalModuleDefinition(root, factory) {
    module.exports = factory();
  })(typeof self !== "undefined" ? self : commonjsGlobal, function() {
    return function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module2 = installedModules[moduleId] = {
          i: moduleId,
          l: false,
          exports: {}
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.l = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports3, name, getter) {
        if (!__webpack_require__.o(exports3, name)) {
          Object.defineProperty(exports3, name, {
            configurable: false,
            enumerable: true,
            get: getter
          });
        }
      };
      __webpack_require__.n = function(module2) {
        var getter = module2 && module2.__esModule ? function getDefault() {
          return module2["default"];
        } : function getModuleExports() {
          return module2;
        };
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = 11);
    }([
      function(module2, exports3, __webpack_require__) {
        var ArrayProto = Array.prototype;
        var ObjProto = Object.prototype;
        var escapeMap = {
          "&": "&amp;",
          '"': "&quot;",
          "'": "&#39;",
          "<": "&lt;",
          ">": "&gt;"
        };
        var escapeRegex = /[&"'<>]/g;
        var exports3 = module2.exports = {};
        function hasOwnProp(obj, k2) {
          return ObjProto.hasOwnProperty.call(obj, k2);
        }
        exports3.hasOwnProp = hasOwnProp;
        function lookupEscape(ch) {
          return escapeMap[ch];
        }
        function _prettifyError(path, withInternals, err) {
          if (!err.Update) {
            err = new exports3.TemplateError(err);
          }
          err.Update(path);
          if (!withInternals) {
            var old = err;
            err = new Error(old.message);
            err.name = old.name;
          }
          return err;
        }
        exports3._prettifyError = _prettifyError;
        function TemplateError(message, lineno, colno) {
          var err;
          var cause;
          if (message instanceof Error) {
            cause = message;
            message = cause.name + ": " + cause.message;
          }
          if (Object.setPrototypeOf) {
            err = new Error(message);
            Object.setPrototypeOf(err, TemplateError.prototype);
          } else {
            err = this;
            Object.defineProperty(err, "message", {
              enumerable: false,
              writable: true,
              value: message
            });
          }
          Object.defineProperty(err, "name", {
            value: "Template render error"
          });
          if (Error.captureStackTrace) {
            Error.captureStackTrace(err, this.constructor);
          }
          var getStack;
          if (cause) {
            var stackDescriptor = Object.getOwnPropertyDescriptor(cause, "stack");
            getStack = stackDescriptor && (stackDescriptor.get || function() {
              return stackDescriptor.value;
            });
            if (!getStack) {
              getStack = function getStack2() {
                return cause.stack;
              };
            }
          } else {
            var stack = new Error(message).stack;
            getStack = function getStack2() {
              return stack;
            };
          }
          Object.defineProperty(err, "stack", {
            get: function get() {
              return getStack.call(err);
            }
          });
          Object.defineProperty(err, "cause", {
            value: cause
          });
          err.lineno = lineno;
          err.colno = colno;
          err.firstUpdate = true;
          err.Update = function Update(path) {
            var msg = "(" + (path || "unknown path") + ")";
            if (this.firstUpdate) {
              if (this.lineno && this.colno) {
                msg += " [Line " + this.lineno + ", Column " + this.colno + "]";
              } else if (this.lineno) {
                msg += " [Line " + this.lineno + "]";
              }
            }
            msg += "\n ";
            if (this.firstUpdate) {
              msg += " ";
            }
            this.message = msg + (this.message || "");
            this.firstUpdate = false;
            return this;
          };
          return err;
        }
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(TemplateError.prototype, Error.prototype);
        } else {
          TemplateError.prototype = Object.create(Error.prototype, {
            constructor: {
              value: TemplateError
            }
          });
        }
        exports3.TemplateError = TemplateError;
        function escape2(val) {
          return val.replace(escapeRegex, lookupEscape);
        }
        exports3.escape = escape2;
        function isFunction2(obj) {
          return ObjProto.toString.call(obj) === "[object Function]";
        }
        exports3.isFunction = isFunction2;
        function isArray(obj) {
          return ObjProto.toString.call(obj) === "[object Array]";
        }
        exports3.isArray = isArray;
        function isString2(obj) {
          return ObjProto.toString.call(obj) === "[object String]";
        }
        exports3.isString = isString2;
        function isObject2(obj) {
          return ObjProto.toString.call(obj) === "[object Object]";
        }
        exports3.isObject = isObject2;
        function _prepareAttributeParts(attr2) {
          if (!attr2) {
            return [];
          }
          if (typeof attr2 === "string") {
            return attr2.split(".");
          }
          return [attr2];
        }
        function getAttrGetter(attribute) {
          var parts = _prepareAttributeParts(attribute);
          return function attrGetter(item) {
            var _item = item;
            for (var i2 = 0; i2 < parts.length; i2++) {
              var part = parts[i2];
              if (hasOwnProp(_item, part)) {
                _item = _item[part];
              } else {
                return void 0;
              }
            }
            return _item;
          };
        }
        exports3.getAttrGetter = getAttrGetter;
        function groupBy(obj, val, throwOnUndefined) {
          var result = {};
          var iterator = isFunction2(val) ? val : getAttrGetter(val);
          for (var i2 = 0; i2 < obj.length; i2++) {
            var value = obj[i2];
            var key = iterator(value, i2);
            if (key === void 0 && throwOnUndefined === true) {
              throw new TypeError('groupby: attribute "' + val + '" resolved to undefined');
            }
            (result[key] || (result[key] = [])).push(value);
          }
          return result;
        }
        exports3.groupBy = groupBy;
        function toArray(obj) {
          return Array.prototype.slice.call(obj);
        }
        exports3.toArray = toArray;
        function without(array) {
          var result = [];
          if (!array) {
            return result;
          }
          var length = array.length;
          var contains = toArray(arguments).slice(1);
          var index2 = -1;
          while (++index2 < length) {
            if (indexOf(contains, array[index2]) === -1) {
              result.push(array[index2]);
            }
          }
          return result;
        }
        exports3.without = without;
        function repeat(char_, n2) {
          var str = "";
          for (var i2 = 0; i2 < n2; i2++) {
            str += char_;
          }
          return str;
        }
        exports3.repeat = repeat;
        function each2(obj, func, context2) {
          if (obj == null) {
            return;
          }
          if (ArrayProto.forEach && obj.forEach === ArrayProto.forEach) {
            obj.forEach(func, context2);
          } else if (obj.length === +obj.length) {
            for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
              func.call(context2, obj[i2], i2, obj);
            }
          }
        }
        exports3.each = each2;
        function map(obj, func) {
          var results = [];
          if (obj == null) {
            return results;
          }
          if (ArrayProto.map && obj.map === ArrayProto.map) {
            return obj.map(func);
          }
          for (var i2 = 0; i2 < obj.length; i2++) {
            results[results.length] = func(obj[i2], i2);
          }
          if (obj.length === +obj.length) {
            results.length = obj.length;
          }
          return results;
        }
        exports3.map = map;
        function asyncIter(arr, iter, cb) {
          var i2 = -1;
          function next3() {
            i2++;
            if (i2 < arr.length) {
              iter(arr[i2], i2, next3, cb);
            } else {
              cb();
            }
          }
          next3();
        }
        exports3.asyncIter = asyncIter;
        function asyncFor(obj, iter, cb) {
          var keys = keys_(obj || {});
          var len = keys.length;
          var i2 = -1;
          function next3() {
            i2++;
            var k2 = keys[i2];
            if (i2 < len) {
              iter(k2, obj[k2], i2, len, next3);
            } else {
              cb();
            }
          }
          next3();
        }
        exports3.asyncFor = asyncFor;
        function indexOf(arr, searchElement, fromIndex) {
          return Array.prototype.indexOf.call(arr || [], searchElement, fromIndex);
        }
        exports3.indexOf = indexOf;
        function keys_(obj) {
          var arr = [];
          for (var k2 in obj) {
            if (hasOwnProp(obj, k2)) {
              arr.push(k2);
            }
          }
          return arr;
        }
        exports3.keys = keys_;
        function _entries(obj) {
          return keys_(obj).map(function(k2) {
            return [k2, obj[k2]];
          });
        }
        exports3._entries = _entries;
        function _values(obj) {
          return keys_(obj).map(function(k2) {
            return obj[k2];
          });
        }
        exports3._values = _values;
        function extend2(obj1, obj2) {
          obj1 = obj1 || {};
          keys_(obj2).forEach(function(k2) {
            obj1[k2] = obj2[k2];
          });
          return obj1;
        }
        exports3._assign = exports3.extend = extend2;
        function inOperator(key, val) {
          if (isArray(val) || isString2(val)) {
            return val.indexOf(key) !== -1;
          } else if (isObject2(val)) {
            return key in val;
          }
          throw new Error('Cannot use "in" operator to search for "' + key + '" in unexpected types.');
        }
        exports3.inOperator = inOperator;
      },
      function(module2, exports3, __webpack_require__) {
        function _defineProperties2(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o2, p2) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
            o3.__proto__ = p3;
            return o3;
          };
          return _setPrototypeOf(o2, p2);
        }
        var EventEmitter = __webpack_require__(16);
        var lib = __webpack_require__(0);
        function parentWrap(parent2, prop) {
          if (typeof parent2 !== "function" || typeof prop !== "function") {
            return prop;
          }
          return function wrap() {
            var tmp2 = this.parent;
            this.parent = parent2;
            var res = prop.apply(this, arguments);
            this.parent = tmp2;
            return res;
          };
        }
        function extendClass(cls, name, props) {
          props = props || {};
          lib.keys(props).forEach(function(k2) {
            props[k2] = parentWrap(cls.prototype[k2], props[k2]);
          });
          var subclass = /* @__PURE__ */ function(_cls) {
            _inheritsLoose(subclass2, _cls);
            function subclass2() {
              return _cls.apply(this, arguments) || this;
            }
            _createClass2(subclass2, [{
              key: "typename",
              get: function get() {
                return name;
              }
            }]);
            return subclass2;
          }(cls);
          lib._assign(subclass.prototype, props);
          return subclass;
        }
        var Obj = /* @__PURE__ */ function() {
          function Obj2() {
            this.init.apply(this, arguments);
          }
          var _proto = Obj2.prototype;
          _proto.init = function init() {
          };
          Obj2.extend = function extend2(name, props) {
            if (typeof name === "object") {
              props = name;
              name = "anonymous";
            }
            return extendClass(this, name, props);
          };
          _createClass2(Obj2, [{
            key: "typename",
            get: function get() {
              return this.constructor.name;
            }
          }]);
          return Obj2;
        }();
        var EmitterObj = /* @__PURE__ */ function(_EventEmitter) {
          _inheritsLoose(EmitterObj2, _EventEmitter);
          function EmitterObj2() {
            var _this2;
            var _this;
            _this = _EventEmitter.call(this) || this;
            (_this2 = _this).init.apply(_this2, arguments);
            return _this;
          }
          var _proto2 = EmitterObj2.prototype;
          _proto2.init = function init() {
          };
          EmitterObj2.extend = function extend2(name, props) {
            if (typeof name === "object") {
              props = name;
              name = "anonymous";
            }
            return extendClass(this, name, props);
          };
          _createClass2(EmitterObj2, [{
            key: "typename",
            get: function get() {
              return this.constructor.name;
            }
          }]);
          return EmitterObj2;
        }(EventEmitter);
        module2.exports = {
          Obj,
          EmitterObj
        };
      },
      function(module2, exports3, __webpack_require__) {
        var lib = __webpack_require__(0);
        var arrayFrom = Array.from;
        var supportsIterators = typeof Symbol === "function" && Symbol.iterator && typeof arrayFrom === "function";
        var Frame = /* @__PURE__ */ function() {
          function Frame2(parent2, isolateWrites) {
            this.variables = Object.create(null);
            this.parent = parent2;
            this.topLevel = false;
            this.isolateWrites = isolateWrites;
          }
          var _proto = Frame2.prototype;
          _proto.set = function set(name, val, resolveUp) {
            var parts = name.split(".");
            var obj = this.variables;
            var frame = this;
            if (resolveUp) {
              if (frame = this.resolve(parts[0], true)) {
                frame.set(name, val);
                return;
              }
            }
            for (var i2 = 0; i2 < parts.length - 1; i2++) {
              var id = parts[i2];
              if (!obj[id]) {
                obj[id] = {};
              }
              obj = obj[id];
            }
            obj[parts[parts.length - 1]] = val;
          };
          _proto.get = function get(name) {
            var val = this.variables[name];
            if (val !== void 0) {
              return val;
            }
            return null;
          };
          _proto.lookup = function lookup(name) {
            var p2 = this.parent;
            var val = this.variables[name];
            if (val !== void 0) {
              return val;
            }
            return p2 && p2.lookup(name);
          };
          _proto.resolve = function resolve(name, forWrite) {
            var p2 = forWrite && this.isolateWrites ? void 0 : this.parent;
            var val = this.variables[name];
            if (val !== void 0) {
              return this;
            }
            return p2 && p2.resolve(name);
          };
          _proto.push = function push(isolateWrites) {
            return new Frame2(this, isolateWrites);
          };
          _proto.pop = function pop() {
            return this.parent;
          };
          return Frame2;
        }();
        function makeMacro(argNames, kwargNames, func) {
          return function macro() {
            for (var _len = arguments.length, macroArgs = new Array(_len), _key = 0; _key < _len; _key++) {
              macroArgs[_key] = arguments[_key];
            }
            var argCount = numArgs(macroArgs);
            var args;
            var kwargs = getKeywordArgs(macroArgs);
            if (argCount > argNames.length) {
              args = macroArgs.slice(0, argNames.length);
              macroArgs.slice(args.length, argCount).forEach(function(val, i3) {
                if (i3 < kwargNames.length) {
                  kwargs[kwargNames[i3]] = val;
                }
              });
              args.push(kwargs);
            } else if (argCount < argNames.length) {
              args = macroArgs.slice(0, argCount);
              for (var i2 = argCount; i2 < argNames.length; i2++) {
                var arg = argNames[i2];
                args.push(kwargs[arg]);
                delete kwargs[arg];
              }
              args.push(kwargs);
            } else {
              args = macroArgs;
            }
            return func.apply(this, args);
          };
        }
        function makeKeywordArgs(obj) {
          obj.__keywords = true;
          return obj;
        }
        function isKeywordArgs(obj) {
          return obj && Object.prototype.hasOwnProperty.call(obj, "__keywords");
        }
        function getKeywordArgs(args) {
          var len = args.length;
          if (len) {
            var lastArg = args[len - 1];
            if (isKeywordArgs(lastArg)) {
              return lastArg;
            }
          }
          return {};
        }
        function numArgs(args) {
          var len = args.length;
          if (len === 0) {
            return 0;
          }
          var lastArg = args[len - 1];
          if (isKeywordArgs(lastArg)) {
            return len - 1;
          } else {
            return len;
          }
        }
        function SafeString(val) {
          if (typeof val !== "string") {
            return val;
          }
          this.val = val;
          this.length = val.length;
        }
        SafeString.prototype = Object.create(String.prototype, {
          length: {
            writable: true,
            configurable: true,
            value: 0
          }
        });
        SafeString.prototype.valueOf = function valueOf() {
          return this.val;
        };
        SafeString.prototype.toString = function toString() {
          return this.val;
        };
        function copySafeness(dest, target) {
          if (dest instanceof SafeString) {
            return new SafeString(target);
          }
          return target.toString();
        }
        function markSafe(val) {
          var type = typeof val;
          if (type === "string") {
            return new SafeString(val);
          } else if (type !== "function") {
            return val;
          } else {
            return function wrapSafe(args) {
              var ret = val.apply(this, arguments);
              if (typeof ret === "string") {
                return new SafeString(ret);
              }
              return ret;
            };
          }
        }
        function suppressValue(val, autoescape) {
          val = val !== void 0 && val !== null ? val : "";
          if (autoescape && !(val instanceof SafeString)) {
            val = lib.escape(val.toString());
          }
          return val;
        }
        function ensureDefined(val, lineno, colno) {
          if (val === null || val === void 0) {
            throw new lib.TemplateError("attempted to output null or undefined value", lineno + 1, colno + 1);
          }
          return val;
        }
        function memberLookup(obj, val) {
          if (obj === void 0 || obj === null) {
            return void 0;
          }
          if (typeof obj[val] === "function") {
            return function() {
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }
              return obj[val].apply(obj, args);
            };
          }
          return obj[val];
        }
        function callWrap(obj, name, context2, args) {
          if (!obj) {
            throw new Error("Unable to call `" + name + "`, which is undefined or falsey");
          } else if (typeof obj !== "function") {
            throw new Error("Unable to call `" + name + "`, which is not a function");
          }
          return obj.apply(context2, args);
        }
        function contextOrFrameLookup(context2, frame, name) {
          var val = frame.lookup(name);
          return val !== void 0 ? val : context2.lookup(name);
        }
        function handleError(error, lineno, colno) {
          if (error.lineno) {
            return error;
          } else {
            return new lib.TemplateError(error, lineno, colno);
          }
        }
        function asyncEach(arr, dimen, iter, cb) {
          if (lib.isArray(arr)) {
            var len = arr.length;
            lib.asyncIter(arr, function iterCallback(item, i2, next3) {
              switch (dimen) {
                case 1:
                  iter(item, i2, len, next3);
                  break;
                case 2:
                  iter(item[0], item[1], i2, len, next3);
                  break;
                case 3:
                  iter(item[0], item[1], item[2], i2, len, next3);
                  break;
                default:
                  item.push(i2, len, next3);
                  iter.apply(this, item);
              }
            }, cb);
          } else {
            lib.asyncFor(arr, function iterCallback(key, val, i2, len2, next3) {
              iter(key, val, i2, len2, next3);
            }, cb);
          }
        }
        function asyncAll(arr, dimen, func, cb) {
          var finished = 0;
          var len;
          var outputArr;
          function done(i3, output) {
            finished++;
            outputArr[i3] = output;
            if (finished === len) {
              cb(null, outputArr.join(""));
            }
          }
          if (lib.isArray(arr)) {
            len = arr.length;
            outputArr = new Array(len);
            if (len === 0) {
              cb(null, "");
            } else {
              for (var i2 = 0; i2 < arr.length; i2++) {
                var item = arr[i2];
                switch (dimen) {
                  case 1:
                    func(item, i2, len, done);
                    break;
                  case 2:
                    func(item[0], item[1], i2, len, done);
                    break;
                  case 3:
                    func(item[0], item[1], item[2], i2, len, done);
                    break;
                  default:
                    item.push(i2, len, done);
                    func.apply(this, item);
                }
              }
            }
          } else {
            var keys = lib.keys(arr || {});
            len = keys.length;
            outputArr = new Array(len);
            if (len === 0) {
              cb(null, "");
            } else {
              for (var _i = 0; _i < keys.length; _i++) {
                var k2 = keys[_i];
                func(k2, arr[k2], _i, len, done);
              }
            }
          }
        }
        function fromIterator(arr) {
          if (typeof arr !== "object" || arr === null || lib.isArray(arr)) {
            return arr;
          } else if (supportsIterators && Symbol.iterator in arr) {
            return arrayFrom(arr);
          } else {
            return arr;
          }
        }
        module2.exports = {
          Frame,
          makeMacro,
          makeKeywordArgs,
          numArgs,
          suppressValue,
          ensureDefined,
          memberLookup,
          contextOrFrameLookup,
          callWrap,
          handleError,
          isArray: lib.isArray,
          keys: lib.keys,
          SafeString,
          copySafeness,
          markSafe,
          asyncEach,
          asyncAll,
          inOperator: lib.inOperator,
          fromIterator
        };
      },
      function(module2, exports3, __webpack_require__) {
        function _defineProperties2(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o2, p2) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
            o3.__proto__ = p3;
            return o3;
          };
          return _setPrototypeOf(o2, p2);
        }
        var _require = __webpack_require__(1), Obj = _require.Obj;
        function traverseAndCheck(obj, type, results) {
          if (obj instanceof type) {
            results.push(obj);
          }
          if (obj instanceof Node2) {
            obj.findAll(type, results);
          }
        }
        var Node2 = /* @__PURE__ */ function(_Obj) {
          _inheritsLoose(Node3, _Obj);
          function Node3() {
            return _Obj.apply(this, arguments) || this;
          }
          var _proto = Node3.prototype;
          _proto.init = function init(lineno, colno) {
            var _arguments = arguments, _this = this;
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            this.lineno = lineno;
            this.colno = colno;
            this.fields.forEach(function(field, i2) {
              var val = _arguments[i2 + 2];
              if (val === void 0) {
                val = null;
              }
              _this[field] = val;
            });
          };
          _proto.findAll = function findAll(type, results) {
            var _this2 = this;
            results = results || [];
            if (this instanceof NodeList) {
              this.children.forEach(function(child) {
                return traverseAndCheck(child, type, results);
              });
            } else {
              this.fields.forEach(function(field) {
                return traverseAndCheck(_this2[field], type, results);
              });
            }
            return results;
          };
          _proto.iterFields = function iterFields(func) {
            var _this3 = this;
            this.fields.forEach(function(field) {
              func(_this3[field], field);
            });
          };
          return Node3;
        }(Obj);
        var Value = /* @__PURE__ */ function(_Node) {
          _inheritsLoose(Value2, _Node);
          function Value2() {
            return _Node.apply(this, arguments) || this;
          }
          _createClass2(Value2, [{
            key: "typename",
            get: function get() {
              return "Value";
            }
          }, {
            key: "fields",
            get: function get() {
              return ["value"];
            }
          }]);
          return Value2;
        }(Node2);
        var NodeList = /* @__PURE__ */ function(_Node2) {
          _inheritsLoose(NodeList2, _Node2);
          function NodeList2() {
            return _Node2.apply(this, arguments) || this;
          }
          var _proto2 = NodeList2.prototype;
          _proto2.init = function init(lineno, colno, nodes) {
            _Node2.prototype.init.call(this, lineno, colno, nodes || []);
          };
          _proto2.addChild = function addChild(node) {
            this.children.push(node);
          };
          _createClass2(NodeList2, [{
            key: "typename",
            get: function get() {
              return "NodeList";
            }
          }, {
            key: "fields",
            get: function get() {
              return ["children"];
            }
          }]);
          return NodeList2;
        }(Node2);
        var Root = NodeList.extend("Root");
        var Literal = Value.extend("Literal");
        var Symbol2 = Value.extend("Symbol");
        var Group2 = NodeList.extend("Group");
        var ArrayNode = NodeList.extend("Array");
        var Pair = Node2.extend("Pair", {
          fields: ["key", "value"]
        });
        var Dict = NodeList.extend("Dict");
        var LookupVal = Node2.extend("LookupVal", {
          fields: ["target", "val"]
        });
        var If = Node2.extend("If", {
          fields: ["cond", "body", "else_"]
        });
        var IfAsync = If.extend("IfAsync");
        var InlineIf = Node2.extend("InlineIf", {
          fields: ["cond", "body", "else_"]
        });
        var For = Node2.extend("For", {
          fields: ["arr", "name", "body", "else_"]
        });
        var AsyncEach = For.extend("AsyncEach");
        var AsyncAll = For.extend("AsyncAll");
        var Macro = Node2.extend("Macro", {
          fields: ["name", "args", "body"]
        });
        var Caller = Macro.extend("Caller");
        var Import = Node2.extend("Import", {
          fields: ["template", "target", "withContext"]
        });
        var FromImport = /* @__PURE__ */ function(_Node3) {
          _inheritsLoose(FromImport2, _Node3);
          function FromImport2() {
            return _Node3.apply(this, arguments) || this;
          }
          var _proto3 = FromImport2.prototype;
          _proto3.init = function init(lineno, colno, template, names, withContext) {
            _Node3.prototype.init.call(this, lineno, colno, template, names || new NodeList(), withContext);
          };
          _createClass2(FromImport2, [{
            key: "typename",
            get: function get() {
              return "FromImport";
            }
          }, {
            key: "fields",
            get: function get() {
              return ["template", "names", "withContext"];
            }
          }]);
          return FromImport2;
        }(Node2);
        var FunCall = Node2.extend("FunCall", {
          fields: ["name", "args"]
        });
        var Filter = FunCall.extend("Filter");
        var FilterAsync = Filter.extend("FilterAsync", {
          fields: ["name", "args", "symbol"]
        });
        var KeywordArgs = Dict.extend("KeywordArgs");
        var Block = Node2.extend("Block", {
          fields: ["name", "body"]
        });
        var Super = Node2.extend("Super", {
          fields: ["blockName", "symbol"]
        });
        var TemplateRef = Node2.extend("TemplateRef", {
          fields: ["template"]
        });
        var Extends = TemplateRef.extend("Extends");
        var Include = Node2.extend("Include", {
          fields: ["template", "ignoreMissing"]
        });
        var Set2 = Node2.extend("Set", {
          fields: ["targets", "value"]
        });
        var Switch = Node2.extend("Switch", {
          fields: ["expr", "cases", "default"]
        });
        var Case = Node2.extend("Case", {
          fields: ["cond", "body"]
        });
        var Output = NodeList.extend("Output");
        var Capture = Node2.extend("Capture", {
          fields: ["body"]
        });
        var TemplateData = Literal.extend("TemplateData");
        var UnaryOp = Node2.extend("UnaryOp", {
          fields: ["target"]
        });
        var BinOp = Node2.extend("BinOp", {
          fields: ["left", "right"]
        });
        var In = BinOp.extend("In");
        var Is = BinOp.extend("Is");
        var Or = BinOp.extend("Or");
        var And = BinOp.extend("And");
        var Not = UnaryOp.extend("Not");
        var Add = BinOp.extend("Add");
        var Concat = BinOp.extend("Concat");
        var Sub = BinOp.extend("Sub");
        var Mul = BinOp.extend("Mul");
        var Div = BinOp.extend("Div");
        var FloorDiv = BinOp.extend("FloorDiv");
        var Mod = BinOp.extend("Mod");
        var Pow = BinOp.extend("Pow");
        var Neg = UnaryOp.extend("Neg");
        var Pos = UnaryOp.extend("Pos");
        var Compare = Node2.extend("Compare", {
          fields: ["expr", "ops"]
        });
        var CompareOperand = Node2.extend("CompareOperand", {
          fields: ["expr", "type"]
        });
        var CallExtension = Node2.extend("CallExtension", {
          init: function init(ext, prop, args, contentArgs) {
            this.parent();
            this.extName = ext.__name || ext;
            this.prop = prop;
            this.args = args || new NodeList();
            this.contentArgs = contentArgs || [];
            this.autoescape = ext.autoescape;
          },
          fields: ["extName", "prop", "args", "contentArgs"]
        });
        var CallExtensionAsync = CallExtension.extend("CallExtensionAsync");
        function print(str, indent, inline) {
          var lines = str.split("\n");
          lines.forEach(function(line, i2) {
            if (line && (inline && i2 > 0 || !inline)) {
              process.stdout.write(" ".repeat(indent));
            }
            var nl = i2 === lines.length - 1 ? "" : "\n";
            process.stdout.write("" + line + nl);
          });
        }
        function printNodes(node, indent) {
          indent = indent || 0;
          print(node.typename + ": ", indent);
          if (node instanceof NodeList) {
            print("\n");
            node.children.forEach(function(n2) {
              printNodes(n2, indent + 2);
            });
          } else if (node instanceof CallExtension) {
            print(node.extName + "." + node.prop + "\n");
            if (node.args) {
              printNodes(node.args, indent + 2);
            }
            if (node.contentArgs) {
              node.contentArgs.forEach(function(n2) {
                printNodes(n2, indent + 2);
              });
            }
          } else {
            var nodes = [];
            var props = null;
            node.iterFields(function(val, fieldName) {
              if (val instanceof Node2) {
                nodes.push([fieldName, val]);
              } else {
                props = props || {};
                props[fieldName] = val;
              }
            });
            if (props) {
              print(JSON.stringify(props, null, 2) + "\n", null, true);
            } else {
              print("\n");
            }
            nodes.forEach(function(_ref) {
              var fieldName = _ref[0], n2 = _ref[1];
              print("[" + fieldName + "] =>", indent + 2);
              printNodes(n2, indent + 4);
            });
          }
        }
        module2.exports = {
          Node: Node2,
          Root,
          NodeList,
          Value,
          Literal,
          Symbol: Symbol2,
          Group: Group2,
          Array: ArrayNode,
          Pair,
          Dict,
          Output,
          Capture,
          TemplateData,
          If,
          IfAsync,
          InlineIf,
          For,
          AsyncEach,
          AsyncAll,
          Macro,
          Caller,
          Import,
          FromImport,
          FunCall,
          Filter,
          FilterAsync,
          KeywordArgs,
          Block,
          Super,
          Extends,
          Include,
          Set: Set2,
          Switch,
          Case,
          LookupVal,
          BinOp,
          In,
          Is,
          Or,
          And,
          Not,
          Add,
          Concat,
          Sub,
          Mul,
          Div,
          FloorDiv,
          Mod,
          Pow,
          Neg,
          Pos,
          Compare,
          CompareOperand,
          CallExtension,
          CallExtensionAsync,
          printNodes
        };
      },
      function(module2, exports3) {
      },
      function(module2, exports3, __webpack_require__) {
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o2, p2) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
            o3.__proto__ = p3;
            return o3;
          };
          return _setPrototypeOf(o2, p2);
        }
        var parser = __webpack_require__(8);
        var transformer = __webpack_require__(17);
        var nodes = __webpack_require__(3);
        var _require = __webpack_require__(0), TemplateError = _require.TemplateError;
        var _require2 = __webpack_require__(2), Frame = _require2.Frame;
        var _require3 = __webpack_require__(1), Obj = _require3.Obj;
        var compareOps = {
          "==": "==",
          "===": "===",
          "!=": "!=",
          "!==": "!==",
          "<": "<",
          ">": ">",
          "<=": "<=",
          ">=": ">="
        };
        var Compiler = /* @__PURE__ */ function(_Obj) {
          _inheritsLoose(Compiler2, _Obj);
          function Compiler2() {
            return _Obj.apply(this, arguments) || this;
          }
          var _proto = Compiler2.prototype;
          _proto.init = function init(templateName, throwOnUndefined) {
            this.templateName = templateName;
            this.codebuf = [];
            this.lastId = 0;
            this.buffer = null;
            this.bufferStack = [];
            this._scopeClosers = "";
            this.inBlock = false;
            this.throwOnUndefined = throwOnUndefined;
          };
          _proto.fail = function fail(msg, lineno, colno) {
            if (lineno !== void 0) {
              lineno += 1;
            }
            if (colno !== void 0) {
              colno += 1;
            }
            throw new TemplateError(msg, lineno, colno);
          };
          _proto._pushBuffer = function _pushBuffer() {
            var id = this._tmpid();
            this.bufferStack.push(this.buffer);
            this.buffer = id;
            this._emit("var " + this.buffer + ' = "";');
            return id;
          };
          _proto._popBuffer = function _popBuffer() {
            this.buffer = this.bufferStack.pop();
          };
          _proto._emit = function _emit(code) {
            this.codebuf.push(code);
          };
          _proto._emitLine = function _emitLine(code) {
            this._emit(code + "\n");
          };
          _proto._emitLines = function _emitLines() {
            var _this = this;
            for (var _len = arguments.length, lines = new Array(_len), _key = 0; _key < _len; _key++) {
              lines[_key] = arguments[_key];
            }
            lines.forEach(function(line) {
              return _this._emitLine(line);
            });
          };
          _proto._emitFuncBegin = function _emitFuncBegin(node, name) {
            this.buffer = "output";
            this._scopeClosers = "";
            this._emitLine("function " + name + "(env, context, frame, runtime, cb) {");
            this._emitLine("var lineno = " + node.lineno + ";");
            this._emitLine("var colno = " + node.colno + ";");
            this._emitLine("var " + this.buffer + ' = "";');
            this._emitLine("try {");
          };
          _proto._emitFuncEnd = function _emitFuncEnd(noReturn) {
            if (!noReturn) {
              this._emitLine("cb(null, " + this.buffer + ");");
            }
            this._closeScopeLevels();
            this._emitLine("} catch (e) {");
            this._emitLine("  cb(runtime.handleError(e, lineno, colno));");
            this._emitLine("}");
            this._emitLine("}");
            this.buffer = null;
          };
          _proto._addScopeLevel = function _addScopeLevel() {
            this._scopeClosers += "})";
          };
          _proto._closeScopeLevels = function _closeScopeLevels() {
            this._emitLine(this._scopeClosers + ";");
            this._scopeClosers = "";
          };
          _proto._withScopedSyntax = function _withScopedSyntax(func) {
            var _scopeClosers = this._scopeClosers;
            this._scopeClosers = "";
            func.call(this);
            this._closeScopeLevels();
            this._scopeClosers = _scopeClosers;
          };
          _proto._makeCallback = function _makeCallback(res) {
            var err = this._tmpid();
            return "function(" + err + (res ? "," + res : "") + ") {\nif(" + err + ") { cb(" + err + "); return; }";
          };
          _proto._tmpid = function _tmpid() {
            this.lastId++;
            return "t_" + this.lastId;
          };
          _proto._templateName = function _templateName() {
            return this.templateName == null ? "undefined" : JSON.stringify(this.templateName);
          };
          _proto._compileChildren = function _compileChildren(node, frame) {
            var _this2 = this;
            node.children.forEach(function(child) {
              _this2.compile(child, frame);
            });
          };
          _proto._compileAggregate = function _compileAggregate(node, frame, startChar, endChar) {
            var _this3 = this;
            if (startChar) {
              this._emit(startChar);
            }
            node.children.forEach(function(child, i2) {
              if (i2 > 0) {
                _this3._emit(",");
              }
              _this3.compile(child, frame);
            });
            if (endChar) {
              this._emit(endChar);
            }
          };
          _proto._compileExpression = function _compileExpression(node, frame) {
            this.assertType(node, nodes.Literal, nodes.Symbol, nodes.Group, nodes.Array, nodes.Dict, nodes.FunCall, nodes.Caller, nodes.Filter, nodes.LookupVal, nodes.Compare, nodes.InlineIf, nodes.In, nodes.Is, nodes.And, nodes.Or, nodes.Not, nodes.Add, nodes.Concat, nodes.Sub, nodes.Mul, nodes.Div, nodes.FloorDiv, nodes.Mod, nodes.Pow, nodes.Neg, nodes.Pos, nodes.Compare, nodes.NodeList);
            this.compile(node, frame);
          };
          _proto.assertType = function assertType(node) {
            for (var _len2 = arguments.length, types = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              types[_key2 - 1] = arguments[_key2];
            }
            if (!types.some(function(t2) {
              return node instanceof t2;
            })) {
              this.fail("assertType: invalid type: " + node.typename, node.lineno, node.colno);
            }
          };
          _proto.compileCallExtension = function compileCallExtension(node, frame, async) {
            var _this4 = this;
            var args = node.args;
            var contentArgs = node.contentArgs;
            var autoescape = typeof node.autoescape === "boolean" ? node.autoescape : true;
            if (!async) {
              this._emit(this.buffer + " += runtime.suppressValue(");
            }
            this._emit('env.getExtension("' + node.extName + '")["' + node.prop + '"](');
            this._emit("context");
            if (args || contentArgs) {
              this._emit(",");
            }
            if (args) {
              if (!(args instanceof nodes.NodeList)) {
                this.fail("compileCallExtension: arguments must be a NodeList, use `parser.parseSignature`");
              }
              args.children.forEach(function(arg, i2) {
                _this4._compileExpression(arg, frame);
                if (i2 !== args.children.length - 1 || contentArgs.length) {
                  _this4._emit(",");
                }
              });
            }
            if (contentArgs.length) {
              contentArgs.forEach(function(arg, i2) {
                if (i2 > 0) {
                  _this4._emit(",");
                }
                if (arg) {
                  _this4._emitLine("function(cb) {");
                  _this4._emitLine("if(!cb) { cb = function(err) { if(err) { throw err; }}}");
                  var id = _this4._pushBuffer();
                  _this4._withScopedSyntax(function() {
                    _this4.compile(arg, frame);
                    _this4._emitLine("cb(null, " + id + ");");
                  });
                  _this4._popBuffer();
                  _this4._emitLine("return " + id + ";");
                  _this4._emitLine("}");
                } else {
                  _this4._emit("null");
                }
              });
            }
            if (async) {
              var res = this._tmpid();
              this._emitLine(", " + this._makeCallback(res));
              this._emitLine(this.buffer + " += runtime.suppressValue(" + res + ", " + autoescape + " && env.opts.autoescape);");
              this._addScopeLevel();
            } else {
              this._emit(")");
              this._emit(", " + autoescape + " && env.opts.autoescape);\n");
            }
          };
          _proto.compileCallExtensionAsync = function compileCallExtensionAsync(node, frame) {
            this.compileCallExtension(node, frame, true);
          };
          _proto.compileNodeList = function compileNodeList(node, frame) {
            this._compileChildren(node, frame);
          };
          _proto.compileLiteral = function compileLiteral(node) {
            if (typeof node.value === "string") {
              var val = node.value.replace(/\\/g, "\\\\");
              val = val.replace(/"/g, '\\"');
              val = val.replace(/\n/g, "\\n");
              val = val.replace(/\r/g, "\\r");
              val = val.replace(/\t/g, "\\t");
              val = val.replace(/\u2028/g, "\\u2028");
              this._emit('"' + val + '"');
            } else if (node.value === null) {
              this._emit("null");
            } else {
              this._emit(node.value.toString());
            }
          };
          _proto.compileSymbol = function compileSymbol(node, frame) {
            var name = node.value;
            var v2 = frame.lookup(name);
            if (v2) {
              this._emit(v2);
            } else {
              this._emit('runtime.contextOrFrameLookup(context, frame, "' + name + '")');
            }
          };
          _proto.compileGroup = function compileGroup(node, frame) {
            this._compileAggregate(node, frame, "(", ")");
          };
          _proto.compileArray = function compileArray(node, frame) {
            this._compileAggregate(node, frame, "[", "]");
          };
          _proto.compileDict = function compileDict(node, frame) {
            this._compileAggregate(node, frame, "{", "}");
          };
          _proto.compilePair = function compilePair(node, frame) {
            var key = node.key;
            var val = node.value;
            if (key instanceof nodes.Symbol) {
              key = new nodes.Literal(key.lineno, key.colno, key.value);
            } else if (!(key instanceof nodes.Literal && typeof key.value === "string")) {
              this.fail("compilePair: Dict keys must be strings or names", key.lineno, key.colno);
            }
            this.compile(key, frame);
            this._emit(": ");
            this._compileExpression(val, frame);
          };
          _proto.compileInlineIf = function compileInlineIf(node, frame) {
            this._emit("(");
            this.compile(node.cond, frame);
            this._emit("?");
            this.compile(node.body, frame);
            this._emit(":");
            if (node.else_ !== null) {
              this.compile(node.else_, frame);
            } else {
              this._emit('""');
            }
            this._emit(")");
          };
          _proto.compileIn = function compileIn(node, frame) {
            this._emit("runtime.inOperator(");
            this.compile(node.left, frame);
            this._emit(",");
            this.compile(node.right, frame);
            this._emit(")");
          };
          _proto.compileIs = function compileIs(node, frame) {
            var right = node.right.name ? node.right.name.value : node.right.value;
            this._emit('env.getTest("' + right + '").call(context, ');
            this.compile(node.left, frame);
            if (node.right.args) {
              this._emit(",");
              this.compile(node.right.args, frame);
            }
            this._emit(") === true");
          };
          _proto._binOpEmitter = function _binOpEmitter(node, frame, str) {
            this.compile(node.left, frame);
            this._emit(str);
            this.compile(node.right, frame);
          };
          _proto.compileOr = function compileOr(node, frame) {
            return this._binOpEmitter(node, frame, " || ");
          };
          _proto.compileAnd = function compileAnd(node, frame) {
            return this._binOpEmitter(node, frame, " && ");
          };
          _proto.compileAdd = function compileAdd(node, frame) {
            return this._binOpEmitter(node, frame, " + ");
          };
          _proto.compileConcat = function compileConcat(node, frame) {
            return this._binOpEmitter(node, frame, ' + "" + ');
          };
          _proto.compileSub = function compileSub(node, frame) {
            return this._binOpEmitter(node, frame, " - ");
          };
          _proto.compileMul = function compileMul(node, frame) {
            return this._binOpEmitter(node, frame, " * ");
          };
          _proto.compileDiv = function compileDiv(node, frame) {
            return this._binOpEmitter(node, frame, " / ");
          };
          _proto.compileMod = function compileMod(node, frame) {
            return this._binOpEmitter(node, frame, " % ");
          };
          _proto.compileNot = function compileNot(node, frame) {
            this._emit("!");
            this.compile(node.target, frame);
          };
          _proto.compileFloorDiv = function compileFloorDiv(node, frame) {
            this._emit("Math.floor(");
            this.compile(node.left, frame);
            this._emit(" / ");
            this.compile(node.right, frame);
            this._emit(")");
          };
          _proto.compilePow = function compilePow(node, frame) {
            this._emit("Math.pow(");
            this.compile(node.left, frame);
            this._emit(", ");
            this.compile(node.right, frame);
            this._emit(")");
          };
          _proto.compileNeg = function compileNeg(node, frame) {
            this._emit("-");
            this.compile(node.target, frame);
          };
          _proto.compilePos = function compilePos(node, frame) {
            this._emit("+");
            this.compile(node.target, frame);
          };
          _proto.compileCompare = function compileCompare(node, frame) {
            var _this5 = this;
            this.compile(node.expr, frame);
            node.ops.forEach(function(op) {
              _this5._emit(" " + compareOps[op.type] + " ");
              _this5.compile(op.expr, frame);
            });
          };
          _proto.compileLookupVal = function compileLookupVal(node, frame) {
            this._emit("runtime.memberLookup((");
            this._compileExpression(node.target, frame);
            this._emit("),");
            this._compileExpression(node.val, frame);
            this._emit(")");
          };
          _proto._getNodeName = function _getNodeName(node) {
            switch (node.typename) {
              case "Symbol":
                return node.value;
              case "FunCall":
                return "the return value of (" + this._getNodeName(node.name) + ")";
              case "LookupVal":
                return this._getNodeName(node.target) + '["' + this._getNodeName(node.val) + '"]';
              case "Literal":
                return node.value.toString();
              default:
                return "--expression--";
            }
          };
          _proto.compileFunCall = function compileFunCall(node, frame) {
            this._emit("(lineno = " + node.lineno + ", colno = " + node.colno + ", ");
            this._emit("runtime.callWrap(");
            this._compileExpression(node.name, frame);
            this._emit(', "' + this._getNodeName(node.name).replace(/"/g, '\\"') + '", context, ');
            this._compileAggregate(node.args, frame, "[", "])");
            this._emit(")");
          };
          _proto.compileFilter = function compileFilter(node, frame) {
            var name = node.name;
            this.assertType(name, nodes.Symbol);
            this._emit('env.getFilter("' + name.value + '").call(context, ');
            this._compileAggregate(node.args, frame);
            this._emit(")");
          };
          _proto.compileFilterAsync = function compileFilterAsync(node, frame) {
            var name = node.name;
            var symbol = node.symbol.value;
            this.assertType(name, nodes.Symbol);
            frame.set(symbol, symbol);
            this._emit('env.getFilter("' + name.value + '").call(context, ');
            this._compileAggregate(node.args, frame);
            this._emitLine(", " + this._makeCallback(symbol));
            this._addScopeLevel();
          };
          _proto.compileKeywordArgs = function compileKeywordArgs(node, frame) {
            this._emit("runtime.makeKeywordArgs(");
            this.compileDict(node, frame);
            this._emit(")");
          };
          _proto.compileSet = function compileSet(node, frame) {
            var _this6 = this;
            var ids = [];
            node.targets.forEach(function(target) {
              var name = target.value;
              var id = frame.lookup(name);
              if (id === null || id === void 0) {
                id = _this6._tmpid();
                _this6._emitLine("var " + id + ";");
              }
              ids.push(id);
            });
            if (node.value) {
              this._emit(ids.join(" = ") + " = ");
              this._compileExpression(node.value, frame);
              this._emitLine(";");
            } else {
              this._emit(ids.join(" = ") + " = ");
              this.compile(node.body, frame);
              this._emitLine(";");
            }
            node.targets.forEach(function(target, i2) {
              var id = ids[i2];
              var name = target.value;
              _this6._emitLine('frame.set("' + name + '", ' + id + ", true);");
              _this6._emitLine("if(frame.topLevel) {");
              _this6._emitLine('context.setVariable("' + name + '", ' + id + ");");
              _this6._emitLine("}");
              if (name.charAt(0) !== "_") {
                _this6._emitLine("if(frame.topLevel) {");
                _this6._emitLine('context.addExport("' + name + '", ' + id + ");");
                _this6._emitLine("}");
              }
            });
          };
          _proto.compileSwitch = function compileSwitch(node, frame) {
            var _this7 = this;
            this._emit("switch (");
            this.compile(node.expr, frame);
            this._emit(") {");
            node.cases.forEach(function(c2, i2) {
              _this7._emit("case ");
              _this7.compile(c2.cond, frame);
              _this7._emit(": ");
              _this7.compile(c2.body, frame);
              if (c2.body.children.length) {
                _this7._emitLine("break;");
              }
            });
            if (node.default) {
              this._emit("default:");
              this.compile(node.default, frame);
            }
            this._emit("}");
          };
          _proto.compileIf = function compileIf(node, frame, async) {
            var _this8 = this;
            this._emit("if(");
            this._compileExpression(node.cond, frame);
            this._emitLine(") {");
            this._withScopedSyntax(function() {
              _this8.compile(node.body, frame);
              if (async) {
                _this8._emit("cb()");
              }
            });
            if (node.else_) {
              this._emitLine("}\nelse {");
              this._withScopedSyntax(function() {
                _this8.compile(node.else_, frame);
                if (async) {
                  _this8._emit("cb()");
                }
              });
            } else if (async) {
              this._emitLine("}\nelse {");
              this._emit("cb()");
            }
            this._emitLine("}");
          };
          _proto.compileIfAsync = function compileIfAsync(node, frame) {
            this._emit("(function(cb) {");
            this.compileIf(node, frame, true);
            this._emit("})(" + this._makeCallback());
            this._addScopeLevel();
          };
          _proto._emitLoopBindings = function _emitLoopBindings(node, arr, i2, len) {
            var _this9 = this;
            var bindings = [{
              name: "index",
              val: i2 + " + 1"
            }, {
              name: "index0",
              val: i2
            }, {
              name: "revindex",
              val: len + " - " + i2
            }, {
              name: "revindex0",
              val: len + " - " + i2 + " - 1"
            }, {
              name: "first",
              val: i2 + " === 0"
            }, {
              name: "last",
              val: i2 + " === " + len + " - 1"
            }, {
              name: "length",
              val: len
            }];
            bindings.forEach(function(b2) {
              _this9._emitLine('frame.set("loop.' + b2.name + '", ' + b2.val + ");");
            });
          };
          _proto.compileFor = function compileFor(node, frame) {
            var _this10 = this;
            var i2 = this._tmpid();
            var len = this._tmpid();
            var arr = this._tmpid();
            frame = frame.push();
            this._emitLine("frame = frame.push();");
            this._emit("var " + arr + " = ");
            this._compileExpression(node.arr, frame);
            this._emitLine(";");
            this._emit("if(" + arr + ") {");
            this._emitLine(arr + " = runtime.fromIterator(" + arr + ");");
            if (node.name instanceof nodes.Array) {
              this._emitLine("var " + i2 + ";");
              this._emitLine("if(runtime.isArray(" + arr + ")) {");
              this._emitLine("var " + len + " = " + arr + ".length;");
              this._emitLine("for(" + i2 + "=0; " + i2 + " < " + arr + ".length; " + i2 + "++) {");
              node.name.children.forEach(function(child, u2) {
                var tid = _this10._tmpid();
                _this10._emitLine("var " + tid + " = " + arr + "[" + i2 + "][" + u2 + "];");
                _this10._emitLine('frame.set("' + child + '", ' + arr + "[" + i2 + "][" + u2 + "]);");
                frame.set(node.name.children[u2].value, tid);
              });
              this._emitLoopBindings(node, arr, i2, len);
              this._withScopedSyntax(function() {
                _this10.compile(node.body, frame);
              });
              this._emitLine("}");
              this._emitLine("} else {");
              var _node$name$children = node.name.children, key = _node$name$children[0], val = _node$name$children[1];
              var k2 = this._tmpid();
              var v2 = this._tmpid();
              frame.set(key.value, k2);
              frame.set(val.value, v2);
              this._emitLine(i2 + " = -1;");
              this._emitLine("var " + len + " = runtime.keys(" + arr + ").length;");
              this._emitLine("for(var " + k2 + " in " + arr + ") {");
              this._emitLine(i2 + "++;");
              this._emitLine("var " + v2 + " = " + arr + "[" + k2 + "];");
              this._emitLine('frame.set("' + key.value + '", ' + k2 + ");");
              this._emitLine('frame.set("' + val.value + '", ' + v2 + ");");
              this._emitLoopBindings(node, arr, i2, len);
              this._withScopedSyntax(function() {
                _this10.compile(node.body, frame);
              });
              this._emitLine("}");
              this._emitLine("}");
            } else {
              var _v = this._tmpid();
              frame.set(node.name.value, _v);
              this._emitLine("var " + len + " = " + arr + ".length;");
              this._emitLine("for(var " + i2 + "=0; " + i2 + " < " + arr + ".length; " + i2 + "++) {");
              this._emitLine("var " + _v + " = " + arr + "[" + i2 + "];");
              this._emitLine('frame.set("' + node.name.value + '", ' + _v + ");");
              this._emitLoopBindings(node, arr, i2, len);
              this._withScopedSyntax(function() {
                _this10.compile(node.body, frame);
              });
              this._emitLine("}");
            }
            this._emitLine("}");
            if (node.else_) {
              this._emitLine("if (!" + len + ") {");
              this.compile(node.else_, frame);
              this._emitLine("}");
            }
            this._emitLine("frame = frame.pop();");
          };
          _proto._compileAsyncLoop = function _compileAsyncLoop(node, frame, parallel) {
            var _this11 = this;
            var i2 = this._tmpid();
            var len = this._tmpid();
            var arr = this._tmpid();
            var asyncMethod = parallel ? "asyncAll" : "asyncEach";
            frame = frame.push();
            this._emitLine("frame = frame.push();");
            this._emit("var " + arr + " = runtime.fromIterator(");
            this._compileExpression(node.arr, frame);
            this._emitLine(");");
            if (node.name instanceof nodes.Array) {
              var arrayLen = node.name.children.length;
              this._emit("runtime." + asyncMethod + "(" + arr + ", " + arrayLen + ", function(");
              node.name.children.forEach(function(name) {
                _this11._emit(name.value + ",");
              });
              this._emit(i2 + "," + len + ",next) {");
              node.name.children.forEach(function(name) {
                var id2 = name.value;
                frame.set(id2, id2);
                _this11._emitLine('frame.set("' + id2 + '", ' + id2 + ");");
              });
            } else {
              var id = node.name.value;
              this._emitLine("runtime." + asyncMethod + "(" + arr + ", 1, function(" + id + ", " + i2 + ", " + len + ",next) {");
              this._emitLine('frame.set("' + id + '", ' + id + ");");
              frame.set(id, id);
            }
            this._emitLoopBindings(node, arr, i2, len);
            this._withScopedSyntax(function() {
              var buf;
              if (parallel) {
                buf = _this11._pushBuffer();
              }
              _this11.compile(node.body, frame);
              _this11._emitLine("next(" + i2 + (buf ? "," + buf : "") + ");");
              if (parallel) {
                _this11._popBuffer();
              }
            });
            var output = this._tmpid();
            this._emitLine("}, " + this._makeCallback(output));
            this._addScopeLevel();
            if (parallel) {
              this._emitLine(this.buffer + " += " + output + ";");
            }
            if (node.else_) {
              this._emitLine("if (!" + arr + ".length) {");
              this.compile(node.else_, frame);
              this._emitLine("}");
            }
            this._emitLine("frame = frame.pop();");
          };
          _proto.compileAsyncEach = function compileAsyncEach(node, frame) {
            this._compileAsyncLoop(node, frame);
          };
          _proto.compileAsyncAll = function compileAsyncAll(node, frame) {
            this._compileAsyncLoop(node, frame, true);
          };
          _proto._compileMacro = function _compileMacro(node, frame) {
            var _this12 = this;
            var args = [];
            var kwargs = null;
            var funcId = "macro_" + this._tmpid();
            var keepFrame = frame !== void 0;
            node.args.children.forEach(function(arg, i2) {
              if (i2 === node.args.children.length - 1 && arg instanceof nodes.Dict) {
                kwargs = arg;
              } else {
                _this12.assertType(arg, nodes.Symbol);
                args.push(arg);
              }
            });
            var realNames = [].concat(args.map(function(n2) {
              return "l_" + n2.value;
            }), ["kwargs"]);
            var argNames = args.map(function(n2) {
              return '"' + n2.value + '"';
            });
            var kwargNames = (kwargs && kwargs.children || []).map(function(n2) {
              return '"' + n2.key.value + '"';
            });
            var currFrame;
            if (keepFrame) {
              currFrame = frame.push(true);
            } else {
              currFrame = new Frame();
            }
            this._emitLines("var " + funcId + " = runtime.makeMacro(", "[" + argNames.join(", ") + "], ", "[" + kwargNames.join(", ") + "], ", "function (" + realNames.join(", ") + ") {", "var callerFrame = frame;", "frame = " + (keepFrame ? "frame.push(true);" : "new runtime.Frame();"), "kwargs = kwargs || {};", 'if (Object.prototype.hasOwnProperty.call(kwargs, "caller")) {', 'frame.set("caller", kwargs.caller); }');
            args.forEach(function(arg) {
              _this12._emitLine('frame.set("' + arg.value + '", l_' + arg.value + ");");
              currFrame.set(arg.value, "l_" + arg.value);
            });
            if (kwargs) {
              kwargs.children.forEach(function(pair) {
                var name = pair.key.value;
                _this12._emit('frame.set("' + name + '", ');
                _this12._emit('Object.prototype.hasOwnProperty.call(kwargs, "' + name + '")');
                _this12._emit(' ? kwargs["' + name + '"] : ');
                _this12._compileExpression(pair.value, currFrame);
                _this12._emit(");");
              });
            }
            var bufferId = this._pushBuffer();
            this._withScopedSyntax(function() {
              _this12.compile(node.body, currFrame);
            });
            this._emitLine("frame = " + (keepFrame ? "frame.pop();" : "callerFrame;"));
            this._emitLine("return new runtime.SafeString(" + bufferId + ");");
            this._emitLine("});");
            this._popBuffer();
            return funcId;
          };
          _proto.compileMacro = function compileMacro(node, frame) {
            var funcId = this._compileMacro(node);
            var name = node.name.value;
            frame.set(name, funcId);
            if (frame.parent) {
              this._emitLine('frame.set("' + name + '", ' + funcId + ");");
            } else {
              if (node.name.value.charAt(0) !== "_") {
                this._emitLine('context.addExport("' + name + '");');
              }
              this._emitLine('context.setVariable("' + name + '", ' + funcId + ");");
            }
          };
          _proto.compileCaller = function compileCaller(node, frame) {
            this._emit("(function (){");
            var funcId = this._compileMacro(node, frame);
            this._emit("return " + funcId + ";})()");
          };
          _proto._compileGetTemplate = function _compileGetTemplate(node, frame, eagerCompile, ignoreMissing) {
            var parentTemplateId = this._tmpid();
            var parentName = this._templateName();
            var cb = this._makeCallback(parentTemplateId);
            var eagerCompileArg = eagerCompile ? "true" : "false";
            var ignoreMissingArg = ignoreMissing ? "true" : "false";
            this._emit("env.getTemplate(");
            this._compileExpression(node.template, frame);
            this._emitLine(", " + eagerCompileArg + ", " + parentName + ", " + ignoreMissingArg + ", " + cb);
            return parentTemplateId;
          };
          _proto.compileImport = function compileImport(node, frame) {
            var target = node.target.value;
            var id = this._compileGetTemplate(node, frame, false, false);
            this._addScopeLevel();
            this._emitLine(id + ".getExported(" + (node.withContext ? "context.getVariables(), frame, " : "") + this._makeCallback(id));
            this._addScopeLevel();
            frame.set(target, id);
            if (frame.parent) {
              this._emitLine('frame.set("' + target + '", ' + id + ");");
            } else {
              this._emitLine('context.setVariable("' + target + '", ' + id + ");");
            }
          };
          _proto.compileFromImport = function compileFromImport(node, frame) {
            var _this13 = this;
            var importedId = this._compileGetTemplate(node, frame, false, false);
            this._addScopeLevel();
            this._emitLine(importedId + ".getExported(" + (node.withContext ? "context.getVariables(), frame, " : "") + this._makeCallback(importedId));
            this._addScopeLevel();
            node.names.children.forEach(function(nameNode) {
              var name;
              var alias;
              var id = _this13._tmpid();
              if (nameNode instanceof nodes.Pair) {
                name = nameNode.key.value;
                alias = nameNode.value.value;
              } else {
                name = nameNode.value;
                alias = name;
              }
              _this13._emitLine("if(Object.prototype.hasOwnProperty.call(" + importedId + ', "' + name + '")) {');
              _this13._emitLine("var " + id + " = " + importedId + "." + name + ";");
              _this13._emitLine("} else {");
              _this13._emitLine(`cb(new Error("cannot import '` + name + `'")); return;`);
              _this13._emitLine("}");
              frame.set(alias, id);
              if (frame.parent) {
                _this13._emitLine('frame.set("' + alias + '", ' + id + ");");
              } else {
                _this13._emitLine('context.setVariable("' + alias + '", ' + id + ");");
              }
            });
          };
          _proto.compileBlock = function compileBlock(node) {
            var id = this._tmpid();
            if (!this.inBlock) {
              this._emit('(parentTemplate ? function(e, c, f, r, cb) { cb(""); } : ');
            }
            this._emit('context.getBlock("' + node.name.value + '")');
            if (!this.inBlock) {
              this._emit(")");
            }
            this._emitLine("(env, context, frame, runtime, " + this._makeCallback(id));
            this._emitLine(this.buffer + " += " + id + ";");
            this._addScopeLevel();
          };
          _proto.compileSuper = function compileSuper(node, frame) {
            var name = node.blockName.value;
            var id = node.symbol.value;
            var cb = this._makeCallback(id);
            this._emitLine('context.getSuper(env, "' + name + '", b_' + name + ", frame, runtime, " + cb);
            this._emitLine(id + " = runtime.markSafe(" + id + ");");
            this._addScopeLevel();
            frame.set(id, id);
          };
          _proto.compileExtends = function compileExtends(node, frame) {
            var k2 = this._tmpid();
            var parentTemplateId = this._compileGetTemplate(node, frame, true, false);
            this._emitLine("parentTemplate = " + parentTemplateId);
            this._emitLine("for(var " + k2 + " in parentTemplate.blocks) {");
            this._emitLine("context.addBlock(" + k2 + ", parentTemplate.blocks[" + k2 + "]);");
            this._emitLine("}");
            this._addScopeLevel();
          };
          _proto.compileInclude = function compileInclude(node, frame) {
            this._emitLine("var tasks = [];");
            this._emitLine("tasks.push(");
            this._emitLine("function(callback) {");
            var id = this._compileGetTemplate(node, frame, false, node.ignoreMissing);
            this._emitLine("callback(null," + id + ");});");
            this._emitLine("});");
            var id2 = this._tmpid();
            this._emitLine("tasks.push(");
            this._emitLine("function(template, callback){");
            this._emitLine("template.render(context.getVariables(), frame, " + this._makeCallback(id2));
            this._emitLine("callback(null," + id2 + ");});");
            this._emitLine("});");
            this._emitLine("tasks.push(");
            this._emitLine("function(result, callback){");
            this._emitLine(this.buffer + " += result;");
            this._emitLine("callback(null);");
            this._emitLine("});");
            this._emitLine("env.waterfall(tasks, function(){");
            this._addScopeLevel();
          };
          _proto.compileTemplateData = function compileTemplateData(node, frame) {
            this.compileLiteral(node, frame);
          };
          _proto.compileCapture = function compileCapture(node, frame) {
            var _this14 = this;
            var buffer = this.buffer;
            this.buffer = "output";
            this._emitLine("(function() {");
            this._emitLine('var output = "";');
            this._withScopedSyntax(function() {
              _this14.compile(node.body, frame);
            });
            this._emitLine("return output;");
            this._emitLine("})()");
            this.buffer = buffer;
          };
          _proto.compileOutput = function compileOutput(node, frame) {
            var _this15 = this;
            var children2 = node.children;
            children2.forEach(function(child) {
              if (child instanceof nodes.TemplateData) {
                if (child.value) {
                  _this15._emit(_this15.buffer + " += ");
                  _this15.compileLiteral(child, frame);
                  _this15._emitLine(";");
                }
              } else {
                _this15._emit(_this15.buffer + " += runtime.suppressValue(");
                if (_this15.throwOnUndefined) {
                  _this15._emit("runtime.ensureDefined(");
                }
                _this15.compile(child, frame);
                if (_this15.throwOnUndefined) {
                  _this15._emit("," + node.lineno + "," + node.colno + ")");
                }
                _this15._emit(", env.opts.autoescape);\n");
              }
            });
          };
          _proto.compileRoot = function compileRoot(node, frame) {
            var _this16 = this;
            if (frame) {
              this.fail("compileRoot: root node can't have frame");
            }
            frame = new Frame();
            this._emitFuncBegin(node, "root");
            this._emitLine("var parentTemplate = null;");
            this._compileChildren(node, frame);
            this._emitLine("if(parentTemplate) {");
            this._emitLine("parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);");
            this._emitLine("} else {");
            this._emitLine("cb(null, " + this.buffer + ");");
            this._emitLine("}");
            this._emitFuncEnd(true);
            this.inBlock = true;
            var blockNames = [];
            var blocks = node.findAll(nodes.Block);
            blocks.forEach(function(block, i2) {
              var name = block.name.value;
              if (blockNames.indexOf(name) !== -1) {
                throw new Error('Block "' + name + '" defined more than once.');
              }
              blockNames.push(name);
              _this16._emitFuncBegin(block, "b_" + name);
              var tmpFrame = new Frame();
              _this16._emitLine("var frame = frame.push(true);");
              _this16.compile(block.body, tmpFrame);
              _this16._emitFuncEnd();
            });
            this._emitLine("return {");
            blocks.forEach(function(block, i2) {
              var blockName = "b_" + block.name.value;
              _this16._emitLine(blockName + ": " + blockName + ",");
            });
            this._emitLine("root: root\n};");
          };
          _proto.compile = function compile(node, frame) {
            var _compile = this["compile" + node.typename];
            if (_compile) {
              _compile.call(this, node, frame);
            } else {
              this.fail("compile: Cannot compile node: " + node.typename, node.lineno, node.colno);
            }
          };
          _proto.getCode = function getCode() {
            return this.codebuf.join("");
          };
          return Compiler2;
        }(Obj);
        module2.exports = {
          compile: function compile(src, asyncFilters, extensions, name, opts) {
            if (opts === void 0) {
              opts = {};
            }
            var c2 = new Compiler(name, opts.throwOnUndefined);
            var preprocessors = (extensions || []).map(function(ext) {
              return ext.preprocess;
            }).filter(function(f2) {
              return !!f2;
            });
            var processedSrc = preprocessors.reduce(function(s2, processor) {
              return processor(s2);
            }, src);
            c2.compile(transformer.transform(parser.parse(processedSrc, extensions, opts), asyncFilters, name));
            return c2.getCode();
          },
          Compiler
        };
      },
      function(module2, exports3, __webpack_require__) {
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o2, p2) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
            o3.__proto__ = p3;
            return o3;
          };
          return _setPrototypeOf(o2, p2);
        }
        var path = __webpack_require__(4);
        var _require = __webpack_require__(1), EmitterObj = _require.EmitterObj;
        module2.exports = /* @__PURE__ */ function(_EmitterObj) {
          _inheritsLoose(Loader2, _EmitterObj);
          function Loader2() {
            return _EmitterObj.apply(this, arguments) || this;
          }
          var _proto = Loader2.prototype;
          _proto.resolve = function resolve(from, to) {
            return path.resolve(path.dirname(from), to);
          };
          _proto.isRelative = function isRelative(filename) {
            return filename.indexOf("./") === 0 || filename.indexOf("../") === 0;
          };
          return Loader2;
        }(EmitterObj);
      },
      function(module2, exports3, __webpack_require__) {
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o2, p2) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
            o3.__proto__ = p3;
            return o3;
          };
          return _setPrototypeOf(o2, p2);
        }
        var asap = __webpack_require__(12);
        var _waterfall = __webpack_require__(15);
        var lib = __webpack_require__(0);
        var compiler = __webpack_require__(5);
        var filters = __webpack_require__(18);
        var _require = __webpack_require__(10), FileSystemLoader = _require.FileSystemLoader, WebLoader = _require.WebLoader, PrecompiledLoader = _require.PrecompiledLoader;
        var tests = __webpack_require__(20);
        var globals = __webpack_require__(21);
        var _require2 = __webpack_require__(1), Obj = _require2.Obj, EmitterObj = _require2.EmitterObj;
        var globalRuntime = __webpack_require__(2);
        var handleError = globalRuntime.handleError, Frame = globalRuntime.Frame;
        var expressApp = __webpack_require__(22);
        function callbackAsap(cb, err, res) {
          asap(function() {
            cb(err, res);
          });
        }
        var noopTmplSrc = {
          type: "code",
          obj: {
            root: function root(env, context2, frame, runtime, cb) {
              try {
                cb(null, "");
              } catch (e2) {
                cb(handleError(e2, null, null));
              }
            }
          }
        };
        var Environment = /* @__PURE__ */ function(_EmitterObj) {
          _inheritsLoose(Environment2, _EmitterObj);
          function Environment2() {
            return _EmitterObj.apply(this, arguments) || this;
          }
          var _proto = Environment2.prototype;
          _proto.init = function init(loaders, opts) {
            var _this = this;
            opts = this.opts = opts || {};
            this.opts.dev = !!opts.dev;
            this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true;
            this.opts.throwOnUndefined = !!opts.throwOnUndefined;
            this.opts.trimBlocks = !!opts.trimBlocks;
            this.opts.lstripBlocks = !!opts.lstripBlocks;
            this.loaders = [];
            if (!loaders) {
              if (FileSystemLoader) {
                this.loaders = [new FileSystemLoader("views")];
              } else if (WebLoader) {
                this.loaders = [new WebLoader("/views")];
              }
            } else {
              this.loaders = lib.isArray(loaders) ? loaders : [loaders];
            }
            if (typeof window !== "undefined" && window.nunjucksPrecompiled) {
              this.loaders.unshift(new PrecompiledLoader(window.nunjucksPrecompiled));
            }
            this._initLoaders();
            this.globals = globals();
            this.filters = {};
            this.tests = {};
            this.asyncFilters = [];
            this.extensions = {};
            this.extensionsList = [];
            lib._entries(filters).forEach(function(_ref) {
              var name = _ref[0], filter2 = _ref[1];
              return _this.addFilter(name, filter2);
            });
            lib._entries(tests).forEach(function(_ref2) {
              var name = _ref2[0], test = _ref2[1];
              return _this.addTest(name, test);
            });
          };
          _proto._initLoaders = function _initLoaders() {
            var _this2 = this;
            this.loaders.forEach(function(loader) {
              loader.cache = {};
              if (typeof loader.on === "function") {
                loader.on("update", function(name, fullname) {
                  loader.cache[name] = null;
                  _this2.emit("update", name, fullname, loader);
                });
                loader.on("load", function(name, source) {
                  _this2.emit("load", name, source, loader);
                });
              }
            });
          };
          _proto.invalidateCache = function invalidateCache() {
            this.loaders.forEach(function(loader) {
              loader.cache = {};
            });
          };
          _proto.addExtension = function addExtension(name, extension) {
            extension.__name = name;
            this.extensions[name] = extension;
            this.extensionsList.push(extension);
            return this;
          };
          _proto.removeExtension = function removeExtension(name) {
            var extension = this.getExtension(name);
            if (!extension) {
              return;
            }
            this.extensionsList = lib.without(this.extensionsList, extension);
            delete this.extensions[name];
          };
          _proto.getExtension = function getExtension(name) {
            return this.extensions[name];
          };
          _proto.hasExtension = function hasExtension(name) {
            return !!this.extensions[name];
          };
          _proto.addGlobal = function addGlobal(name, value) {
            this.globals[name] = value;
            return this;
          };
          _proto.getGlobal = function getGlobal(name) {
            if (typeof this.globals[name] === "undefined") {
              throw new Error("global not found: " + name);
            }
            return this.globals[name];
          };
          _proto.addFilter = function addFilter(name, func, async) {
            var wrapped = func;
            if (async) {
              this.asyncFilters.push(name);
            }
            this.filters[name] = wrapped;
            return this;
          };
          _proto.getFilter = function getFilter(name) {
            if (!this.filters[name]) {
              throw new Error("filter not found: " + name);
            }
            return this.filters[name];
          };
          _proto.addTest = function addTest(name, func) {
            this.tests[name] = func;
            return this;
          };
          _proto.getTest = function getTest(name) {
            if (!this.tests[name]) {
              throw new Error("test not found: " + name);
            }
            return this.tests[name];
          };
          _proto.resolveTemplate = function resolveTemplate(loader, parentName, filename) {
            var isRelative = loader.isRelative && parentName ? loader.isRelative(filename) : false;
            return isRelative && loader.resolve ? loader.resolve(parentName, filename) : filename;
          };
          _proto.getTemplate = function getTemplate(name, eagerCompile, parentName, ignoreMissing, cb) {
            var _this3 = this;
            var that = this;
            var tmpl = null;
            if (name && name.raw) {
              name = name.raw;
            }
            if (lib.isFunction(parentName)) {
              cb = parentName;
              parentName = null;
              eagerCompile = eagerCompile || false;
            }
            if (lib.isFunction(eagerCompile)) {
              cb = eagerCompile;
              eagerCompile = false;
            }
            if (name instanceof Template) {
              tmpl = name;
            } else if (typeof name !== "string") {
              throw new Error("template names must be a string: " + name);
            } else {
              for (var i2 = 0; i2 < this.loaders.length; i2++) {
                var loader = this.loaders[i2];
                tmpl = loader.cache[this.resolveTemplate(loader, parentName, name)];
                if (tmpl) {
                  break;
                }
              }
            }
            if (tmpl) {
              if (eagerCompile) {
                tmpl.compile();
              }
              if (cb) {
                cb(null, tmpl);
                return void 0;
              } else {
                return tmpl;
              }
            }
            var syncResult;
            var createTemplate = function createTemplate2(err, info) {
              if (!info && !err && !ignoreMissing) {
                err = new Error("template not found: " + name);
              }
              if (err) {
                if (cb) {
                  cb(err);
                  return;
                } else {
                  throw err;
                }
              }
              var newTmpl;
              if (!info) {
                newTmpl = new Template(noopTmplSrc, _this3, "", eagerCompile);
              } else {
                newTmpl = new Template(info.src, _this3, info.path, eagerCompile);
                if (!info.noCache) {
                  info.loader.cache[name] = newTmpl;
                }
              }
              if (cb) {
                cb(null, newTmpl);
              } else {
                syncResult = newTmpl;
              }
            };
            lib.asyncIter(this.loaders, function(loader2, i3, next3, done) {
              function handle(err, src) {
                if (err) {
                  done(err);
                } else if (src) {
                  src.loader = loader2;
                  done(null, src);
                } else {
                  next3();
                }
              }
              name = that.resolveTemplate(loader2, parentName, name);
              if (loader2.async) {
                loader2.getSource(name, handle);
              } else {
                handle(null, loader2.getSource(name));
              }
            }, createTemplate);
            return syncResult;
          };
          _proto.express = function express(app) {
            return expressApp(this, app);
          };
          _proto.render = function render3(name, ctx, cb) {
            if (lib.isFunction(ctx)) {
              cb = ctx;
              ctx = null;
            }
            var syncResult = null;
            this.getTemplate(name, function(err, tmpl) {
              if (err && cb) {
                callbackAsap(cb, err);
              } else if (err) {
                throw err;
              } else {
                syncResult = tmpl.render(ctx, cb);
              }
            });
            return syncResult;
          };
          _proto.renderString = function renderString(src, ctx, opts, cb) {
            if (lib.isFunction(opts)) {
              cb = opts;
              opts = {};
            }
            opts = opts || {};
            var tmpl = new Template(src, this, opts.path);
            return tmpl.render(ctx, cb);
          };
          _proto.waterfall = function waterfall(tasks, callback, forceAsync) {
            return _waterfall(tasks, callback, forceAsync);
          };
          return Environment2;
        }(EmitterObj);
        var Context = /* @__PURE__ */ function(_Obj) {
          _inheritsLoose(Context2, _Obj);
          function Context2() {
            return _Obj.apply(this, arguments) || this;
          }
          var _proto2 = Context2.prototype;
          _proto2.init = function init(ctx, blocks, env) {
            var _this4 = this;
            this.env = env || new Environment();
            this.ctx = lib.extend({}, ctx);
            this.blocks = {};
            this.exported = [];
            lib.keys(blocks).forEach(function(name) {
              _this4.addBlock(name, blocks[name]);
            });
          };
          _proto2.lookup = function lookup(name) {
            if (name in this.env.globals && !(name in this.ctx)) {
              return this.env.globals[name];
            } else {
              return this.ctx[name];
            }
          };
          _proto2.setVariable = function setVariable(name, val) {
            this.ctx[name] = val;
          };
          _proto2.getVariables = function getVariables() {
            return this.ctx;
          };
          _proto2.addBlock = function addBlock(name, block) {
            this.blocks[name] = this.blocks[name] || [];
            this.blocks[name].push(block);
            return this;
          };
          _proto2.getBlock = function getBlock(name) {
            if (!this.blocks[name]) {
              throw new Error('unknown block "' + name + '"');
            }
            return this.blocks[name][0];
          };
          _proto2.getSuper = function getSuper(env, name, block, frame, runtime, cb) {
            var idx = lib.indexOf(this.blocks[name] || [], block);
            var blk = this.blocks[name][idx + 1];
            var context2 = this;
            if (idx === -1 || !blk) {
              throw new Error('no super block available for "' + name + '"');
            }
            blk(env, context2, frame, runtime, cb);
          };
          _proto2.addExport = function addExport(name) {
            this.exported.push(name);
          };
          _proto2.getExported = function getExported() {
            var _this5 = this;
            var exported = {};
            this.exported.forEach(function(name) {
              exported[name] = _this5.ctx[name];
            });
            return exported;
          };
          return Context2;
        }(Obj);
        var Template = /* @__PURE__ */ function(_Obj2) {
          _inheritsLoose(Template2, _Obj2);
          function Template2() {
            return _Obj2.apply(this, arguments) || this;
          }
          var _proto3 = Template2.prototype;
          _proto3.init = function init(src, env, path, eagerCompile) {
            this.env = env || new Environment();
            if (lib.isObject(src)) {
              switch (src.type) {
                case "code":
                  this.tmplProps = src.obj;
                  break;
                case "string":
                  this.tmplStr = src.obj;
                  break;
                default:
                  throw new Error("Unexpected template object type " + src.type + "; expected 'code', or 'string'");
              }
            } else if (lib.isString(src)) {
              this.tmplStr = src;
            } else {
              throw new Error("src must be a string or an object describing the source");
            }
            this.path = path;
            if (eagerCompile) {
              try {
                this._compile();
              } catch (err) {
                throw lib._prettifyError(this.path, this.env.opts.dev, err);
              }
            } else {
              this.compiled = false;
            }
          };
          _proto3.render = function render3(ctx, parentFrame, cb) {
            var _this6 = this;
            if (typeof ctx === "function") {
              cb = ctx;
              ctx = {};
            } else if (typeof parentFrame === "function") {
              cb = parentFrame;
              parentFrame = null;
            }
            var forceAsync = !parentFrame;
            try {
              this.compile();
            } catch (e2) {
              var err = lib._prettifyError(this.path, this.env.opts.dev, e2);
              if (cb) {
                return callbackAsap(cb, err);
              } else {
                throw err;
              }
            }
            var context2 = new Context(ctx || {}, this.blocks, this.env);
            var frame = parentFrame ? parentFrame.push(true) : new Frame();
            frame.topLevel = true;
            var syncResult = null;
            var didError = false;
            this.rootRenderFunc(this.env, context2, frame, globalRuntime, function(err2, res) {
              if (didError && cb && typeof res !== "undefined") {
                return;
              }
              if (err2) {
                err2 = lib._prettifyError(_this6.path, _this6.env.opts.dev, err2);
                didError = true;
              }
              if (cb) {
                if (forceAsync) {
                  callbackAsap(cb, err2, res);
                } else {
                  cb(err2, res);
                }
              } else {
                if (err2) {
                  throw err2;
                }
                syncResult = res;
              }
            });
            return syncResult;
          };
          _proto3.getExported = function getExported(ctx, parentFrame, cb) {
            if (typeof ctx === "function") {
              cb = ctx;
              ctx = {};
            }
            if (typeof parentFrame === "function") {
              cb = parentFrame;
              parentFrame = null;
            }
            try {
              this.compile();
            } catch (e2) {
              if (cb) {
                return cb(e2);
              } else {
                throw e2;
              }
            }
            var frame = parentFrame ? parentFrame.push() : new Frame();
            frame.topLevel = true;
            var context2 = new Context(ctx || {}, this.blocks, this.env);
            this.rootRenderFunc(this.env, context2, frame, globalRuntime, function(err) {
              if (err) {
                cb(err, null);
              } else {
                cb(null, context2.getExported());
              }
            });
          };
          _proto3.compile = function compile() {
            if (!this.compiled) {
              this._compile();
            }
          };
          _proto3._compile = function _compile() {
            var props;
            if (this.tmplProps) {
              props = this.tmplProps;
            } else {
              var source = compiler.compile(this.tmplStr, this.env.asyncFilters, this.env.extensionsList, this.path, this.env.opts);
              var func = new Function(source);
              props = func();
            }
            this.blocks = this._getBlocks(props);
            this.rootRenderFunc = props.root;
            this.compiled = true;
          };
          _proto3._getBlocks = function _getBlocks(props) {
            var blocks = {};
            lib.keys(props).forEach(function(k2) {
              if (k2.slice(0, 2) === "b_") {
                blocks[k2.slice(2)] = props[k2];
              }
            });
            return blocks;
          };
          return Template2;
        }(Obj);
        module2.exports = {
          Environment,
          Template
        };
      },
      function(module2, exports3, __webpack_require__) {
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o2, p2) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
            o3.__proto__ = p3;
            return o3;
          };
          return _setPrototypeOf(o2, p2);
        }
        var lexer = __webpack_require__(9);
        var nodes = __webpack_require__(3);
        var Obj = __webpack_require__(1).Obj;
        var lib = __webpack_require__(0);
        var Parser = /* @__PURE__ */ function(_Obj) {
          _inheritsLoose(Parser2, _Obj);
          function Parser2() {
            return _Obj.apply(this, arguments) || this;
          }
          var _proto = Parser2.prototype;
          _proto.init = function init(tokens) {
            this.tokens = tokens;
            this.peeked = null;
            this.breakOnBlocks = null;
            this.dropLeadingWhitespace = false;
            this.extensions = [];
          };
          _proto.nextToken = function nextToken(withWhitespace) {
            var tok;
            if (this.peeked) {
              if (!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {
                this.peeked = null;
              } else {
                tok = this.peeked;
                this.peeked = null;
                return tok;
              }
            }
            tok = this.tokens.nextToken();
            if (!withWhitespace) {
              while (tok && tok.type === lexer.TOKEN_WHITESPACE) {
                tok = this.tokens.nextToken();
              }
            }
            return tok;
          };
          _proto.peekToken = function peekToken() {
            this.peeked = this.peeked || this.nextToken();
            return this.peeked;
          };
          _proto.pushToken = function pushToken(tok) {
            if (this.peeked) {
              throw new Error("pushToken: can only push one token on between reads");
            }
            this.peeked = tok;
          };
          _proto.error = function error(msg, lineno, colno) {
            if (lineno === void 0 || colno === void 0) {
              var tok = this.peekToken() || {};
              lineno = tok.lineno;
              colno = tok.colno;
            }
            if (lineno !== void 0) {
              lineno += 1;
            }
            if (colno !== void 0) {
              colno += 1;
            }
            return new lib.TemplateError(msg, lineno, colno);
          };
          _proto.fail = function fail(msg, lineno, colno) {
            throw this.error(msg, lineno, colno);
          };
          _proto.skip = function skip(type) {
            var tok = this.nextToken();
            if (!tok || tok.type !== type) {
              this.pushToken(tok);
              return false;
            }
            return true;
          };
          _proto.expect = function expect(type) {
            var tok = this.nextToken();
            if (tok.type !== type) {
              this.fail("expected " + type + ", got " + tok.type, tok.lineno, tok.colno);
            }
            return tok;
          };
          _proto.skipValue = function skipValue(type, val) {
            var tok = this.nextToken();
            if (!tok || tok.type !== type || tok.value !== val) {
              this.pushToken(tok);
              return false;
            }
            return true;
          };
          _proto.skipSymbol = function skipSymbol(val) {
            return this.skipValue(lexer.TOKEN_SYMBOL, val);
          };
          _proto.advanceAfterBlockEnd = function advanceAfterBlockEnd(name) {
            var tok;
            if (!name) {
              tok = this.peekToken();
              if (!tok) {
                this.fail("unexpected end of file");
              }
              if (tok.type !== lexer.TOKEN_SYMBOL) {
                this.fail("advanceAfterBlockEnd: expected symbol token or explicit name to be passed");
              }
              name = this.nextToken().value;
            }
            tok = this.nextToken();
            if (tok && tok.type === lexer.TOKEN_BLOCK_END) {
              if (tok.value.charAt(0) === "-") {
                this.dropLeadingWhitespace = true;
              }
            } else {
              this.fail("expected block end in " + name + " statement");
            }
            return tok;
          };
          _proto.advanceAfterVariableEnd = function advanceAfterVariableEnd() {
            var tok = this.nextToken();
            if (tok && tok.type === lexer.TOKEN_VARIABLE_END) {
              this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.VARIABLE_END.length - 1) === "-";
            } else {
              this.pushToken(tok);
              this.fail("expected variable end");
            }
          };
          _proto.parseFor = function parseFor() {
            var forTok = this.peekToken();
            var node;
            var endBlock;
            if (this.skipSymbol("for")) {
              node = new nodes.For(forTok.lineno, forTok.colno);
              endBlock = "endfor";
            } else if (this.skipSymbol("asyncEach")) {
              node = new nodes.AsyncEach(forTok.lineno, forTok.colno);
              endBlock = "endeach";
            } else if (this.skipSymbol("asyncAll")) {
              node = new nodes.AsyncAll(forTok.lineno, forTok.colno);
              endBlock = "endall";
            } else {
              this.fail("parseFor: expected for{Async}", forTok.lineno, forTok.colno);
            }
            node.name = this.parsePrimary();
            if (!(node.name instanceof nodes.Symbol)) {
              this.fail("parseFor: variable name expected for loop");
            }
            var type = this.peekToken().type;
            if (type === lexer.TOKEN_COMMA) {
              var key = node.name;
              node.name = new nodes.Array(key.lineno, key.colno);
              node.name.addChild(key);
              while (this.skip(lexer.TOKEN_COMMA)) {
                var prim = this.parsePrimary();
                node.name.addChild(prim);
              }
            }
            if (!this.skipSymbol("in")) {
              this.fail('parseFor: expected "in" keyword for loop', forTok.lineno, forTok.colno);
            }
            node.arr = this.parseExpression();
            this.advanceAfterBlockEnd(forTok.value);
            node.body = this.parseUntilBlocks(endBlock, "else");
            if (this.skipSymbol("else")) {
              this.advanceAfterBlockEnd("else");
              node.else_ = this.parseUntilBlocks(endBlock);
            }
            this.advanceAfterBlockEnd();
            return node;
          };
          _proto.parseMacro = function parseMacro() {
            var macroTok = this.peekToken();
            if (!this.skipSymbol("macro")) {
              this.fail("expected macro");
            }
            var name = this.parsePrimary(true);
            var args = this.parseSignature();
            var node = new nodes.Macro(macroTok.lineno, macroTok.colno, name, args);
            this.advanceAfterBlockEnd(macroTok.value);
            node.body = this.parseUntilBlocks("endmacro");
            this.advanceAfterBlockEnd();
            return node;
          };
          _proto.parseCall = function parseCall() {
            var callTok = this.peekToken();
            if (!this.skipSymbol("call")) {
              this.fail("expected call");
            }
            var callerArgs = this.parseSignature(true) || new nodes.NodeList();
            var macroCall = this.parsePrimary();
            this.advanceAfterBlockEnd(callTok.value);
            var body = this.parseUntilBlocks("endcall");
            this.advanceAfterBlockEnd();
            var callerName = new nodes.Symbol(callTok.lineno, callTok.colno, "caller");
            var callerNode = new nodes.Caller(callTok.lineno, callTok.colno, callerName, callerArgs, body);
            var args = macroCall.args.children;
            if (!(args[args.length - 1] instanceof nodes.KeywordArgs)) {
              args.push(new nodes.KeywordArgs());
            }
            var kwargs = args[args.length - 1];
            kwargs.addChild(new nodes.Pair(callTok.lineno, callTok.colno, callerName, callerNode));
            return new nodes.Output(callTok.lineno, callTok.colno, [macroCall]);
          };
          _proto.parseWithContext = function parseWithContext() {
            var tok = this.peekToken();
            var withContext = null;
            if (this.skipSymbol("with")) {
              withContext = true;
            } else if (this.skipSymbol("without")) {
              withContext = false;
            }
            if (withContext !== null) {
              if (!this.skipSymbol("context")) {
                this.fail("parseFrom: expected context after with/without", tok.lineno, tok.colno);
              }
            }
            return withContext;
          };
          _proto.parseImport = function parseImport() {
            var importTok = this.peekToken();
            if (!this.skipSymbol("import")) {
              this.fail("parseImport: expected import", importTok.lineno, importTok.colno);
            }
            var template = this.parseExpression();
            if (!this.skipSymbol("as")) {
              this.fail('parseImport: expected "as" keyword', importTok.lineno, importTok.colno);
            }
            var target = this.parseExpression();
            var withContext = this.parseWithContext();
            var node = new nodes.Import(importTok.lineno, importTok.colno, template, target, withContext);
            this.advanceAfterBlockEnd(importTok.value);
            return node;
          };
          _proto.parseFrom = function parseFrom() {
            var fromTok = this.peekToken();
            if (!this.skipSymbol("from")) {
              this.fail("parseFrom: expected from");
            }
            var template = this.parseExpression();
            if (!this.skipSymbol("import")) {
              this.fail("parseFrom: expected import", fromTok.lineno, fromTok.colno);
            }
            var names = new nodes.NodeList();
            var withContext;
            while (1) {
              var nextTok = this.peekToken();
              if (nextTok.type === lexer.TOKEN_BLOCK_END) {
                if (!names.children.length) {
                  this.fail("parseFrom: Expected at least one import name", fromTok.lineno, fromTok.colno);
                }
                if (nextTok.value.charAt(0) === "-") {
                  this.dropLeadingWhitespace = true;
                }
                this.nextToken();
                break;
              }
              if (names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {
                this.fail("parseFrom: expected comma", fromTok.lineno, fromTok.colno);
              }
              var name = this.parsePrimary();
              if (name.value.charAt(0) === "_") {
                this.fail("parseFrom: names starting with an underscore cannot be imported", name.lineno, name.colno);
              }
              if (this.skipSymbol("as")) {
                var alias = this.parsePrimary();
                names.addChild(new nodes.Pair(name.lineno, name.colno, name, alias));
              } else {
                names.addChild(name);
              }
              withContext = this.parseWithContext();
            }
            return new nodes.FromImport(fromTok.lineno, fromTok.colno, template, names, withContext);
          };
          _proto.parseBlock = function parseBlock() {
            var tag = this.peekToken();
            if (!this.skipSymbol("block")) {
              this.fail("parseBlock: expected block", tag.lineno, tag.colno);
            }
            var node = new nodes.Block(tag.lineno, tag.colno);
            node.name = this.parsePrimary();
            if (!(node.name instanceof nodes.Symbol)) {
              this.fail("parseBlock: variable name expected", tag.lineno, tag.colno);
            }
            this.advanceAfterBlockEnd(tag.value);
            node.body = this.parseUntilBlocks("endblock");
            this.skipSymbol("endblock");
            this.skipSymbol(node.name.value);
            var tok = this.peekToken();
            if (!tok) {
              this.fail("parseBlock: expected endblock, got end of file");
            }
            this.advanceAfterBlockEnd(tok.value);
            return node;
          };
          _proto.parseExtends = function parseExtends() {
            var tagName = "extends";
            var tag = this.peekToken();
            if (!this.skipSymbol(tagName)) {
              this.fail("parseTemplateRef: expected " + tagName);
            }
            var node = new nodes.Extends(tag.lineno, tag.colno);
            node.template = this.parseExpression();
            this.advanceAfterBlockEnd(tag.value);
            return node;
          };
          _proto.parseInclude = function parseInclude() {
            var tagName = "include";
            var tag = this.peekToken();
            if (!this.skipSymbol(tagName)) {
              this.fail("parseInclude: expected " + tagName);
            }
            var node = new nodes.Include(tag.lineno, tag.colno);
            node.template = this.parseExpression();
            if (this.skipSymbol("ignore") && this.skipSymbol("missing")) {
              node.ignoreMissing = true;
            }
            this.advanceAfterBlockEnd(tag.value);
            return node;
          };
          _proto.parseIf = function parseIf() {
            var tag = this.peekToken();
            var node;
            if (this.skipSymbol("if") || this.skipSymbol("elif") || this.skipSymbol("elseif")) {
              node = new nodes.If(tag.lineno, tag.colno);
            } else if (this.skipSymbol("ifAsync")) {
              node = new nodes.IfAsync(tag.lineno, tag.colno);
            } else {
              this.fail("parseIf: expected if, elif, or elseif", tag.lineno, tag.colno);
            }
            node.cond = this.parseExpression();
            this.advanceAfterBlockEnd(tag.value);
            node.body = this.parseUntilBlocks("elif", "elseif", "else", "endif");
            var tok = this.peekToken();
            switch (tok && tok.value) {
              case "elseif":
              case "elif":
                node.else_ = this.parseIf();
                break;
              case "else":
                this.advanceAfterBlockEnd();
                node.else_ = this.parseUntilBlocks("endif");
                this.advanceAfterBlockEnd();
                break;
              case "endif":
                node.else_ = null;
                this.advanceAfterBlockEnd();
                break;
              default:
                this.fail("parseIf: expected elif, else, or endif, got end of file");
            }
            return node;
          };
          _proto.parseSet = function parseSet() {
            var tag = this.peekToken();
            if (!this.skipSymbol("set")) {
              this.fail("parseSet: expected set", tag.lineno, tag.colno);
            }
            var node = new nodes.Set(tag.lineno, tag.colno, []);
            var target;
            while (target = this.parsePrimary()) {
              node.targets.push(target);
              if (!this.skip(lexer.TOKEN_COMMA)) {
                break;
              }
            }
            if (!this.skipValue(lexer.TOKEN_OPERATOR, "=")) {
              if (!this.skip(lexer.TOKEN_BLOCK_END)) {
                this.fail("parseSet: expected = or block end in set tag", tag.lineno, tag.colno);
              } else {
                node.body = new nodes.Capture(tag.lineno, tag.colno, this.parseUntilBlocks("endset"));
                node.value = null;
                this.advanceAfterBlockEnd();
              }
            } else {
              node.value = this.parseExpression();
              this.advanceAfterBlockEnd(tag.value);
            }
            return node;
          };
          _proto.parseSwitch = function parseSwitch() {
            var switchStart = "switch";
            var switchEnd = "endswitch";
            var caseStart = "case";
            var caseDefault = "default";
            var tag = this.peekToken();
            if (!this.skipSymbol(switchStart) && !this.skipSymbol(caseStart) && !this.skipSymbol(caseDefault)) {
              this.fail('parseSwitch: expected "switch," "case" or "default"', tag.lineno, tag.colno);
            }
            var expr = this.parseExpression();
            this.advanceAfterBlockEnd(switchStart);
            this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
            var tok = this.peekToken();
            var cases = [];
            var defaultCase;
            do {
              this.skipSymbol(caseStart);
              var cond = this.parseExpression();
              this.advanceAfterBlockEnd(switchStart);
              var body = this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
              cases.push(new nodes.Case(tok.line, tok.col, cond, body));
              tok = this.peekToken();
            } while (tok && tok.value === caseStart);
            switch (tok.value) {
              case caseDefault:
                this.advanceAfterBlockEnd();
                defaultCase = this.parseUntilBlocks(switchEnd);
                this.advanceAfterBlockEnd();
                break;
              case switchEnd:
                this.advanceAfterBlockEnd();
                break;
              default:
                this.fail('parseSwitch: expected "case," "default" or "endswitch," got EOF.');
            }
            return new nodes.Switch(tag.lineno, tag.colno, expr, cases, defaultCase);
          };
          _proto.parseStatement = function parseStatement() {
            var tok = this.peekToken();
            var node;
            if (tok.type !== lexer.TOKEN_SYMBOL) {
              this.fail("tag name expected", tok.lineno, tok.colno);
            }
            if (this.breakOnBlocks && lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {
              return null;
            }
            switch (tok.value) {
              case "raw":
                return this.parseRaw();
              case "verbatim":
                return this.parseRaw("verbatim");
              case "if":
              case "ifAsync":
                return this.parseIf();
              case "for":
              case "asyncEach":
              case "asyncAll":
                return this.parseFor();
              case "block":
                return this.parseBlock();
              case "extends":
                return this.parseExtends();
              case "include":
                return this.parseInclude();
              case "set":
                return this.parseSet();
              case "macro":
                return this.parseMacro();
              case "call":
                return this.parseCall();
              case "import":
                return this.parseImport();
              case "from":
                return this.parseFrom();
              case "filter":
                return this.parseFilterStatement();
              case "switch":
                return this.parseSwitch();
              default:
                if (this.extensions.length) {
                  for (var i2 = 0; i2 < this.extensions.length; i2++) {
                    var ext = this.extensions[i2];
                    if (lib.indexOf(ext.tags || [], tok.value) !== -1) {
                      return ext.parse(this, nodes, lexer);
                    }
                  }
                }
                this.fail("unknown block tag: " + tok.value, tok.lineno, tok.colno);
            }
            return node;
          };
          _proto.parseRaw = function parseRaw(tagName) {
            tagName = tagName || "raw";
            var endTagName = "end" + tagName;
            var rawBlockRegex = new RegExp("([\\s\\S]*?){%\\s*(" + tagName + "|" + endTagName + ")\\s*(?=%})%}");
            var rawLevel = 1;
            var str = "";
            var matches = null;
            var begun = this.advanceAfterBlockEnd();
            while ((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {
              var all = matches[0];
              var pre = matches[1];
              var blockName = matches[2];
              if (blockName === tagName) {
                rawLevel += 1;
              } else if (blockName === endTagName) {
                rawLevel -= 1;
              }
              if (rawLevel === 0) {
                str += pre;
                this.tokens.backN(all.length - pre.length);
              } else {
                str += all;
              }
            }
            return new nodes.Output(begun.lineno, begun.colno, [new nodes.TemplateData(begun.lineno, begun.colno, str)]);
          };
          _proto.parsePostfix = function parsePostfix(node) {
            var lookup;
            var tok = this.peekToken();
            while (tok) {
              if (tok.type === lexer.TOKEN_LEFT_PAREN) {
                node = new nodes.FunCall(tok.lineno, tok.colno, node, this.parseSignature());
              } else if (tok.type === lexer.TOKEN_LEFT_BRACKET) {
                lookup = this.parseAggregate();
                if (lookup.children.length > 1) {
                  this.fail("invalid index");
                }
                node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup.children[0]);
              } else if (tok.type === lexer.TOKEN_OPERATOR && tok.value === ".") {
                this.nextToken();
                var val = this.nextToken();
                if (val.type !== lexer.TOKEN_SYMBOL) {
                  this.fail("expected name as lookup value, got " + val.value, val.lineno, val.colno);
                }
                lookup = new nodes.Literal(val.lineno, val.colno, val.value);
                node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup);
              } else {
                break;
              }
              tok = this.peekToken();
            }
            return node;
          };
          _proto.parseExpression = function parseExpression() {
            var node = this.parseInlineIf();
            return node;
          };
          _proto.parseInlineIf = function parseInlineIf() {
            var node = this.parseOr();
            if (this.skipSymbol("if")) {
              var condNode = this.parseOr();
              var bodyNode = node;
              node = new nodes.InlineIf(node.lineno, node.colno);
              node.body = bodyNode;
              node.cond = condNode;
              if (this.skipSymbol("else")) {
                node.else_ = this.parseOr();
              } else {
                node.else_ = null;
              }
            }
            return node;
          };
          _proto.parseOr = function parseOr() {
            var node = this.parseAnd();
            while (this.skipSymbol("or")) {
              var node2 = this.parseAnd();
              node = new nodes.Or(node.lineno, node.colno, node, node2);
            }
            return node;
          };
          _proto.parseAnd = function parseAnd() {
            var node = this.parseNot();
            while (this.skipSymbol("and")) {
              var node2 = this.parseNot();
              node = new nodes.And(node.lineno, node.colno, node, node2);
            }
            return node;
          };
          _proto.parseNot = function parseNot() {
            var tok = this.peekToken();
            if (this.skipSymbol("not")) {
              return new nodes.Not(tok.lineno, tok.colno, this.parseNot());
            }
            return this.parseIn();
          };
          _proto.parseIn = function parseIn() {
            var node = this.parseIs();
            while (1) {
              var tok = this.nextToken();
              if (!tok) {
                break;
              }
              var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === "not";
              if (!invert) {
                this.pushToken(tok);
              }
              if (this.skipSymbol("in")) {
                var node2 = this.parseIs();
                node = new nodes.In(node.lineno, node.colno, node, node2);
                if (invert) {
                  node = new nodes.Not(node.lineno, node.colno, node);
                }
              } else {
                if (invert) {
                  this.pushToken(tok);
                }
                break;
              }
            }
            return node;
          };
          _proto.parseIs = function parseIs() {
            var node = this.parseCompare();
            if (this.skipSymbol("is")) {
              var not = this.skipSymbol("not");
              var node2 = this.parseCompare();
              node = new nodes.Is(node.lineno, node.colno, node, node2);
              if (not) {
                node = new nodes.Not(node.lineno, node.colno, node);
              }
            }
            return node;
          };
          _proto.parseCompare = function parseCompare() {
            var compareOps = ["==", "===", "!=", "!==", "<", ">", "<=", ">="];
            var expr = this.parseConcat();
            var ops = [];
            while (1) {
              var tok = this.nextToken();
              if (!tok) {
                break;
              } else if (compareOps.indexOf(tok.value) !== -1) {
                ops.push(new nodes.CompareOperand(tok.lineno, tok.colno, this.parseConcat(), tok.value));
              } else {
                this.pushToken(tok);
                break;
              }
            }
            if (ops.length) {
              return new nodes.Compare(ops[0].lineno, ops[0].colno, expr, ops);
            } else {
              return expr;
            }
          };
          _proto.parseConcat = function parseConcat() {
            var node = this.parseAdd();
            while (this.skipValue(lexer.TOKEN_TILDE, "~")) {
              var node2 = this.parseAdd();
              node = new nodes.Concat(node.lineno, node.colno, node, node2);
            }
            return node;
          };
          _proto.parseAdd = function parseAdd() {
            var node = this.parseSub();
            while (this.skipValue(lexer.TOKEN_OPERATOR, "+")) {
              var node2 = this.parseSub();
              node = new nodes.Add(node.lineno, node.colno, node, node2);
            }
            return node;
          };
          _proto.parseSub = function parseSub() {
            var node = this.parseMul();
            while (this.skipValue(lexer.TOKEN_OPERATOR, "-")) {
              var node2 = this.parseMul();
              node = new nodes.Sub(node.lineno, node.colno, node, node2);
            }
            return node;
          };
          _proto.parseMul = function parseMul() {
            var node = this.parseDiv();
            while (this.skipValue(lexer.TOKEN_OPERATOR, "*")) {
              var node2 = this.parseDiv();
              node = new nodes.Mul(node.lineno, node.colno, node, node2);
            }
            return node;
          };
          _proto.parseDiv = function parseDiv() {
            var node = this.parseFloorDiv();
            while (this.skipValue(lexer.TOKEN_OPERATOR, "/")) {
              var node2 = this.parseFloorDiv();
              node = new nodes.Div(node.lineno, node.colno, node, node2);
            }
            return node;
          };
          _proto.parseFloorDiv = function parseFloorDiv() {
            var node = this.parseMod();
            while (this.skipValue(lexer.TOKEN_OPERATOR, "//")) {
              var node2 = this.parseMod();
              node = new nodes.FloorDiv(node.lineno, node.colno, node, node2);
            }
            return node;
          };
          _proto.parseMod = function parseMod() {
            var node = this.parsePow();
            while (this.skipValue(lexer.TOKEN_OPERATOR, "%")) {
              var node2 = this.parsePow();
              node = new nodes.Mod(node.lineno, node.colno, node, node2);
            }
            return node;
          };
          _proto.parsePow = function parsePow() {
            var node = this.parseUnary();
            while (this.skipValue(lexer.TOKEN_OPERATOR, "**")) {
              var node2 = this.parseUnary();
              node = new nodes.Pow(node.lineno, node.colno, node, node2);
            }
            return node;
          };
          _proto.parseUnary = function parseUnary(noFilters) {
            var tok = this.peekToken();
            var node;
            if (this.skipValue(lexer.TOKEN_OPERATOR, "-")) {
              node = new nodes.Neg(tok.lineno, tok.colno, this.parseUnary(true));
            } else if (this.skipValue(lexer.TOKEN_OPERATOR, "+")) {
              node = new nodes.Pos(tok.lineno, tok.colno, this.parseUnary(true));
            } else {
              node = this.parsePrimary();
            }
            if (!noFilters) {
              node = this.parseFilter(node);
            }
            return node;
          };
          _proto.parsePrimary = function parsePrimary(noPostfix) {
            var tok = this.nextToken();
            var val;
            var node = null;
            if (!tok) {
              this.fail("expected expression, got end of file");
            } else if (tok.type === lexer.TOKEN_STRING) {
              val = tok.value;
            } else if (tok.type === lexer.TOKEN_INT) {
              val = parseInt(tok.value, 10);
            } else if (tok.type === lexer.TOKEN_FLOAT) {
              val = parseFloat(tok.value);
            } else if (tok.type === lexer.TOKEN_BOOLEAN) {
              if (tok.value === "true") {
                val = true;
              } else if (tok.value === "false") {
                val = false;
              } else {
                this.fail("invalid boolean: " + tok.value, tok.lineno, tok.colno);
              }
            } else if (tok.type === lexer.TOKEN_NONE) {
              val = null;
            } else if (tok.type === lexer.TOKEN_REGEX) {
              val = new RegExp(tok.value.body, tok.value.flags);
            }
            if (val !== void 0) {
              node = new nodes.Literal(tok.lineno, tok.colno, val);
            } else if (tok.type === lexer.TOKEN_SYMBOL) {
              node = new nodes.Symbol(tok.lineno, tok.colno, tok.value);
            } else {
              this.pushToken(tok);
              node = this.parseAggregate();
            }
            if (!noPostfix) {
              node = this.parsePostfix(node);
            }
            if (node) {
              return node;
            } else {
              throw this.error("unexpected token: " + tok.value, tok.lineno, tok.colno);
            }
          };
          _proto.parseFilterName = function parseFilterName() {
            var tok = this.expect(lexer.TOKEN_SYMBOL);
            var name = tok.value;
            while (this.skipValue(lexer.TOKEN_OPERATOR, ".")) {
              name += "." + this.expect(lexer.TOKEN_SYMBOL).value;
            }
            return new nodes.Symbol(tok.lineno, tok.colno, name);
          };
          _proto.parseFilterArgs = function parseFilterArgs(node) {
            if (this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {
              var call = this.parsePostfix(node);
              return call.args.children;
            }
            return [];
          };
          _proto.parseFilter = function parseFilter(node) {
            while (this.skip(lexer.TOKEN_PIPE)) {
              var name = this.parseFilterName();
              node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [node].concat(this.parseFilterArgs(node))));
            }
            return node;
          };
          _proto.parseFilterStatement = function parseFilterStatement() {
            var filterTok = this.peekToken();
            if (!this.skipSymbol("filter")) {
              this.fail("parseFilterStatement: expected filter");
            }
            var name = this.parseFilterName();
            var args = this.parseFilterArgs(name);
            this.advanceAfterBlockEnd(filterTok.value);
            var body = new nodes.Capture(name.lineno, name.colno, this.parseUntilBlocks("endfilter"));
            this.advanceAfterBlockEnd();
            var node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [body].concat(args)));
            return new nodes.Output(name.lineno, name.colno, [node]);
          };
          _proto.parseAggregate = function parseAggregate() {
            var tok = this.nextToken();
            var node;
            switch (tok.type) {
              case lexer.TOKEN_LEFT_PAREN:
                node = new nodes.Group(tok.lineno, tok.colno);
                break;
              case lexer.TOKEN_LEFT_BRACKET:
                node = new nodes.Array(tok.lineno, tok.colno);
                break;
              case lexer.TOKEN_LEFT_CURLY:
                node = new nodes.Dict(tok.lineno, tok.colno);
                break;
              default:
                return null;
            }
            while (1) {
              var type = this.peekToken().type;
              if (type === lexer.TOKEN_RIGHT_PAREN || type === lexer.TOKEN_RIGHT_BRACKET || type === lexer.TOKEN_RIGHT_CURLY) {
                this.nextToken();
                break;
              }
              if (node.children.length > 0) {
                if (!this.skip(lexer.TOKEN_COMMA)) {
                  this.fail("parseAggregate: expected comma after expression", tok.lineno, tok.colno);
                }
              }
              if (node instanceof nodes.Dict) {
                var key = this.parsePrimary();
                if (!this.skip(lexer.TOKEN_COLON)) {
                  this.fail("parseAggregate: expected colon after dict key", tok.lineno, tok.colno);
                }
                var value = this.parseExpression();
                node.addChild(new nodes.Pair(key.lineno, key.colno, key, value));
              } else {
                var expr = this.parseExpression();
                node.addChild(expr);
              }
            }
            return node;
          };
          _proto.parseSignature = function parseSignature(tolerant, noParens) {
            var tok = this.peekToken();
            if (!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {
              if (tolerant) {
                return null;
              } else {
                this.fail("expected arguments", tok.lineno, tok.colno);
              }
            }
            if (tok.type === lexer.TOKEN_LEFT_PAREN) {
              tok = this.nextToken();
            }
            var args = new nodes.NodeList(tok.lineno, tok.colno);
            var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);
            var checkComma = false;
            while (1) {
              tok = this.peekToken();
              if (!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {
                this.nextToken();
                break;
              } else if (noParens && tok.type === lexer.TOKEN_BLOCK_END) {
                break;
              }
              if (checkComma && !this.skip(lexer.TOKEN_COMMA)) {
                this.fail("parseSignature: expected comma after expression", tok.lineno, tok.colno);
              } else {
                var arg = this.parseExpression();
                if (this.skipValue(lexer.TOKEN_OPERATOR, "=")) {
                  kwargs.addChild(new nodes.Pair(arg.lineno, arg.colno, arg, this.parseExpression()));
                } else {
                  args.addChild(arg);
                }
              }
              checkComma = true;
            }
            if (kwargs.children.length) {
              args.addChild(kwargs);
            }
            return args;
          };
          _proto.parseUntilBlocks = function parseUntilBlocks() {
            var prev3 = this.breakOnBlocks;
            for (var _len = arguments.length, blockNames = new Array(_len), _key = 0; _key < _len; _key++) {
              blockNames[_key] = arguments[_key];
            }
            this.breakOnBlocks = blockNames;
            var ret = this.parse();
            this.breakOnBlocks = prev3;
            return ret;
          };
          _proto.parseNodes = function parseNodes() {
            var tok;
            var buf = [];
            while (tok = this.nextToken()) {
              if (tok.type === lexer.TOKEN_DATA) {
                var data = tok.value;
                var nextToken = this.peekToken();
                var nextVal = nextToken && nextToken.value;
                if (this.dropLeadingWhitespace) {
                  data = data.replace(/^\s*/, "");
                  this.dropLeadingWhitespace = false;
                }
                if (nextToken && (nextToken.type === lexer.TOKEN_BLOCK_START && nextVal.charAt(nextVal.length - 1) === "-" || nextToken.type === lexer.TOKEN_VARIABLE_START && nextVal.charAt(this.tokens.tags.VARIABLE_START.length) === "-" || nextToken.type === lexer.TOKEN_COMMENT && nextVal.charAt(this.tokens.tags.COMMENT_START.length) === "-")) {
                  data = data.replace(/\s*$/, "");
                }
                buf.push(new nodes.Output(tok.lineno, tok.colno, [new nodes.TemplateData(tok.lineno, tok.colno, data)]));
              } else if (tok.type === lexer.TOKEN_BLOCK_START) {
                this.dropLeadingWhitespace = false;
                var n2 = this.parseStatement();
                if (!n2) {
                  break;
                }
                buf.push(n2);
              } else if (tok.type === lexer.TOKEN_VARIABLE_START) {
                var e2 = this.parseExpression();
                this.dropLeadingWhitespace = false;
                this.advanceAfterVariableEnd();
                buf.push(new nodes.Output(tok.lineno, tok.colno, [e2]));
              } else if (tok.type === lexer.TOKEN_COMMENT) {
                this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.COMMENT_END.length - 1) === "-";
              } else {
                this.fail("Unexpected token at top-level: " + tok.type, tok.lineno, tok.colno);
              }
            }
            return buf;
          };
          _proto.parse = function parse() {
            return new nodes.NodeList(0, 0, this.parseNodes());
          };
          _proto.parseAsRoot = function parseAsRoot() {
            return new nodes.Root(0, 0, this.parseNodes());
          };
          return Parser2;
        }(Obj);
        module2.exports = {
          parse: function parse(src, extensions, opts) {
            var p2 = new Parser(lexer.lex(src, opts));
            if (extensions !== void 0) {
              p2.extensions = extensions;
            }
            return p2.parseAsRoot();
          },
          Parser
        };
      },
      function(module2, exports3, __webpack_require__) {
        var lib = __webpack_require__(0);
        var whitespaceChars = " \n	\r\xA0";
        var delimChars = "()[]{}%*-+~/#,:|.<>=!";
        var intChars = "0123456789";
        var BLOCK_START = "{%";
        var BLOCK_END = "%}";
        var VARIABLE_START = "{{";
        var VARIABLE_END = "}}";
        var COMMENT_START = "{#";
        var COMMENT_END = "#}";
        var TOKEN_STRING = "string";
        var TOKEN_WHITESPACE = "whitespace";
        var TOKEN_DATA = "data";
        var TOKEN_BLOCK_START = "block-start";
        var TOKEN_BLOCK_END = "block-end";
        var TOKEN_VARIABLE_START = "variable-start";
        var TOKEN_VARIABLE_END = "variable-end";
        var TOKEN_COMMENT = "comment";
        var TOKEN_LEFT_PAREN = "left-paren";
        var TOKEN_RIGHT_PAREN = "right-paren";
        var TOKEN_LEFT_BRACKET = "left-bracket";
        var TOKEN_RIGHT_BRACKET = "right-bracket";
        var TOKEN_LEFT_CURLY = "left-curly";
        var TOKEN_RIGHT_CURLY = "right-curly";
        var TOKEN_OPERATOR = "operator";
        var TOKEN_COMMA = "comma";
        var TOKEN_COLON = "colon";
        var TOKEN_TILDE = "tilde";
        var TOKEN_PIPE = "pipe";
        var TOKEN_INT = "int";
        var TOKEN_FLOAT = "float";
        var TOKEN_BOOLEAN = "boolean";
        var TOKEN_NONE = "none";
        var TOKEN_SYMBOL = "symbol";
        var TOKEN_SPECIAL = "special";
        var TOKEN_REGEX = "regex";
        function token(type, value, lineno, colno) {
          return {
            type,
            value,
            lineno,
            colno
          };
        }
        var Tokenizer = /* @__PURE__ */ function() {
          function Tokenizer2(str, opts) {
            this.str = str;
            this.index = 0;
            this.len = str.length;
            this.lineno = 0;
            this.colno = 0;
            this.in_code = false;
            opts = opts || {};
            var tags = opts.tags || {};
            this.tags = {
              BLOCK_START: tags.blockStart || BLOCK_START,
              BLOCK_END: tags.blockEnd || BLOCK_END,
              VARIABLE_START: tags.variableStart || VARIABLE_START,
              VARIABLE_END: tags.variableEnd || VARIABLE_END,
              COMMENT_START: tags.commentStart || COMMENT_START,
              COMMENT_END: tags.commentEnd || COMMENT_END
            };
            this.trimBlocks = !!opts.trimBlocks;
            this.lstripBlocks = !!opts.lstripBlocks;
          }
          var _proto = Tokenizer2.prototype;
          _proto.nextToken = function nextToken() {
            var lineno = this.lineno;
            var colno = this.colno;
            var tok;
            if (this.in_code) {
              var cur = this.current();
              if (this.isFinished()) {
                return null;
              } else if (cur === '"' || cur === "'") {
                return token(TOKEN_STRING, this._parseString(cur), lineno, colno);
              } else if (tok = this._extract(whitespaceChars)) {
                return token(TOKEN_WHITESPACE, tok, lineno, colno);
              } else if ((tok = this._extractString(this.tags.BLOCK_END)) || (tok = this._extractString("-" + this.tags.BLOCK_END))) {
                this.in_code = false;
                if (this.trimBlocks) {
                  cur = this.current();
                  if (cur === "\n") {
                    this.forward();
                  } else if (cur === "\r") {
                    this.forward();
                    cur = this.current();
                    if (cur === "\n") {
                      this.forward();
                    } else {
                      this.back();
                    }
                  }
                }
                return token(TOKEN_BLOCK_END, tok, lineno, colno);
              } else if ((tok = this._extractString(this.tags.VARIABLE_END)) || (tok = this._extractString("-" + this.tags.VARIABLE_END))) {
                this.in_code = false;
                return token(TOKEN_VARIABLE_END, tok, lineno, colno);
              } else if (cur === "r" && this.str.charAt(this.index + 1) === "/") {
                this.forwardN(2);
                var regexBody = "";
                while (!this.isFinished()) {
                  if (this.current() === "/" && this.previous() !== "\\") {
                    this.forward();
                    break;
                  } else {
                    regexBody += this.current();
                    this.forward();
                  }
                }
                var POSSIBLE_FLAGS = ["g", "i", "m", "y"];
                var regexFlags = "";
                while (!this.isFinished()) {
                  var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;
                  if (isCurrentAFlag) {
                    regexFlags += this.current();
                    this.forward();
                  } else {
                    break;
                  }
                }
                return token(TOKEN_REGEX, {
                  body: regexBody,
                  flags: regexFlags
                }, lineno, colno);
              } else if (delimChars.indexOf(cur) !== -1) {
                this.forward();
                var complexOps = ["==", "===", "!=", "!==", "<=", ">=", "//", "**"];
                var curComplex = cur + this.current();
                var type;
                if (lib.indexOf(complexOps, curComplex) !== -1) {
                  this.forward();
                  cur = curComplex;
                  if (lib.indexOf(complexOps, curComplex + this.current()) !== -1) {
                    cur = curComplex + this.current();
                    this.forward();
                  }
                }
                switch (cur) {
                  case "(":
                    type = TOKEN_LEFT_PAREN;
                    break;
                  case ")":
                    type = TOKEN_RIGHT_PAREN;
                    break;
                  case "[":
                    type = TOKEN_LEFT_BRACKET;
                    break;
                  case "]":
                    type = TOKEN_RIGHT_BRACKET;
                    break;
                  case "{":
                    type = TOKEN_LEFT_CURLY;
                    break;
                  case "}":
                    type = TOKEN_RIGHT_CURLY;
                    break;
                  case ",":
                    type = TOKEN_COMMA;
                    break;
                  case ":":
                    type = TOKEN_COLON;
                    break;
                  case "~":
                    type = TOKEN_TILDE;
                    break;
                  case "|":
                    type = TOKEN_PIPE;
                    break;
                  default:
                    type = TOKEN_OPERATOR;
                }
                return token(type, cur, lineno, colno);
              } else {
                tok = this._extractUntil(whitespaceChars + delimChars);
                if (tok.match(/^[-+]?[0-9]+$/)) {
                  if (this.current() === ".") {
                    this.forward();
                    var dec = this._extract(intChars);
                    return token(TOKEN_FLOAT, tok + "." + dec, lineno, colno);
                  } else {
                    return token(TOKEN_INT, tok, lineno, colno);
                  }
                } else if (tok.match(/^(true|false)$/)) {
                  return token(TOKEN_BOOLEAN, tok, lineno, colno);
                } else if (tok === "none") {
                  return token(TOKEN_NONE, tok, lineno, colno);
                } else if (tok === "null") {
                  return token(TOKEN_NONE, tok, lineno, colno);
                } else if (tok) {
                  return token(TOKEN_SYMBOL, tok, lineno, colno);
                } else {
                  throw new Error("Unexpected value while parsing: " + tok);
                }
              }
            } else {
              var beginChars = this.tags.BLOCK_START.charAt(0) + this.tags.VARIABLE_START.charAt(0) + this.tags.COMMENT_START.charAt(0) + this.tags.COMMENT_END.charAt(0);
              if (this.isFinished()) {
                return null;
              } else if ((tok = this._extractString(this.tags.BLOCK_START + "-")) || (tok = this._extractString(this.tags.BLOCK_START))) {
                this.in_code = true;
                return token(TOKEN_BLOCK_START, tok, lineno, colno);
              } else if ((tok = this._extractString(this.tags.VARIABLE_START + "-")) || (tok = this._extractString(this.tags.VARIABLE_START))) {
                this.in_code = true;
                return token(TOKEN_VARIABLE_START, tok, lineno, colno);
              } else {
                tok = "";
                var data;
                var inComment = false;
                if (this._matches(this.tags.COMMENT_START)) {
                  inComment = true;
                  tok = this._extractString(this.tags.COMMENT_START);
                }
                while ((data = this._extractUntil(beginChars)) !== null) {
                  tok += data;
                  if ((this._matches(this.tags.BLOCK_START) || this._matches(this.tags.VARIABLE_START) || this._matches(this.tags.COMMENT_START)) && !inComment) {
                    if (this.lstripBlocks && this._matches(this.tags.BLOCK_START) && this.colno > 0 && this.colno <= tok.length) {
                      var lastLine = tok.slice(-this.colno);
                      if (/^\s+$/.test(lastLine)) {
                        tok = tok.slice(0, -this.colno);
                        if (!tok.length) {
                          return this.nextToken();
                        }
                      }
                    }
                    break;
                  } else if (this._matches(this.tags.COMMENT_END)) {
                    if (!inComment) {
                      throw new Error("unexpected end of comment");
                    }
                    tok += this._extractString(this.tags.COMMENT_END);
                    break;
                  } else {
                    tok += this.current();
                    this.forward();
                  }
                }
                if (data === null && inComment) {
                  throw new Error("expected end of comment, got end of file");
                }
                return token(inComment ? TOKEN_COMMENT : TOKEN_DATA, tok, lineno, colno);
              }
            }
          };
          _proto._parseString = function _parseString(delimiter) {
            this.forward();
            var str = "";
            while (!this.isFinished() && this.current() !== delimiter) {
              var cur = this.current();
              if (cur === "\\") {
                this.forward();
                switch (this.current()) {
                  case "n":
                    str += "\n";
                    break;
                  case "t":
                    str += "	";
                    break;
                  case "r":
                    str += "\r";
                    break;
                  default:
                    str += this.current();
                }
                this.forward();
              } else {
                str += cur;
                this.forward();
              }
            }
            this.forward();
            return str;
          };
          _proto._matches = function _matches(str) {
            if (this.index + str.length > this.len) {
              return null;
            }
            var m2 = this.str.slice(this.index, this.index + str.length);
            return m2 === str;
          };
          _proto._extractString = function _extractString(str) {
            if (this._matches(str)) {
              this.forwardN(str.length);
              return str;
            }
            return null;
          };
          _proto._extractUntil = function _extractUntil(charString) {
            return this._extractMatching(true, charString || "");
          };
          _proto._extract = function _extract(charString) {
            return this._extractMatching(false, charString);
          };
          _proto._extractMatching = function _extractMatching(breakOnMatch, charString) {
            if (this.isFinished()) {
              return null;
            }
            var first = charString.indexOf(this.current());
            if (breakOnMatch && first === -1 || !breakOnMatch && first !== -1) {
              var t2 = this.current();
              this.forward();
              var idx = charString.indexOf(this.current());
              while ((breakOnMatch && idx === -1 || !breakOnMatch && idx !== -1) && !this.isFinished()) {
                t2 += this.current();
                this.forward();
                idx = charString.indexOf(this.current());
              }
              return t2;
            }
            return "";
          };
          _proto._extractRegex = function _extractRegex(regex) {
            var matches = this.currentStr().match(regex);
            if (!matches) {
              return null;
            }
            this.forwardN(matches[0].length);
            return matches;
          };
          _proto.isFinished = function isFinished() {
            return this.index >= this.len;
          };
          _proto.forwardN = function forwardN(n2) {
            for (var i2 = 0; i2 < n2; i2++) {
              this.forward();
            }
          };
          _proto.forward = function forward() {
            this.index++;
            if (this.previous() === "\n") {
              this.lineno++;
              this.colno = 0;
            } else {
              this.colno++;
            }
          };
          _proto.backN = function backN(n2) {
            for (var i2 = 0; i2 < n2; i2++) {
              this.back();
            }
          };
          _proto.back = function back() {
            this.index--;
            if (this.current() === "\n") {
              this.lineno--;
              var idx = this.src.lastIndexOf("\n", this.index - 1);
              if (idx === -1) {
                this.colno = this.index;
              } else {
                this.colno = this.index - idx;
              }
            } else {
              this.colno--;
            }
          };
          _proto.current = function current() {
            if (!this.isFinished()) {
              return this.str.charAt(this.index);
            }
            return "";
          };
          _proto.currentStr = function currentStr() {
            if (!this.isFinished()) {
              return this.str.substr(this.index);
            }
            return "";
          };
          _proto.previous = function previous() {
            return this.str.charAt(this.index - 1);
          };
          return Tokenizer2;
        }();
        module2.exports = {
          lex: function lex(src, opts) {
            return new Tokenizer(src, opts);
          },
          TOKEN_STRING,
          TOKEN_WHITESPACE,
          TOKEN_DATA,
          TOKEN_BLOCK_START,
          TOKEN_BLOCK_END,
          TOKEN_VARIABLE_START,
          TOKEN_VARIABLE_END,
          TOKEN_COMMENT,
          TOKEN_LEFT_PAREN,
          TOKEN_RIGHT_PAREN,
          TOKEN_LEFT_BRACKET,
          TOKEN_RIGHT_BRACKET,
          TOKEN_LEFT_CURLY,
          TOKEN_RIGHT_CURLY,
          TOKEN_OPERATOR,
          TOKEN_COMMA,
          TOKEN_COLON,
          TOKEN_TILDE,
          TOKEN_PIPE,
          TOKEN_INT,
          TOKEN_FLOAT,
          TOKEN_BOOLEAN,
          TOKEN_NONE,
          TOKEN_SYMBOL,
          TOKEN_SPECIAL,
          TOKEN_REGEX
        };
      },
      function(module2, exports3, __webpack_require__) {
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o2, p2) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
            o3.__proto__ = p3;
            return o3;
          };
          return _setPrototypeOf(o2, p2);
        }
        var Loader2 = __webpack_require__(6);
        var _require = __webpack_require__(19), PrecompiledLoader = _require.PrecompiledLoader;
        var WebLoader = /* @__PURE__ */ function(_Loader) {
          _inheritsLoose(WebLoader2, _Loader);
          function WebLoader2(baseURL, opts) {
            var _this;
            _this = _Loader.call(this) || this;
            _this.baseURL = baseURL || ".";
            opts = opts || {};
            _this.useCache = !!opts.useCache;
            _this.async = !!opts.async;
            return _this;
          }
          var _proto = WebLoader2.prototype;
          _proto.resolve = function resolve(from, to) {
            throw new Error("relative templates not support in the browser yet");
          };
          _proto.getSource = function getSource(name, cb) {
            var _this2 = this;
            var useCache = this.useCache;
            var result;
            this.fetch(this.baseURL + "/" + name, function(err, src) {
              if (err) {
                if (cb) {
                  cb(err.content);
                } else if (err.status === 404) {
                  result = null;
                } else {
                  throw err.content;
                }
              } else {
                result = {
                  src,
                  path: name,
                  noCache: !useCache
                };
                _this2.emit("load", name, result);
                if (cb) {
                  cb(null, result);
                }
              }
            });
            return result;
          };
          _proto.fetch = function fetch(url, cb) {
            if (typeof window === "undefined") {
              throw new Error("WebLoader can only by used in a browser");
            }
            var ajax = new XMLHttpRequest();
            var loading2 = true;
            ajax.onreadystatechange = function() {
              if (ajax.readyState === 4 && loading2) {
                loading2 = false;
                if (ajax.status === 0 || ajax.status === 200) {
                  cb(null, ajax.responseText);
                } else {
                  cb({
                    status: ajax.status,
                    content: ajax.responseText
                  });
                }
              }
            };
            url += (url.indexOf("?") === -1 ? "?" : "&") + "s=" + new Date().getTime();
            ajax.open("GET", url, this.async);
            ajax.send();
          };
          return WebLoader2;
        }(Loader2);
        module2.exports = {
          WebLoader,
          PrecompiledLoader
        };
      },
      function(module2, exports3, __webpack_require__) {
        var lib = __webpack_require__(0);
        var _require = __webpack_require__(7), Environment = _require.Environment, Template = _require.Template;
        var Loader2 = __webpack_require__(6);
        var loaders = __webpack_require__(10);
        var precompile = __webpack_require__(23);
        var compiler = __webpack_require__(5);
        var parser = __webpack_require__(8);
        var lexer = __webpack_require__(9);
        var runtime = __webpack_require__(2);
        var nodes = __webpack_require__(3);
        var installJinjaCompat = __webpack_require__(25);
        var e2;
        function configure(templatesPath, opts) {
          opts = opts || {};
          if (lib.isObject(templatesPath)) {
            opts = templatesPath;
            templatesPath = null;
          }
          var TemplateLoader;
          if (loaders.FileSystemLoader) {
            TemplateLoader = new loaders.FileSystemLoader(templatesPath, {
              watch: opts.watch,
              noCache: opts.noCache
            });
          } else if (loaders.WebLoader) {
            TemplateLoader = new loaders.WebLoader(templatesPath, {
              useCache: opts.web && opts.web.useCache,
              async: opts.web && opts.web.async
            });
          }
          e2 = new Environment(TemplateLoader, opts);
          if (opts && opts.express) {
            e2.express(opts.express);
          }
          return e2;
        }
        module2.exports = {
          Environment,
          Template,
          Loader: Loader2,
          FileSystemLoader: loaders.FileSystemLoader,
          NodeResolveLoader: loaders.NodeResolveLoader,
          PrecompiledLoader: loaders.PrecompiledLoader,
          WebLoader: loaders.WebLoader,
          compiler,
          parser,
          lexer,
          runtime,
          lib,
          nodes,
          installJinjaCompat,
          configure,
          reset: function reset2() {
            e2 = void 0;
          },
          compile: function compile(src, env, path, eagerCompile) {
            if (!e2) {
              configure();
            }
            return new Template(src, env, path, eagerCompile);
          },
          render: function render3(name, ctx, cb) {
            if (!e2) {
              configure();
            }
            return e2.render(name, ctx, cb);
          },
          renderString: function renderString(src, ctx, cb) {
            if (!e2) {
              configure();
            }
            return e2.renderString(src, ctx, cb);
          },
          precompile: precompile ? precompile.precompile : void 0,
          precompileString: precompile ? precompile.precompileString : void 0
        };
      },
      function(module2, exports3, __webpack_require__) {
        var rawAsap = __webpack_require__(13);
        var freeTasks = [];
        var pendingErrors = [];
        var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);
        function throwFirstError() {
          if (pendingErrors.length) {
            throw pendingErrors.shift();
          }
        }
        module2.exports = asap;
        function asap(task) {
          var rawTask;
          if (freeTasks.length) {
            rawTask = freeTasks.pop();
          } else {
            rawTask = new RawTask();
          }
          rawTask.task = task;
          rawAsap(rawTask);
        }
        function RawTask() {
          this.task = null;
        }
        RawTask.prototype.call = function() {
          try {
            this.task.call();
          } catch (error) {
            if (asap.onerror) {
              asap.onerror(error);
            } else {
              pendingErrors.push(error);
              requestErrorThrow();
            }
          } finally {
            this.task = null;
            freeTasks[freeTasks.length] = this;
          }
        };
      },
      function(module2, exports3, __webpack_require__) {
        (function(global2) {
          module2.exports = rawAsap;
          function rawAsap(task) {
            if (!queue.length) {
              requestFlush();
            }
            queue[queue.length] = task;
          }
          var queue = [];
          var requestFlush;
          var index2 = 0;
          var capacity = 1024;
          function flush() {
            while (index2 < queue.length) {
              var currentIndex = index2;
              index2 = index2 + 1;
              queue[currentIndex].call();
              if (index2 > capacity) {
                for (var scan = 0, newLength = queue.length - index2; scan < newLength; scan++) {
                  queue[scan] = queue[scan + index2];
                }
                queue.length -= index2;
                index2 = 0;
              }
            }
            queue.length = 0;
            index2 = 0;
          }
          var scope = typeof global2 !== "undefined" ? global2 : self;
          var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
          if (typeof BrowserMutationObserver === "function") {
            requestFlush = makeRequestCallFromMutationObserver(flush);
          } else {
            requestFlush = makeRequestCallFromTimer(flush);
          }
          rawAsap.requestFlush = requestFlush;
          function makeRequestCallFromMutationObserver(callback) {
            var toggle2 = 1;
            var observer = new BrowserMutationObserver(callback);
            var node = document.createTextNode("");
            observer.observe(node, { characterData: true });
            return function requestCall() {
              toggle2 = -toggle2;
              node.data = toggle2;
            };
          }
          function makeRequestCallFromTimer(callback) {
            return function requestCall() {
              var timeoutHandle = setTimeout(handleTimer, 0);
              var intervalHandle = setInterval(handleTimer, 50);
              function handleTimer() {
                clearTimeout(timeoutHandle);
                clearInterval(intervalHandle);
                callback();
              }
            };
          }
          rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
        }).call(exports3, __webpack_require__(14));
      },
      function(module2, exports3) {
        var g2;
        g2 = function() {
          return this;
        }();
        try {
          g2 = g2 || Function("return this")() || (1, eval)("this");
        } catch (e2) {
          if (typeof window === "object")
            g2 = window;
        }
        module2.exports = g2;
      },
      function(module2, exports3, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        (function(globals) {
          var executeSync = function() {
            var args = Array.prototype.slice.call(arguments);
            if (typeof args[0] === "function") {
              args[0].apply(null, args.splice(1));
            }
          };
          var executeAsync = function(fn) {
            if (typeof setImmediate === "function") {
              setImmediate(fn);
            } else if (typeof process !== "undefined" && process.nextTick) {
              process.nextTick(fn);
            } else {
              setTimeout(fn, 0);
            }
          };
          var makeIterator = function(tasks) {
            var makeCallback = function(index2) {
              var fn = function() {
                if (tasks.length) {
                  tasks[index2].apply(null, arguments);
                }
                return fn.next();
              };
              fn.next = function() {
                return index2 < tasks.length - 1 ? makeCallback(index2 + 1) : null;
              };
              return fn;
            };
            return makeCallback(0);
          };
          var _isArray = Array.isArray || function(maybeArray) {
            return Object.prototype.toString.call(maybeArray) === "[object Array]";
          };
          var waterfall = function(tasks, callback, forceAsync) {
            var nextTick2 = forceAsync ? executeAsync : executeSync;
            callback = callback || function() {
            };
            if (!_isArray(tasks)) {
              var err = new Error("First argument to waterfall must be an array of functions");
              return callback(err);
            }
            if (!tasks.length) {
              return callback();
            }
            var wrapIterator = function(iterator) {
              return function(err2) {
                if (err2) {
                  callback.apply(null, arguments);
                  callback = function() {
                  };
                } else {
                  var args = Array.prototype.slice.call(arguments, 1);
                  var next3 = iterator.next();
                  if (next3) {
                    args.push(wrapIterator(next3));
                  } else {
                    args.push(callback);
                  }
                  nextTick2(function() {
                    iterator.apply(null, args);
                  });
                }
              };
            };
            wrapIterator(makeIterator(tasks))();
          };
          {
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
              return waterfall;
            }.apply(exports3, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        })();
      },
      function(module2, exports3, __webpack_require__) {
        var R = typeof Reflect === "object" ? Reflect : null;
        var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
          return Function.prototype.apply.call(target, receiver, args);
        };
        var ReflectOwnKeys;
        if (R && typeof R.ownKeys === "function") {
          ReflectOwnKeys = R.ownKeys;
        } else if (Object.getOwnPropertySymbols) {
          ReflectOwnKeys = function ReflectOwnKeys2(target) {
            return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
          };
        } else {
          ReflectOwnKeys = function ReflectOwnKeys2(target) {
            return Object.getOwnPropertyNames(target);
          };
        }
        function ProcessEmitWarning(warning) {
          if (console && console.warn)
            console.warn(warning);
        }
        var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
          return value !== value;
        };
        function EventEmitter() {
          EventEmitter.init.call(this);
        }
        module2.exports = EventEmitter;
        module2.exports.once = once;
        EventEmitter.EventEmitter = EventEmitter;
        EventEmitter.prototype._events = void 0;
        EventEmitter.prototype._eventsCount = 0;
        EventEmitter.prototype._maxListeners = void 0;
        var defaultMaxListeners = 10;
        function checkListener(listener) {
          if (typeof listener !== "function") {
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
          }
        }
        Object.defineProperty(EventEmitter, "defaultMaxListeners", {
          enumerable: true,
          get: function() {
            return defaultMaxListeners;
          },
          set: function(arg) {
            if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
              throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
            }
            defaultMaxListeners = arg;
          }
        });
        EventEmitter.init = function() {
          if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
            this._events = Object.create(null);
            this._eventsCount = 0;
          }
          this._maxListeners = this._maxListeners || void 0;
        };
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
          if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
          }
          this._maxListeners = n2;
          return this;
        };
        function _getMaxListeners(that) {
          if (that._maxListeners === void 0)
            return EventEmitter.defaultMaxListeners;
          return that._maxListeners;
        }
        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
          return _getMaxListeners(this);
        };
        EventEmitter.prototype.emit = function emit(type) {
          var args = [];
          for (var i2 = 1; i2 < arguments.length; i2++)
            args.push(arguments[i2]);
          var doError = type === "error";
          var events2 = this._events;
          if (events2 !== void 0)
            doError = doError && events2.error === void 0;
          else if (!doError)
            return false;
          if (doError) {
            var er;
            if (args.length > 0)
              er = args[0];
            if (er instanceof Error) {
              throw er;
            }
            var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
            err.context = er;
            throw err;
          }
          var handler = events2[type];
          if (handler === void 0)
            return false;
          if (typeof handler === "function") {
            ReflectApply(handler, this, args);
          } else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i2 = 0; i2 < len; ++i2)
              ReflectApply(listeners[i2], this, args);
          }
          return true;
        };
        function _addListener(target, type, listener, prepend2) {
          var m2;
          var events2;
          var existing;
          checkListener(listener);
          events2 = target._events;
          if (events2 === void 0) {
            events2 = target._events = Object.create(null);
            target._eventsCount = 0;
          } else {
            if (events2.newListener !== void 0) {
              target.emit("newListener", type, listener.listener ? listener.listener : listener);
              events2 = target._events;
            }
            existing = events2[type];
          }
          if (existing === void 0) {
            existing = events2[type] = listener;
            ++target._eventsCount;
          } else {
            if (typeof existing === "function") {
              existing = events2[type] = prepend2 ? [listener, existing] : [existing, listener];
            } else if (prepend2) {
              existing.unshift(listener);
            } else {
              existing.push(listener);
            }
            m2 = _getMaxListeners(target);
            if (m2 > 0 && existing.length > m2 && !existing.warned) {
              existing.warned = true;
              var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
              w2.name = "MaxListenersExceededWarning";
              w2.emitter = target;
              w2.type = type;
              w2.count = existing.length;
              ProcessEmitWarning(w2);
            }
          }
          return target;
        }
        EventEmitter.prototype.addListener = function addListener2(type, listener) {
          return _addListener(this, type, listener, false);
        };
        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
        EventEmitter.prototype.prependListener = function prependListener(type, listener) {
          return _addListener(this, type, listener, true);
        };
        function onceWrapper() {
          if (!this.fired) {
            this.target.removeListener(this.type, this.wrapFn);
            this.fired = true;
            if (arguments.length === 0)
              return this.listener.call(this.target);
            return this.listener.apply(this.target, arguments);
          }
        }
        function _onceWrap(target, type, listener) {
          var state = { fired: false, wrapFn: void 0, target, type, listener };
          var wrapped = onceWrapper.bind(state);
          wrapped.listener = listener;
          state.wrapFn = wrapped;
          return wrapped;
        }
        EventEmitter.prototype.once = function once2(type, listener) {
          checkListener(listener);
          this.on(type, _onceWrap(this, type, listener));
          return this;
        };
        EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
          checkListener(listener);
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };
        EventEmitter.prototype.removeListener = function removeListener2(type, listener) {
          var list, events2, position, i2, originalListener;
          checkListener(listener);
          events2 = this._events;
          if (events2 === void 0)
            return this;
          list = events2[type];
          if (list === void 0)
            return this;
          if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0)
              this._events = Object.create(null);
            else {
              delete events2[type];
              if (events2.removeListener)
                this.emit("removeListener", type, list.listener || listener);
            }
          } else if (typeof list !== "function") {
            position = -1;
            for (i2 = list.length - 1; i2 >= 0; i2--) {
              if (list[i2] === listener || list[i2].listener === listener) {
                originalListener = list[i2].listener;
                position = i2;
                break;
              }
            }
            if (position < 0)
              return this;
            if (position === 0)
              list.shift();
            else {
              spliceOne(list, position);
            }
            if (list.length === 1)
              events2[type] = list[0];
            if (events2.removeListener !== void 0)
              this.emit("removeListener", type, originalListener || listener);
          }
          return this;
        };
        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
        EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
          var listeners, events2, i2;
          events2 = this._events;
          if (events2 === void 0)
            return this;
          if (events2.removeListener === void 0) {
            if (arguments.length === 0) {
              this._events = Object.create(null);
              this._eventsCount = 0;
            } else if (events2[type] !== void 0) {
              if (--this._eventsCount === 0)
                this._events = Object.create(null);
              else
                delete events2[type];
            }
            return this;
          }
          if (arguments.length === 0) {
            var keys = Object.keys(events2);
            var key;
            for (i2 = 0; i2 < keys.length; ++i2) {
              key = keys[i2];
              if (key === "removeListener")
                continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners("removeListener");
            this._events = Object.create(null);
            this._eventsCount = 0;
            return this;
          }
          listeners = events2[type];
          if (typeof listeners === "function") {
            this.removeListener(type, listeners);
          } else if (listeners !== void 0) {
            for (i2 = listeners.length - 1; i2 >= 0; i2--) {
              this.removeListener(type, listeners[i2]);
            }
          }
          return this;
        };
        function _listeners(target, type, unwrap) {
          var events2 = target._events;
          if (events2 === void 0)
            return [];
          var evlistener = events2[type];
          if (evlistener === void 0)
            return [];
          if (typeof evlistener === "function")
            return unwrap ? [evlistener.listener || evlistener] : [evlistener];
          return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
        }
        EventEmitter.prototype.listeners = function listeners(type) {
          return _listeners(this, type, true);
        };
        EventEmitter.prototype.rawListeners = function rawListeners(type) {
          return _listeners(this, type, false);
        };
        EventEmitter.listenerCount = function(emitter, type) {
          if (typeof emitter.listenerCount === "function") {
            return emitter.listenerCount(type);
          } else {
            return listenerCount.call(emitter, type);
          }
        };
        EventEmitter.prototype.listenerCount = listenerCount;
        function listenerCount(type) {
          var events2 = this._events;
          if (events2 !== void 0) {
            var evlistener = events2[type];
            if (typeof evlistener === "function") {
              return 1;
            } else if (evlistener !== void 0) {
              return evlistener.length;
            }
          }
          return 0;
        }
        EventEmitter.prototype.eventNames = function eventNames() {
          return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
        };
        function arrayClone(arr, n2) {
          var copy = new Array(n2);
          for (var i2 = 0; i2 < n2; ++i2)
            copy[i2] = arr[i2];
          return copy;
        }
        function spliceOne(list, index2) {
          for (; index2 + 1 < list.length; index2++)
            list[index2] = list[index2 + 1];
          list.pop();
        }
        function unwrapListeners(arr) {
          var ret = new Array(arr.length);
          for (var i2 = 0; i2 < ret.length; ++i2) {
            ret[i2] = arr[i2].listener || arr[i2];
          }
          return ret;
        }
        function once(emitter, name) {
          return new Promise(function(resolve, reject) {
            function eventListener() {
              if (errorListener !== void 0) {
                emitter.removeListener("error", errorListener);
              }
              resolve([].slice.call(arguments));
            }
            var errorListener;
            if (name !== "error") {
              errorListener = function errorListener2(err) {
                emitter.removeListener(name, eventListener);
                reject(err);
              };
              emitter.once("error", errorListener);
            }
            emitter.once(name, eventListener);
          });
        }
      },
      function(module2, exports3, __webpack_require__) {
        var nodes = __webpack_require__(3);
        var lib = __webpack_require__(0);
        var sym = 0;
        function gensym() {
          return "hole_" + sym++;
        }
        function mapCOW(arr, func) {
          var res = null;
          for (var i2 = 0; i2 < arr.length; i2++) {
            var item = func(arr[i2]);
            if (item !== arr[i2]) {
              if (!res) {
                res = arr.slice();
              }
              res[i2] = item;
            }
          }
          return res || arr;
        }
        function walk(ast, func, depthFirst) {
          if (!(ast instanceof nodes.Node)) {
            return ast;
          }
          if (!depthFirst) {
            var astT = func(ast);
            if (astT && astT !== ast) {
              return astT;
            }
          }
          if (ast instanceof nodes.NodeList) {
            var children2 = mapCOW(ast.children, function(node) {
              return walk(node, func, depthFirst);
            });
            if (children2 !== ast.children) {
              ast = new nodes[ast.typename](ast.lineno, ast.colno, children2);
            }
          } else if (ast instanceof nodes.CallExtension) {
            var args = walk(ast.args, func, depthFirst);
            var contentArgs = mapCOW(ast.contentArgs, function(node) {
              return walk(node, func, depthFirst);
            });
            if (args !== ast.args || contentArgs !== ast.contentArgs) {
              ast = new nodes[ast.typename](ast.extName, ast.prop, args, contentArgs);
            }
          } else {
            var props = ast.fields.map(function(field) {
              return ast[field];
            });
            var propsT = mapCOW(props, function(prop) {
              return walk(prop, func, depthFirst);
            });
            if (propsT !== props) {
              ast = new nodes[ast.typename](ast.lineno, ast.colno);
              propsT.forEach(function(prop, i2) {
                ast[ast.fields[i2]] = prop;
              });
            }
          }
          return depthFirst ? func(ast) || ast : ast;
        }
        function depthWalk(ast, func) {
          return walk(ast, func, true);
        }
        function _liftFilters(node, asyncFilters, prop) {
          var children2 = [];
          var walked = depthWalk(prop ? node[prop] : node, function(descNode) {
            var symbol;
            if (descNode instanceof nodes.Block) {
              return descNode;
            } else if (descNode instanceof nodes.Filter && lib.indexOf(asyncFilters, descNode.name.value) !== -1 || descNode instanceof nodes.CallExtensionAsync) {
              symbol = new nodes.Symbol(descNode.lineno, descNode.colno, gensym());
              children2.push(new nodes.FilterAsync(descNode.lineno, descNode.colno, descNode.name, descNode.args, symbol));
            }
            return symbol;
          });
          if (prop) {
            node[prop] = walked;
          } else {
            node = walked;
          }
          if (children2.length) {
            children2.push(node);
            return new nodes.NodeList(node.lineno, node.colno, children2);
          } else {
            return node;
          }
        }
        function liftFilters(ast, asyncFilters) {
          return depthWalk(ast, function(node) {
            if (node instanceof nodes.Output) {
              return _liftFilters(node, asyncFilters);
            } else if (node instanceof nodes.Set) {
              return _liftFilters(node, asyncFilters, "value");
            } else if (node instanceof nodes.For) {
              return _liftFilters(node, asyncFilters, "arr");
            } else if (node instanceof nodes.If) {
              return _liftFilters(node, asyncFilters, "cond");
            } else if (node instanceof nodes.CallExtension) {
              return _liftFilters(node, asyncFilters, "args");
            } else {
              return void 0;
            }
          });
        }
        function liftSuper(ast) {
          return walk(ast, function(blockNode) {
            if (!(blockNode instanceof nodes.Block)) {
              return;
            }
            var hasSuper = false;
            var symbol = gensym();
            blockNode.body = walk(blockNode.body, function(node) {
              if (node instanceof nodes.FunCall && node.name.value === "super") {
                hasSuper = true;
                return new nodes.Symbol(node.lineno, node.colno, symbol);
              }
            });
            if (hasSuper) {
              blockNode.body.children.unshift(new nodes.Super(0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)));
            }
          });
        }
        function convertStatements(ast) {
          return depthWalk(ast, function(node) {
            if (!(node instanceof nodes.If) && !(node instanceof nodes.For)) {
              return void 0;
            }
            var async = false;
            walk(node, function(child) {
              if (child instanceof nodes.FilterAsync || child instanceof nodes.IfAsync || child instanceof nodes.AsyncEach || child instanceof nodes.AsyncAll || child instanceof nodes.CallExtensionAsync) {
                async = true;
                return child;
              }
              return void 0;
            });
            if (async) {
              if (node instanceof nodes.If) {
                return new nodes.IfAsync(node.lineno, node.colno, node.cond, node.body, node.else_);
              } else if (node instanceof nodes.For && !(node instanceof nodes.AsyncAll)) {
                return new nodes.AsyncEach(node.lineno, node.colno, node.arr, node.name, node.body, node.else_);
              }
            }
            return void 0;
          });
        }
        function cps(ast, asyncFilters) {
          return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));
        }
        function transform2(ast, asyncFilters) {
          return cps(ast, asyncFilters || []);
        }
        module2.exports = {
          transform: transform2
        };
      },
      function(module2, exports3, __webpack_require__) {
        var lib = __webpack_require__(0);
        var r2 = __webpack_require__(2);
        var exports3 = module2.exports = {};
        function normalize(value, defaultValue) {
          if (value === null || value === void 0 || value === false) {
            return defaultValue;
          }
          return value;
        }
        exports3.abs = Math.abs;
        function isNaN2(num) {
          return num !== num;
        }
        function batch(arr, linecount, fillWith) {
          var i2;
          var res = [];
          var tmp2 = [];
          for (i2 = 0; i2 < arr.length; i2++) {
            if (i2 % linecount === 0 && tmp2.length) {
              res.push(tmp2);
              tmp2 = [];
            }
            tmp2.push(arr[i2]);
          }
          if (tmp2.length) {
            if (fillWith) {
              for (i2 = tmp2.length; i2 < linecount; i2++) {
                tmp2.push(fillWith);
              }
            }
            res.push(tmp2);
          }
          return res;
        }
        exports3.batch = batch;
        function capitalize(str) {
          str = normalize(str, "");
          var ret = str.toLowerCase();
          return r2.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));
        }
        exports3.capitalize = capitalize;
        function center(str, width) {
          str = normalize(str, "");
          width = width || 80;
          if (str.length >= width) {
            return str;
          }
          var spaces = width - str.length;
          var pre = lib.repeat(" ", spaces / 2 - spaces % 2);
          var post = lib.repeat(" ", spaces / 2);
          return r2.copySafeness(str, pre + str + post);
        }
        exports3.center = center;
        function default_(val, def, bool) {
          if (bool) {
            return val || def;
          } else {
            return val !== void 0 ? val : def;
          }
        }
        exports3["default"] = default_;
        function dictsort(val, caseSensitive, by) {
          if (!lib.isObject(val)) {
            throw new lib.TemplateError("dictsort filter: val must be an object");
          }
          var array = [];
          for (var k2 in val) {
            array.push([k2, val[k2]]);
          }
          var si;
          if (by === void 0 || by === "key") {
            si = 0;
          } else if (by === "value") {
            si = 1;
          } else {
            throw new lib.TemplateError("dictsort filter: You can only sort by either key or value");
          }
          array.sort(function(t1, t2) {
            var a2 = t1[si];
            var b2 = t2[si];
            if (!caseSensitive) {
              if (lib.isString(a2)) {
                a2 = a2.toUpperCase();
              }
              if (lib.isString(b2)) {
                b2 = b2.toUpperCase();
              }
            }
            return a2 > b2 ? 1 : a2 === b2 ? 0 : -1;
          });
          return array;
        }
        exports3.dictsort = dictsort;
        function dump(obj, spaces) {
          return JSON.stringify(obj, null, spaces);
        }
        exports3.dump = dump;
        function escape2(str) {
          if (str instanceof r2.SafeString) {
            return str;
          }
          str = str === null || str === void 0 ? "" : str;
          return r2.markSafe(lib.escape(str.toString()));
        }
        exports3.escape = escape2;
        function safe(str) {
          if (str instanceof r2.SafeString) {
            return str;
          }
          str = str === null || str === void 0 ? "" : str;
          return r2.markSafe(str.toString());
        }
        exports3.safe = safe;
        function first(arr) {
          return arr[0];
        }
        exports3.first = first;
        function forceescape(str) {
          str = str === null || str === void 0 ? "" : str;
          return r2.markSafe(lib.escape(str.toString()));
        }
        exports3.forceescape = forceescape;
        function groupby(arr, attr2) {
          return lib.groupBy(arr, attr2, this.env.opts.throwOnUndefined);
        }
        exports3.groupby = groupby;
        function indent(str, width, indentfirst) {
          str = normalize(str, "");
          if (str === "") {
            return "";
          }
          width = width || 4;
          var lines = str.split("\n");
          var sp = lib.repeat(" ", width);
          var res = lines.map(function(l2, i2) {
            return i2 === 0 && !indentfirst ? l2 : "" + sp + l2;
          }).join("\n");
          return r2.copySafeness(str, res);
        }
        exports3.indent = indent;
        function join(arr, del, attr2) {
          del = del || "";
          if (attr2) {
            arr = lib.map(arr, function(v2) {
              return v2[attr2];
            });
          }
          return arr.join(del);
        }
        exports3.join = join;
        function last(arr) {
          return arr[arr.length - 1];
        }
        exports3.last = last;
        function lengthFilter(val) {
          var value = normalize(val, "");
          if (value !== void 0) {
            if (typeof Map === "function" && value instanceof Map || typeof Set === "function" && value instanceof Set) {
              return value.size;
            }
            if (lib.isObject(value) && !(value instanceof r2.SafeString)) {
              return lib.keys(value).length;
            }
            return value.length;
          }
          return 0;
        }
        exports3.length = lengthFilter;
        function list(val) {
          if (lib.isString(val)) {
            return val.split("");
          } else if (lib.isObject(val)) {
            return lib._entries(val || {}).map(function(_ref) {
              var key = _ref[0], value = _ref[1];
              return {
                key,
                value
              };
            });
          } else if (lib.isArray(val)) {
            return val;
          } else {
            throw new lib.TemplateError("list filter: type not iterable");
          }
        }
        exports3.list = list;
        function lower(str) {
          str = normalize(str, "");
          return str.toLowerCase();
        }
        exports3.lower = lower;
        function nl2br(str) {
          if (str === null || str === void 0) {
            return "";
          }
          return r2.copySafeness(str, str.replace(/\r\n|\n/g, "<br />\n"));
        }
        exports3.nl2br = nl2br;
        function random(arr) {
          return arr[Math.floor(Math.random() * arr.length)];
        }
        exports3.random = random;
        function getSelectOrReject(expectedTestResult) {
          function filter2(arr, testName, secondArg) {
            if (testName === void 0) {
              testName = "truthy";
            }
            var context2 = this;
            var test = context2.env.getTest(testName);
            return lib.toArray(arr).filter(function examineTestResult(item) {
              return test.call(context2, item, secondArg) === expectedTestResult;
            });
          }
          return filter2;
        }
        exports3.reject = getSelectOrReject(false);
        function rejectattr(arr, attr2) {
          return arr.filter(function(item) {
            return !item[attr2];
          });
        }
        exports3.rejectattr = rejectattr;
        exports3.select = getSelectOrReject(true);
        function selectattr(arr, attr2) {
          return arr.filter(function(item) {
            return !!item[attr2];
          });
        }
        exports3.selectattr = selectattr;
        function replace(str, old, new_, maxCount) {
          var originalStr = str;
          if (old instanceof RegExp) {
            return str.replace(old, new_);
          }
          if (typeof maxCount === "undefined") {
            maxCount = -1;
          }
          var res = "";
          if (typeof old === "number") {
            old = "" + old;
          } else if (typeof old !== "string") {
            return str;
          }
          if (typeof str === "number") {
            str = "" + str;
          }
          if (typeof str !== "string" && !(str instanceof r2.SafeString)) {
            return str;
          }
          if (old === "") {
            res = new_ + str.split("").join(new_) + new_;
            return r2.copySafeness(str, res);
          }
          var nextIndex = str.indexOf(old);
          if (maxCount === 0 || nextIndex === -1) {
            return str;
          }
          var pos = 0;
          var count2 = 0;
          while (nextIndex > -1 && (maxCount === -1 || count2 < maxCount)) {
            res += str.substring(pos, nextIndex) + new_;
            pos = nextIndex + old.length;
            count2++;
            nextIndex = str.indexOf(old, pos);
          }
          if (pos < str.length) {
            res += str.substring(pos);
          }
          return r2.copySafeness(originalStr, res);
        }
        exports3.replace = replace;
        function reverse(val) {
          var arr;
          if (lib.isString(val)) {
            arr = list(val);
          } else {
            arr = lib.map(val, function(v2) {
              return v2;
            });
          }
          arr.reverse();
          if (lib.isString(val)) {
            return r2.copySafeness(val, arr.join(""));
          }
          return arr;
        }
        exports3.reverse = reverse;
        function round(val, precision, method) {
          precision = precision || 0;
          var factor = Math.pow(10, precision);
          var rounder;
          if (method === "ceil") {
            rounder = Math.ceil;
          } else if (method === "floor") {
            rounder = Math.floor;
          } else {
            rounder = Math.round;
          }
          return rounder(val * factor) / factor;
        }
        exports3.round = round;
        function slice(arr, slices, fillWith) {
          var sliceLength = Math.floor(arr.length / slices);
          var extra = arr.length % slices;
          var res = [];
          var offset2 = 0;
          for (var i2 = 0; i2 < slices; i2++) {
            var start = offset2 + i2 * sliceLength;
            if (i2 < extra) {
              offset2++;
            }
            var end = offset2 + (i2 + 1) * sliceLength;
            var currSlice = arr.slice(start, end);
            if (fillWith && i2 >= extra) {
              currSlice.push(fillWith);
            }
            res.push(currSlice);
          }
          return res;
        }
        exports3.slice = slice;
        function sum(arr, attr2, start) {
          if (start === void 0) {
            start = 0;
          }
          if (attr2) {
            arr = lib.map(arr, function(v2) {
              return v2[attr2];
            });
          }
          return start + arr.reduce(function(a2, b2) {
            return a2 + b2;
          }, 0);
        }
        exports3.sum = sum;
        exports3.sort = r2.makeMacro(["value", "reverse", "case_sensitive", "attribute"], [], function sortFilter(arr, reversed, caseSens, attr2) {
          var _this = this;
          var array = lib.map(arr, function(v2) {
            return v2;
          });
          var getAttribute = lib.getAttrGetter(attr2);
          array.sort(function(a2, b2) {
            var x2 = attr2 ? getAttribute(a2) : a2;
            var y = attr2 ? getAttribute(b2) : b2;
            if (_this.env.opts.throwOnUndefined && attr2 && (x2 === void 0 || y === void 0)) {
              throw new TypeError('sort: attribute "' + attr2 + '" resolved to undefined');
            }
            if (!caseSens && lib.isString(x2) && lib.isString(y)) {
              x2 = x2.toLowerCase();
              y = y.toLowerCase();
            }
            if (x2 < y) {
              return reversed ? 1 : -1;
            } else if (x2 > y) {
              return reversed ? -1 : 1;
            } else {
              return 0;
            }
          });
          return array;
        });
        function string(obj) {
          return r2.copySafeness(obj, obj);
        }
        exports3.string = string;
        function striptags(input, preserveLinebreaks) {
          input = normalize(input, "");
          var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>|<!--[\s\S]*?-->/gi;
          var trimmedInput = trim(input.replace(tags, ""));
          var res = "";
          if (preserveLinebreaks) {
            res = trimmedInput.replace(/^ +| +$/gm, "").replace(/ +/g, " ").replace(/(\r\n)/g, "\n").replace(/\n\n\n+/g, "\n\n");
          } else {
            res = trimmedInput.replace(/\s+/gi, " ");
          }
          return r2.copySafeness(input, res);
        }
        exports3.striptags = striptags;
        function title(str) {
          str = normalize(str, "");
          var words = str.split(" ").map(function(word) {
            return capitalize(word);
          });
          return r2.copySafeness(str, words.join(" "));
        }
        exports3.title = title;
        function trim(str) {
          return r2.copySafeness(str, str.replace(/^\s*|\s*$/g, ""));
        }
        exports3.trim = trim;
        function truncate(input, length, killwords, end) {
          var orig = input;
          input = normalize(input, "");
          length = length || 255;
          if (input.length <= length) {
            return input;
          }
          if (killwords) {
            input = input.substring(0, length);
          } else {
            var idx = input.lastIndexOf(" ", length);
            if (idx === -1) {
              idx = length;
            }
            input = input.substring(0, idx);
          }
          input += end !== void 0 && end !== null ? end : "...";
          return r2.copySafeness(orig, input);
        }
        exports3.truncate = truncate;
        function upper(str) {
          str = normalize(str, "");
          return str.toUpperCase();
        }
        exports3.upper = upper;
        function urlencode(obj) {
          var enc = encodeURIComponent;
          if (lib.isString(obj)) {
            return enc(obj);
          } else {
            var keyvals = lib.isArray(obj) ? obj : lib._entries(obj);
            return keyvals.map(function(_ref2) {
              var k2 = _ref2[0], v2 = _ref2[1];
              return enc(k2) + "=" + enc(v2);
            }).join("&");
          }
        }
        exports3.urlencode = urlencode;
        var puncRe = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/;
        var emailRe = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i;
        var httpHttpsRe = /^https?:\/\/.*$/;
        var wwwRe = /^www\./;
        var tldRe = /\.(?:org|net|com)(?:\:|\/|$)/;
        function urlize(str, length, nofollow) {
          if (isNaN2(length)) {
            length = Infinity;
          }
          var noFollowAttr = nofollow === true ? ' rel="nofollow"' : "";
          var words = str.split(/(\s+)/).filter(function(word) {
            return word && word.length;
          }).map(function(word) {
            var matches = word.match(puncRe);
            var possibleUrl = matches ? matches[1] : word;
            var shortUrl = possibleUrl.substr(0, length);
            if (httpHttpsRe.test(possibleUrl)) {
              return '<a href="' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
            }
            if (wwwRe.test(possibleUrl)) {
              return '<a href="http://' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
            }
            if (emailRe.test(possibleUrl)) {
              return '<a href="mailto:' + possibleUrl + '">' + possibleUrl + "</a>";
            }
            if (tldRe.test(possibleUrl)) {
              return '<a href="http://' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
            }
            return word;
          });
          return words.join("");
        }
        exports3.urlize = urlize;
        function wordcount(str) {
          str = normalize(str, "");
          var words = str ? str.match(/\w+/g) : null;
          return words ? words.length : null;
        }
        exports3.wordcount = wordcount;
        function float(val, def) {
          var res = parseFloat(val);
          return isNaN2(res) ? def : res;
        }
        exports3.float = float;
        var intFilter = r2.makeMacro(["value", "default", "base"], [], function doInt(value, defaultValue, base) {
          if (base === void 0) {
            base = 10;
          }
          var res = parseInt(value, base);
          return isNaN2(res) ? defaultValue : res;
        });
        exports3.int = intFilter;
        exports3.d = exports3.default;
        exports3.e = exports3.escape;
      },
      function(module2, exports3, __webpack_require__) {
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o2, p2) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
            o3.__proto__ = p3;
            return o3;
          };
          return _setPrototypeOf(o2, p2);
        }
        var Loader2 = __webpack_require__(6);
        var PrecompiledLoader = /* @__PURE__ */ function(_Loader) {
          _inheritsLoose(PrecompiledLoader2, _Loader);
          function PrecompiledLoader2(compiledTemplates) {
            var _this;
            _this = _Loader.call(this) || this;
            _this.precompiled = compiledTemplates || {};
            return _this;
          }
          var _proto = PrecompiledLoader2.prototype;
          _proto.getSource = function getSource(name) {
            if (this.precompiled[name]) {
              return {
                src: {
                  type: "code",
                  obj: this.precompiled[name]
                },
                path: name
              };
            }
            return null;
          };
          return PrecompiledLoader2;
        }(Loader2);
        module2.exports = {
          PrecompiledLoader
        };
      },
      function(module2, exports3, __webpack_require__) {
        var SafeString = __webpack_require__(2).SafeString;
        function callable(value) {
          return typeof value === "function";
        }
        exports3.callable = callable;
        function defined(value) {
          return value !== void 0;
        }
        exports3.defined = defined;
        function divisibleby(one, two) {
          return one % two === 0;
        }
        exports3.divisibleby = divisibleby;
        function escaped(value) {
          return value instanceof SafeString;
        }
        exports3.escaped = escaped;
        function equalto(one, two) {
          return one === two;
        }
        exports3.equalto = equalto;
        exports3.eq = exports3.equalto;
        exports3.sameas = exports3.equalto;
        function even(value) {
          return value % 2 === 0;
        }
        exports3.even = even;
        function falsy(value) {
          return !value;
        }
        exports3.falsy = falsy;
        function ge(one, two) {
          return one >= two;
        }
        exports3.ge = ge;
        function greaterthan(one, two) {
          return one > two;
        }
        exports3.greaterthan = greaterthan;
        exports3.gt = exports3.greaterthan;
        function le(one, two) {
          return one <= two;
        }
        exports3.le = le;
        function lessthan(one, two) {
          return one < two;
        }
        exports3.lessthan = lessthan;
        exports3.lt = exports3.lessthan;
        function lower(value) {
          return value.toLowerCase() === value;
        }
        exports3.lower = lower;
        function ne(one, two) {
          return one !== two;
        }
        exports3.ne = ne;
        function nullTest(value) {
          return value === null;
        }
        exports3.null = nullTest;
        function number(value) {
          return typeof value === "number";
        }
        exports3.number = number;
        function odd(value) {
          return value % 2 === 1;
        }
        exports3.odd = odd;
        function string(value) {
          return typeof value === "string";
        }
        exports3.string = string;
        function truthy(value) {
          return !!value;
        }
        exports3.truthy = truthy;
        function undefinedTest(value) {
          return value === void 0;
        }
        exports3.undefined = undefinedTest;
        function upper(value) {
          return value.toUpperCase() === value;
        }
        exports3.upper = upper;
        function iterable(value) {
          if (typeof Symbol !== "undefined") {
            return !!value[Symbol.iterator];
          } else {
            return Array.isArray(value) || typeof value === "string";
          }
        }
        exports3.iterable = iterable;
        function mapping(value) {
          var bool = value !== null && value !== void 0 && typeof value === "object" && !Array.isArray(value);
          if (Set) {
            return bool && !(value instanceof Set);
          } else {
            return bool;
          }
        }
        exports3.mapping = mapping;
      },
      function(module2, exports3, __webpack_require__) {
        function _cycler(items) {
          var index2 = -1;
          return {
            current: null,
            reset: function reset2() {
              index2 = -1;
              this.current = null;
            },
            next: function next3() {
              index2++;
              if (index2 >= items.length) {
                index2 = 0;
              }
              this.current = items[index2];
              return this.current;
            }
          };
        }
        function _joiner(sep) {
          sep = sep || ",";
          var first = true;
          return function() {
            var val = first ? "" : sep;
            first = false;
            return val;
          };
        }
        function globals() {
          return {
            range: function range(start, stop2, step) {
              if (typeof stop2 === "undefined") {
                stop2 = start;
                start = 0;
                step = 1;
              } else if (!step) {
                step = 1;
              }
              var arr = [];
              if (step > 0) {
                for (var i2 = start; i2 < stop2; i2 += step) {
                  arr.push(i2);
                }
              } else {
                for (var _i = start; _i > stop2; _i += step) {
                  arr.push(_i);
                }
              }
              return arr;
            },
            cycler: function cycler() {
              return _cycler(Array.prototype.slice.call(arguments));
            },
            joiner: function joiner(sep) {
              return _joiner(sep);
            }
          };
        }
        module2.exports = globals;
      },
      function(module2, exports3, __webpack_require__) {
        var path = __webpack_require__(4);
        module2.exports = function express(env, app) {
          function NunjucksView(name, opts) {
            this.name = name;
            this.path = name;
            this.defaultEngine = opts.defaultEngine;
            this.ext = path.extname(name);
            if (!this.ext && !this.defaultEngine) {
              throw new Error("No default engine was specified and no extension was provided.");
            }
            if (!this.ext) {
              this.name += this.ext = (this.defaultEngine[0] !== "." ? "." : "") + this.defaultEngine;
            }
          }
          NunjucksView.prototype.render = function render3(opts, cb) {
            env.render(this.name, opts, cb);
          };
          app.set("view", NunjucksView);
          app.set("nunjucksEnv", env);
          return env;
        };
      },
      function(module2, exports3, __webpack_require__) {
        var fs = __webpack_require__(4);
        var path = __webpack_require__(4);
        var _require = __webpack_require__(0), _prettifyError = _require._prettifyError;
        var compiler = __webpack_require__(5);
        var _require2 = __webpack_require__(7), Environment = _require2.Environment;
        var precompileGlobal = __webpack_require__(24);
        function match(filename, patterns) {
          if (!Array.isArray(patterns)) {
            return false;
          }
          return patterns.some(function(pattern) {
            return filename.match(pattern);
          });
        }
        function precompileString(str, opts) {
          opts = opts || {};
          opts.isString = true;
          var env = opts.env || new Environment([]);
          var wrapper = opts.wrapper || precompileGlobal;
          if (!opts.name) {
            throw new Error('the "name" option is required when compiling a string');
          }
          return wrapper([_precompile(str, opts.name, env)], opts);
        }
        function precompile(input, opts) {
          opts = opts || {};
          var env = opts.env || new Environment([]);
          var wrapper = opts.wrapper || precompileGlobal;
          if (opts.isString) {
            return precompileString(input, opts);
          }
          var pathStats = fs.existsSync(input) && fs.statSync(input);
          var precompiled = [];
          var templates = [];
          function addTemplates(dir) {
            fs.readdirSync(dir).forEach(function(file) {
              var filepath = path.join(dir, file);
              var subpath = filepath.substr(path.join(input, "/").length);
              var stat = fs.statSync(filepath);
              if (stat && stat.isDirectory()) {
                subpath += "/";
                if (!match(subpath, opts.exclude)) {
                  addTemplates(filepath);
                }
              } else if (match(subpath, opts.include)) {
                templates.push(filepath);
              }
            });
          }
          if (pathStats.isFile()) {
            precompiled.push(_precompile(fs.readFileSync(input, "utf-8"), opts.name || input, env));
          } else if (pathStats.isDirectory()) {
            addTemplates(input);
            for (var i2 = 0; i2 < templates.length; i2++) {
              var name = templates[i2].replace(path.join(input, "/"), "");
              try {
                precompiled.push(_precompile(fs.readFileSync(templates[i2], "utf-8"), name, env));
              } catch (e2) {
                if (opts.force) {
                  console.error(e2);
                } else {
                  throw e2;
                }
              }
            }
          }
          return wrapper(precompiled, opts);
        }
        function _precompile(str, name, env) {
          env = env || new Environment([]);
          var asyncFilters = env.asyncFilters;
          var extensions = env.extensionsList;
          var template;
          name = name.replace(/\\/g, "/");
          try {
            template = compiler.compile(str, asyncFilters, extensions, name, env.opts);
          } catch (err) {
            throw _prettifyError(name, false, err);
          }
          return {
            name,
            template
          };
        }
        module2.exports = {
          precompile,
          precompileString
        };
      },
      function(module2, exports3, __webpack_require__) {
        function precompileGlobal(templates, opts) {
          var out = "";
          opts = opts || {};
          for (var i2 = 0; i2 < templates.length; i2++) {
            var name = JSON.stringify(templates[i2].name);
            var template = templates[i2].template;
            out += "(function() {(window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})[" + name + "] = (function() {\n" + template + "\n})();\n";
            if (opts.asFunction) {
              out += "return function(ctx, cb) { return nunjucks.render(" + name + ", ctx, cb); }\n";
            }
            out += "})();\n";
          }
          return out;
        }
        module2.exports = precompileGlobal;
      },
      function(module2, exports3, __webpack_require__) {
        function installCompat() {
          var runtime = this.runtime;
          var lib = this.lib;
          var Compiler = this.compiler.Compiler;
          var Parser = this.parser.Parser;
          var nodes = this.nodes;
          var lexer = this.lexer;
          var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;
          var orig_memberLookup = runtime.memberLookup;
          var orig_Compiler_assertType;
          var orig_Parser_parseAggregate;
          if (Compiler) {
            orig_Compiler_assertType = Compiler.prototype.assertType;
          }
          if (Parser) {
            orig_Parser_parseAggregate = Parser.prototype.parseAggregate;
          }
          function uninstall() {
            runtime.contextOrFrameLookup = orig_contextOrFrameLookup;
            runtime.memberLookup = orig_memberLookup;
            if (Compiler) {
              Compiler.prototype.assertType = orig_Compiler_assertType;
            }
            if (Parser) {
              Parser.prototype.parseAggregate = orig_Parser_parseAggregate;
            }
          }
          runtime.contextOrFrameLookup = function contextOrFrameLookup(context2, frame, key) {
            var val = orig_contextOrFrameLookup.apply(this, arguments);
            if (val !== void 0) {
              return val;
            }
            switch (key) {
              case "True":
                return true;
              case "False":
                return false;
              case "None":
                return null;
              default:
                return void 0;
            }
          };
          function getTokensState(tokens) {
            return {
              index: tokens.index,
              lineno: tokens.lineno,
              colno: tokens.colno
            };
          }
          if (nodes && Compiler && Parser) {
            var Slice = nodes.Node.extend("Slice", {
              fields: ["start", "stop", "step"],
              init: function init(lineno, colno, start, stop2, step) {
                start = start || new nodes.Literal(lineno, colno, null);
                stop2 = stop2 || new nodes.Literal(lineno, colno, null);
                step = step || new nodes.Literal(lineno, colno, 1);
                this.parent(lineno, colno, start, stop2, step);
              }
            });
            Compiler.prototype.assertType = function assertType(node) {
              if (node instanceof Slice) {
                return;
              }
              orig_Compiler_assertType.apply(this, arguments);
            };
            Compiler.prototype.compileSlice = function compileSlice(node, frame) {
              this._emit("(");
              this._compileExpression(node.start, frame);
              this._emit("),(");
              this._compileExpression(node.stop, frame);
              this._emit("),(");
              this._compileExpression(node.step, frame);
              this._emit(")");
            };
            Parser.prototype.parseAggregate = function parseAggregate() {
              var _this = this;
              var origState = getTokensState(this.tokens);
              origState.colno--;
              origState.index--;
              try {
                return orig_Parser_parseAggregate.apply(this);
              } catch (e2) {
                var errState = getTokensState(this.tokens);
                var rethrow = function rethrow2() {
                  lib._assign(_this.tokens, errState);
                  return e2;
                };
                lib._assign(this.tokens, origState);
                this.peeked = false;
                var tok = this.peekToken();
                if (tok.type !== lexer.TOKEN_LEFT_BRACKET) {
                  throw rethrow();
                } else {
                  this.nextToken();
                }
                var node = new Slice(tok.lineno, tok.colno);
                var isSlice = false;
                for (var i2 = 0; i2 <= node.fields.length; i2++) {
                  if (this.skip(lexer.TOKEN_RIGHT_BRACKET)) {
                    break;
                  }
                  if (i2 === node.fields.length) {
                    if (isSlice) {
                      this.fail("parseSlice: too many slice components", tok.lineno, tok.colno);
                    } else {
                      break;
                    }
                  }
                  if (this.skip(lexer.TOKEN_COLON)) {
                    isSlice = true;
                  } else {
                    var field = node.fields[i2];
                    node[field] = this.parseExpression();
                    isSlice = this.skip(lexer.TOKEN_COLON) || isSlice;
                  }
                }
                if (!isSlice) {
                  throw rethrow();
                }
                return new nodes.Array(tok.lineno, tok.colno, [node]);
              }
            };
          }
          function sliceLookup(obj, start, stop2, step) {
            obj = obj || [];
            if (start === null) {
              start = step < 0 ? obj.length - 1 : 0;
            }
            if (stop2 === null) {
              stop2 = step < 0 ? -1 : obj.length;
            } else if (stop2 < 0) {
              stop2 += obj.length;
            }
            if (start < 0) {
              start += obj.length;
            }
            var results = [];
            for (var i2 = start; ; i2 += step) {
              if (i2 < 0 || i2 > obj.length) {
                break;
              }
              if (step > 0 && i2 >= stop2) {
                break;
              }
              if (step < 0 && i2 <= stop2) {
                break;
              }
              results.push(runtime.memberLookup(obj, i2));
            }
            return results;
          }
          function hasOwnProp(obj, key) {
            return Object.prototype.hasOwnProperty.call(obj, key);
          }
          var ARRAY_MEMBERS = {
            pop: function pop(index2) {
              if (index2 === void 0) {
                return this.pop();
              }
              if (index2 >= this.length || index2 < 0) {
                throw new Error("KeyError");
              }
              return this.splice(index2, 1);
            },
            append: function append2(element) {
              return this.push(element);
            },
            remove: function remove2(element) {
              for (var i2 = 0; i2 < this.length; i2++) {
                if (this[i2] === element) {
                  return this.splice(i2, 1);
                }
              }
              throw new Error("ValueError");
            },
            count: function count2(element) {
              var count3 = 0;
              for (var i2 = 0; i2 < this.length; i2++) {
                if (this[i2] === element) {
                  count3++;
                }
              }
              return count3;
            },
            index: function index2(element) {
              var i2;
              if ((i2 = this.indexOf(element)) === -1) {
                throw new Error("ValueError");
              }
              return i2;
            },
            find: function find2(element) {
              return this.indexOf(element);
            },
            insert: function insert(index2, elem) {
              return this.splice(index2, 0, elem);
            }
          };
          var OBJECT_MEMBERS = {
            items: function items() {
              return lib._entries(this);
            },
            values: function values() {
              return lib._values(this);
            },
            keys: function keys() {
              return lib.keys(this);
            },
            get: function get(key, def) {
              var output = this[key];
              if (output === void 0) {
                output = def;
              }
              return output;
            },
            has_key: function has_key(key) {
              return hasOwnProp(this, key);
            },
            pop: function pop(key, def) {
              var output = this[key];
              if (output === void 0 && def !== void 0) {
                output = def;
              } else if (output === void 0) {
                throw new Error("KeyError");
              } else {
                delete this[key];
              }
              return output;
            },
            popitem: function popitem() {
              var keys = lib.keys(this);
              if (!keys.length) {
                throw new Error("KeyError");
              }
              var k2 = keys[0];
              var val = this[k2];
              delete this[k2];
              return [k2, val];
            },
            setdefault: function setdefault(key, def) {
              if (def === void 0) {
                def = null;
              }
              if (!(key in this)) {
                this[key] = def;
              }
              return this[key];
            },
            update: function update3(kwargs) {
              lib._assign(this, kwargs);
              return null;
            }
          };
          OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;
          OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;
          OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;
          runtime.memberLookup = function memberLookup(obj, val, autoescape) {
            if (arguments.length === 4) {
              return sliceLookup.apply(this, arguments);
            }
            obj = obj || {};
            if (lib.isArray(obj) && hasOwnProp(ARRAY_MEMBERS, val)) {
              return ARRAY_MEMBERS[val].bind(obj);
            }
            if (lib.isObject(obj) && hasOwnProp(OBJECT_MEMBERS, val)) {
              return OBJECT_MEMBERS[val].bind(obj);
            }
            return orig_memberLookup.apply(this, arguments);
          };
          return uninstall;
        }
        module2.exports = installCompat;
      }
    ]);
  });
})(nunjucks$1);
var nunjucks = /* @__PURE__ */ getDefaultExportFromCjs(nunjucks$1.exports);
function templateExtractor(options) {
  const compiledTemplates = {};
  for (const [key, templateRaw] of Object.entries(options.templates)) {
    compiledTemplates[key] = nunjucks.compile(templateRaw);
  }
  const featureHandler = (feature) => {
    feature.result = {};
    for (const key of Object.keys(options.templates)) {
      feature.result[key] = compiledTemplates[key].render(feature.properties);
    }
  };
  if (options.geojson.features) {
    options.geojson.features.forEach(featureHandler);
  } else {
    featureHandler(options.geojson);
  }
  return options.geojson;
}
const Quyuan = {
  templateExtractor
};
export { Quyuan };
//# sourceMappingURL=quyuen.es.js.map
